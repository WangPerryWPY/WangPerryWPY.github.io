<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PerryWang🍎博客</title>
  
  <subtitle>分享软件开发中学到的点滴知识</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-06T13:13:07.439Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>PerryWang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++实现DES加密算法</title>
    <link href="http://yoursite.com/2019/07/06/c-%E5%AE%9E%E7%8E%B0DES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/07/06/c-实现DES加密算法/</id>
    <published>2019-07-06T13:12:25.000Z</published>
    <updated>2019-07-06T13:13:07.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法原理："><a href="#算法原理：" class="headerlink" title="算法原理："></a>算法原理：</h2><p>DES算法是一种对称加密算法，以64位为分组对数据加密，加密和解密用的是同一个算法。它的密钥长度是56位（因为每个第8 位都用作奇偶校验），密钥可以是任意的56位的数，而且可以任意时候改变。其中有极少数被认为是易破解的弱密钥，但是很容易避开它们不用。所以保密性依赖于密钥。 </p><p><strong>其基本流程如下：</strong></p><p>首先要生成一套加密密钥，从用户处取得一个64位长的密码口令，然后通过等分、移位、选取和迭代形成一套16个加密密钥，分别供每一轮运算中使用。</p><p>DES对64位(bit)的明文分组M进行操作，M经过一个初始置换IP，置换成m0。将m0明文分成左半部分和右半部分m0 = (L0，R0)，各32位长。然后进行16轮完全相同的运算（迭代），这些运算被称为函数f，在每一轮运算过程中数据与相应的密钥结合。</p><p>在每一轮中，密钥位移位，然后再从密钥的56位中选出48位。通过一个扩展置换将数据的右半部分扩展成48位，并通过一个异或操作替代成新的48位数据，再将其压缩置换成32位。这四步运算构成了函数f。然后，通过另一个异或运算，函数f的输出与左半部分结合，其结果成为新的右半部分，原来的右半部分成为新的左半部分。将该操作重复16次。</p><p>经过16轮迭代后，左，右半部分合在一起经过一个末置换（数据整理），这样就完成了加密过程。</p><p>DES的解密和加密唯一的不同是密钥的次序相反。如果各轮加密密钥分别是K1，K2，K3…K16，那么解密密钥就是K16，K15，K14…K1。</p><h2 id="总体结构："><a href="#总体结构：" class="headerlink" title="总体结构："></a>总体结构：</h2><p><strong>Feistel结构：</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209200251183.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="模块分解："><a href="#模块分解：" class="headerlink" title="模块分解："></a>模块分解：</h2><h4 id="由给定的密钥获取16个子密钥："><a href="#由给定的密钥获取16个子密钥：" class="headerlink" title="由给定的密钥获取16个子密钥："></a>由给定的密钥获取16个子密钥：</h4><ul><li>对K 的56个非校验位实行置换PC-1，得到C0D0，其中C0 和D0 分别由PC-1 置换后的前28位和后28位组成。 </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//密钥置换表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PC_1[<span class="number">56</span>] = &#123;</span><br><span class="line"><span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,</span><br><span class="line"> <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>,</span><br><span class="line"><span class="number">10</span>,  <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line"><span class="number">19</span>, <span class="number">11</span>,  <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>,</span><br><span class="line"><span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>,</span><br><span class="line"> <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line"><span class="number">14</span>,  <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>,</span><br><span class="line"><span class="number">21</span>, <span class="number">13</span>,  <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>,  <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>计算Ci = LSi(Ci-1) 和Di = LSi(Di-1) </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//密钥置换时每轮移动的位数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> shift[<span class="number">16</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将密钥的前后部分分别左移</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftShift</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> K[<span class="number">28</span>], <span class="keyword">int</span> shift)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ar[<span class="number">28</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(ar, K, <span class="number">28</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">27</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i-shift &lt; <span class="number">0</span>)</span><br><span class="line">K[i] = ar[i-shift+<span class="number">28</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">K[i] = ar[i-shift];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对56位的CiDi 实行PC-2 压缩置换，得到48位的Ki 。i= i+1。 </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//压缩置换表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PC_2[<span class="number">48</span>] = &#123;</span><br><span class="line"><span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>,  <span class="number">1</span>,  <span class="number">5</span>,</span><br><span class="line"> <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>,  <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line"><span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>,  <span class="number">4</span>, <span class="number">26</span>,  <span class="number">8</span>,</span><br><span class="line"><span class="number">16</span>,  <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>,  <span class="number">2</span>,</span><br><span class="line"><span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line"><span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line"><span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line"><span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>之后的16轮按照以上步骤重复得到16个子密钥</li></ul><p>[外链图片转存失败(img-Dov3dif3-1562418750620)(C:\Users\ADMINI~1\AppData\Local\Temp\1540735921928.png)]</p><ul><li><strong>总的算法实现：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMyKey</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">64</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> subKey[<span class="number">16</span>][<span class="number">48</span>])</span> </span>&#123;</span><br><span class="line"><span class="comment">//去掉奇偶检验位的key</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> key_f[<span class="number">56</span>];</span><br><span class="line"><span class="comment">//左半部分</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> L[<span class="number">28</span>];</span><br><span class="line"><span class="comment">//右半部分</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R[<span class="number">28</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> C_key[<span class="number">48</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">56</span>; i++) &#123;</span><br><span class="line">key_f[<span class="number">55</span>-i] = key[<span class="number">64</span>-PC_1[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成左右子密钥</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">28</span>; j++) &#123;</span><br><span class="line">L[j] = key_f[j+<span class="number">28</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">28</span>; j++) &#123;</span><br><span class="line">R[j] = key_f[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左移</span></span><br><span class="line">leftShift(L, shift[i]);</span><br><span class="line">leftShift(R, shift[i]);</span><br><span class="line"><span class="comment">//压缩置换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">28</span>; j++) &#123;</span><br><span class="line">key_f[j+<span class="number">28</span>] = L[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">28</span>; j++) &#123;</span><br><span class="line">key_f[j] = R[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">48</span>; j++) &#123;</span><br><span class="line">C_key[<span class="number">47</span>-j] = key_f[<span class="number">56</span>-PC_2[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(subKey[i], C_key, <span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始IP置换："><a href="#初始IP置换：" class="headerlink" title="初始IP置换："></a>初始IP置换：</h4><p> 给定64位明文块M，通过一个固定的初始置换IP来重排M中的二进制位，得到二进制串M0 = IP(M) = L0 R0，这里L0 和R0分别是M0 的前32位和后32位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IP置换表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> IP[<span class="number">64</span>] = &#123;</span><br><span class="line"><span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line"><span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>,</span><br><span class="line"><span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line"><span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,  <span class="number">1</span>,</span><br><span class="line"><span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line"><span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>,</span><br><span class="line"><span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始置换IP</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> FirstKey[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">FirstKey[<span class="number">63</span>-i] = word[<span class="number">64</span>-IP[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代T"><a href="#迭代T" class="headerlink" title="迭代T"></a>迭代T</h4><ul><li>根据L0R0 按下述规则进行16次迭代，即 </li></ul><p>$$<br>Li= Ri-1,  Ri= Li-1 (XOR) f(Ri-1, Ki), i= 1 .. 16<br>$$</p><ul><li>这里 (XOR) 是32位二进制串按位异或运算，f 是输出32位的Feistel 轮函数；</li><li>16个长度为48位的子密钥Ki(i= 1 .. 16) 由密钥K生成；</li><li>16次迭代后得到L16R16 ;</li><li>左右交换输出R16L16 。</li></ul><p><img src="https://img-blog.csdnimg.cn/20181209200339257.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//16轮迭代</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> L[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">L[i] = FirstKey[i+<span class="number">32</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">R[i] = FirstKey[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> tmp_R[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R1[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(tmp_R, R, <span class="number">32</span>);</span><br><span class="line">f(R, subKey[i], R1);</span><br><span class="line">XOR_32(L, R1);</span><br><span class="line"><span class="built_in">memcpy</span>(R, L, <span class="number">32</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(L, tmp_R, <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>轮询函数Feistel：</strong></p><ul><li>将长度为32位的串Ri-1作E-扩展,成为48位的串E(Ri-1)； </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩展置换表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> E[<span class="number">48</span>] = &#123;</span><br><span class="line"><span class="number">32</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,</span><br><span class="line"> <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,</span><br><span class="line"> <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,</span><br><span class="line"><span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>,</span><br><span class="line"><span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line"><span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>,</span><br><span class="line"><span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>,</span><br><span class="line"><span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>,  <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>将E(Ri-1) 和长度为48位的子密钥Ki作48位二进制串按位异或运算，Ki 由密钥K生成； </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XOR_48</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ER[<span class="number">48</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> K[<span class="number">48</span>])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">48</span>; i++) &#123;</span><br><span class="line">ER[i] ^= K[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将上面得到的结果平均分成8个分组(每个分组长度6位)，各个分 组分别经过8个不同的S-盒进行6-4 转换，得到8个长度分别为4 位的分组； </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S盒置换表，每个S盒是4x16的置换表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S_BOX[<span class="number">8</span>][<span class="number">4</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">14</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">0</span>&#125;, </span><br><span class="line">&#123;<span class="number">15</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">13</span>&#125; </span><br><span class="line">&#125;,</span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">15</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>&#125;,  </span><br><span class="line">&#123;<span class="number">3</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">5</span>&#125;, </span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">15</span>&#125;,  </span><br><span class="line">&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">9</span>&#125;  </span><br><span class="line">&#125;, </span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">10</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">&#123;<span class="number">13</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">12</span>&#125;  </span><br><span class="line">&#125;, </span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">7</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">15</span>&#125;,  </span><br><span class="line">&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,  </span><br><span class="line">&#123;<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>&#125;,  </span><br><span class="line">&#123;<span class="number">3</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">14</span>&#125;  </span><br><span class="line">&#125;,</span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,  </span><br><span class="line">&#123;<span class="number">14</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">14</span>&#125;,  </span><br><span class="line">&#123;<span class="number">11</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>&#125;  </span><br><span class="line">&#125;,</span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>&#125;,  </span><br><span class="line">&#123;<span class="number">10</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">&#123;<span class="number">9</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>&#125;  </span><br><span class="line">&#125;, </span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">&#123;<span class="number">13</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,  </span><br><span class="line">&#123;<span class="number">6</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>&#125;  </span><br><span class="line">&#125;, </span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">13</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,  </span><br><span class="line">&#123;<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>&#125;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>将上面得到的分组结果顺序连接得到长度为32位的串；</li><li>再将上面的32位串经过P-置换，得到的结果作为轮函数f(Ri-1, Ki) 的最终32位输出。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P盒置换表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P[<span class="number">32</span>] = &#123;</span><br><span class="line"><span class="number">16</span>,  <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line"><span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>,</span><br><span class="line"> <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>,</span><br><span class="line"> <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line"> <span class="number">2</span>,  <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>,</span><br><span class="line"><span class="number">32</span>, <span class="number">27</span>,  <span class="number">3</span>,  <span class="number">9</span>,</span><br><span class="line"><span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>,  <span class="number">6</span>,</span><br><span class="line"><span class="number">22</span>, <span class="number">11</span>,  <span class="number">4</span>, <span class="number">25</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>整个函数的实现过程：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//轮询函数Feistel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> R[<span class="number">32</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> K[<span class="number">48</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> R1[<span class="number">32</span>])</span> </span>&#123;</span><br><span class="line"><span class="comment">//将32位进行扩展成48位</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ER[<span class="number">48</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">48</span>; i++) &#123;</span><br><span class="line">ER[<span class="number">47</span>-i] = R[<span class="number">32</span>-E[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展后的R和K异或</span></span><br><span class="line">XOR_48(ER, K);</span><br><span class="line"><span class="comment">//轮询S_Box，将6-&gt;4</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">48</span>; i+=<span class="number">6</span>, j+=<span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> m = (ER[<span class="number">47</span>-i]&lt;&lt;<span class="number">1</span>) +ER[<span class="number">47</span>-i<span class="number">-5</span>];</span><br><span class="line"><span class="keyword">int</span> n = (ER[<span class="number">47</span>-i<span class="number">-1</span>]&lt;&lt;<span class="number">3</span>) + (ER[<span class="number">47</span>-i<span class="number">-2</span>]&lt;&lt;<span class="number">2</span>) + (ER[<span class="number">47</span>-i<span class="number">-3</span>]&lt;&lt;<span class="number">1</span>) + ER[<span class="number">47</span>-i<span class="number">-4</span>];</span><br><span class="line"><span class="keyword">int</span> num = S_BOX[i/<span class="number">6</span>][m][n];</span><br><span class="line"><span class="comment">//printf("%d  %d", m, n);</span></span><br><span class="line">R1[<span class="number">31</span>-j] = (num&amp;<span class="number">0x08</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">R1[<span class="number">31</span>-j<span class="number">-1</span>] = (num&amp;<span class="number">0x04</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">R1[<span class="number">31</span>-j<span class="number">-2</span>] = (num&amp;<span class="number">0x02</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">R1[<span class="number">31</span>-j<span class="number">-3</span>] = num&amp;<span class="number">0x01</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//P置换， 32-&gt;32</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ar[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(ar, R1, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">R1[<span class="number">31</span>-i] = ar[<span class="number">32</span>-P[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加密："><a href="#加密：" class="headerlink" title="加密："></a>加密：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnCode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> word[<span class="number">64</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> cipher[<span class="number">64</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> subKey[<span class="number">16</span>][<span class="number">48</span>])</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始置换IP</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> FirstKey[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">FirstKey[<span class="number">63</span>-i] = word[<span class="number">64</span>-IP[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//16轮迭代</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> L[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">L[i] = FirstKey[i+<span class="number">32</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">R[i] = FirstKey[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> tmp_R[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R1[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(tmp_R, R, <span class="number">32</span>);</span><br><span class="line">f(R, subKey[i], R1);</span><br><span class="line">XOR_32(L, R1);</span><br><span class="line"><span class="built_in">memcpy</span>(R, L, <span class="number">32</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(L, tmp_R, <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并迭代后的L和R,并进行IP-1的置换</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> LR[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">LR[i] = L[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">LR[i+<span class="number">32</span>] = R[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> tmp_LR[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(tmp_LR, LR, <span class="number">64</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">cipher[<span class="number">63</span>-i] = tmp_LR[<span class="number">64</span>-IP_1[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解密："><a href="#解密：" class="headerlink" title="解密："></a>解密：</h4><ul><li>分析所有的代替、置换、异或和循环移动过程，获得一个非常 有用的性质：DES 的加密和解密可使用相同的算法和密钥。 </li><li>DES 的过程设计使得用相同的函数来加密或解密每个分组成为 可能。加解密过程中使用由同一个密钥K 经过相同的子密钥生 成算法得到的子密钥序列，唯一不同之处是加解密过程中子密 钥的调度次序恰好相反。<ul><li>加密过程的子密钥按(K1 K2 … K15 K16) 次序调度</li><li>解密过程的子密钥按(K16 K15 … K2 K1) 次序调度</li></ul></li></ul><p><strong>代码实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeCode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> cipher[<span class="number">64</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> word[<span class="number">64</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> subKey[<span class="number">16</span>][<span class="number">48</span>])</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始置换IP</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> FirstKey[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">FirstKey[<span class="number">63</span>-i] = cipher[<span class="number">64</span>-IP[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//16轮迭代</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> L[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">L[i] = FirstKey[i+<span class="number">32</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">R[i] = FirstKey[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> tmp_R[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R1[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(tmp_R, R, <span class="number">32</span>);</span><br><span class="line">f(R, subKey[<span class="number">15</span>-i], R1);</span><br><span class="line">XOR_32(L, R1);</span><br><span class="line"><span class="built_in">memcpy</span>(R, L, <span class="number">32</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(L, tmp_R, <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并迭代后的L和R,并进行IP-1的置换</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> LR[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">LR[i] = L[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">LR[i+<span class="number">32</span>] = R[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> tmp_LR[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(tmp_LR, LR, <span class="number">64</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">word[<span class="number">63</span>-i] = tmp_LR[<span class="number">64</span>-IP_1[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h2><p>使用<strong>unsigned char数组</strong>来存储二进制位串</p><p>通过c语言的移位操作符实现二进制位串的逻辑运算。</p><p><strong>通过以下代码实现字符串与二进制位串的转换：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符转换成二进制符号 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CharToBit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> c, <span class="keyword">unsigned</span> <span class="keyword">char</span> bit[<span class="number">8</span>])</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;  </span><br><span class="line">        *(bit+i) = (c&gt;&gt;i) &amp; <span class="number">1</span>;  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line"><span class="comment">//将长度为8的字符串转为64位二进制  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringToBits</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> c[<span class="number">8</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> bit[<span class="number">64</span>])</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;          </span><br><span class="line">        CharToBit(*(c + i), bit + (i&lt;&lt;<span class="number">3</span>));  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//二进制转换成字节  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitToChar</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> bit[<span class="number">8</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> *c)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;  </span><br><span class="line">        *c |= *(bit + i) &lt;&lt; i;  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将二进制字节转为长度为8的字符串  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitsToString</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> bit[<span class="number">64</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> c[<span class="number">8</span>])</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="number">8</span>);  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;  </span><br><span class="line">        BitToChar(bit + (i&lt;&lt;<span class="number">3</span>), c + i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二进制位串的一些逻辑运算如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XOR_32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ER[<span class="number">32</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> K[<span class="number">32</span>])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">ER[i] ^= K[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = (ER[<span class="number">47</span>-i]&lt;&lt;<span class="number">1</span>) +ER[<span class="number">47</span>-i<span class="number">-5</span>];</span><br><span class="line"><span class="keyword">int</span> n = (ER[<span class="number">47</span>-i<span class="number">-1</span>]&lt;&lt;<span class="number">3</span>) + (ER[<span class="number">47</span>-i<span class="number">-2</span>]&lt;&lt;<span class="number">2</span>) + (ER[<span class="number">47</span>-i<span class="number">-3</span>]&lt;&lt;<span class="number">1</span>) + ER[<span class="number">47</span>-i<span class="number">-4</span>];</span><br><span class="line"><span class="keyword">int</span> num = S_BOX[i/<span class="number">6</span>][m][n];</span><br><span class="line"><span class="comment">//printf("%d  %d", m, n);</span></span><br><span class="line">R1[<span class="number">31</span>-j] = (num&amp;<span class="number">0x08</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">R1[<span class="number">31</span>-j<span class="number">-1</span>] = (num&amp;<span class="number">0x04</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">R1[<span class="number">31</span>-j<span class="number">-2</span>] = (num&amp;<span class="number">0x02</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">R1[<span class="number">31</span>-j<span class="number">-3</span>] = num&amp;<span class="number">0x01</span>;</span><br></pre></td></tr></table></figure><h2 id="编译运行结果："><a href="#编译运行结果：" class="headerlink" title="编译运行结果："></a>编译运行结果：</h2><p><strong>用于测试的main文件：</strong></p><ul><li>将加密的文字存到一个记事本里，解密过程读取记事本中的位串进行解码。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"desCode.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please input the words you want to encode: \n\n"</span>);</span><br><span class="line"><span class="comment">//加密的文字</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> word[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memset</span>(word, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *s_word = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">gets(s_word);</span><br><span class="line"><span class="built_in">strcpy</span>(word, s_word);</span><br><span class="line"><span class="built_in">free</span>(s_word);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> words[<span class="number">64</span>];</span><br><span class="line">StringToBits(word, words);</span><br><span class="line"><span class="comment">//密钥</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c_key[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//取1~9的随机数作为密钥</span></span><br><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> key_1 = rand() % <span class="number">10</span>;</span><br><span class="line">c_key[i] = key_1 + <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nthe key help us to encode is: \n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, c_key[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"><span class="comment">//unsigned char *c_key = "12342a78";</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">64</span>];</span><br><span class="line">StringToBits(c_key, key);</span><br><span class="line"><span class="comment">//根据提供的密钥生成16个子密钥</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> subKey[<span class="number">16</span>][<span class="number">48</span>];</span><br><span class="line">getMyKey(key, subKey);</span><br><span class="line"><span class="comment">//加密过程</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> cipher[<span class="number">64</span>];</span><br><span class="line">EnCode(words, cipher, subKey);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"After encode, your cipher is: \n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, cipher[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"><span class="comment">//将密码写到密码本里面</span></span><br><span class="line">FILE *fp;</span><br><span class="line">fp = fopen(<span class="string">"code.txt"</span>,<span class="string">"w+t"</span>);</span><br><span class="line">fwrite(cipher, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="number">64</span>, fp);</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="comment">//将密码本的密码读取出</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> cipher_read[<span class="number">64</span>];</span><br><span class="line">fp = fopen(<span class="string">"code.txt"</span>,<span class="string">"r+t"</span>);</span><br><span class="line">fread(cipher_read, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="number">64</span>, fp);</span><br><span class="line"><span class="comment">//fscanf(fp, "%s", cipher_read);</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="comment">//解密过程</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> decode[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> answer[<span class="number">8</span>];</span><br><span class="line">DeCode(cipher_read, decode, subKey);</span><br><span class="line">BitsToString(decode, answer);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"After decode, your answer is: \n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, answer[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br><img src="https://img-blog.csdnimg.cn/20181209200433922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法原理：&quot;&gt;&lt;a href=&quot;#算法原理：&quot; class=&quot;headerlink&quot; title=&quot;算法原理：&quot;&gt;&lt;/a&gt;算法原理：&lt;/h2&gt;&lt;p&gt;DES算法是一种对称加密算法，以64位为分组对数据加密，加密和解密用的是同一个算法。它的密钥长度是56位（因为每个第
      
    
    </summary>
    
      <category term="信息安全技术" scheme="http://yoursite.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="信息安全技术" scheme="http://yoursite.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>c++实现MD5</title>
    <link href="http://yoursite.com/2019/07/06/c-%E5%AE%9E%E7%8E%B0MD5/"/>
    <id>http://yoursite.com/2019/07/06/c-实现MD5/</id>
    <published>2019-07-06T13:10:58.000Z</published>
    <updated>2019-07-06T13:11:57.393Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MD5算法简介："><a href="#MD5算法简介：" class="headerlink" title="MD5算法简介："></a>MD5算法简介：</h4><p>消息摘要算法第五版（英语：Message-Digest Algorithm 5，缩写为MD5），是当前计算机领域用于确保信息传输完整一致而广泛使用的散列算法之一（又译哈希算法、摘要算法等），主流编程语言普遍已有MD5的实现。将数据 （如一段文字）运算变为另一固定长度值，是散列算法的基础原理，MD5的前身有MD2、MD3和MD4。MD5由MD4、MD3、MD2改进而来，主要增强算法复杂度和不可逆性。目前，MD5算法因其普遍、稳定、快速的特点，仍广泛应用于普通 数据的错误检查领域。例如在一些BitTorrent下载中，软件将通过计算MD5检验下载到的文件片段的完整性。MD5已经广泛使用在为文件传输提供一定的可靠性方面。例如，服务器预先提供一个MD5校验和，用户下载完文件以后， 用MD5算法计算下载文件的MD5校验和，然后通过检查这两个校验和是否一致，就能判断下载的文件是否出错。MD5是输入不定长度信息，输出固定长度128-bits的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个 128-bits散列。基本方式为，求余、取余、调整长度、与链接变量进行循环运算。得出结果。</p><h4 id="MD5运算步骤："><a href="#MD5运算步骤：" class="headerlink" title="MD5运算步骤："></a>MD5运算步骤：</h4><p>假设输入信息(input message)的长度为b(bit)，我们想要产生它的报文摘要，在此处b为任意的非负整数：b也可能为0，也不一定为8的整数倍，且可能是任意大的长度。设该信息的比特流表示如下： M[0] M[1] M[2] … M[b-1] 计算此信息的报文摘要需要如下5步：</p><p><strong>1.补位</strong></p><p>信息计算前先要进行位补位，设补位后信息的长度为LEN(bit)，则LEN%512 = 448(bit)，即数据扩展至 K * 512 + 448(bit)。即K * 64+56(byte)，K为整数。补位操作始终要执行，即使补位前信息的长度对512求余的结果是448。具体补位操作：补一个1，然后补0至满足上述要求。总共最少要补1bit，最多补512bit。</p><p><strong>2.尾部加上信息长度</strong></p><p>将输入信息的原始长度b(bit)表示成一个64-bit的数字，把它添加到上一步的结果后面(在32位的机器上，这64位将用2个字来表示并且低位在前)。当遇到b大于2^64这种极少的情况时，b的高位被截去，仅使用b的低64位。经过上面两步，数据就被填补成长度为512(bit)的倍数。也就是说，此时的数据长度是16个字(32byte)的整数倍。此时的数据表示为： M[0 … N-1] 其中的N是16的倍数。</p><p><strong>3.初始化缓存区</strong></p><p>用一个四个字的缓冲器(A，B，C，D)来计算报文摘要，A,B,C,D分别是32位的寄存器，初始化使用的是十六进制表示的数字，注意低字节在前： word A: 01 23 45 67 word B: 89 ab cd ef word C: fe dc ba 98 word D: 76 54 32 10</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">0x67452301</span>;</span><br><span class="line">B = <span class="number">0xEFCDAB89</span>;</span><br><span class="line">C = <span class="number">0x98BADCFE</span>;</span><br><span class="line">D = <span class="number">0x10325476</span>;</span><br></pre></td></tr></table></figure><p><strong>4.转换</strong></p><p>四轮循环运算：循环的次数是分组的个数（N+1）：</p><p>1）将每一512字节细分成16个小组，每个小组64位（8个字节） </p><p>2）用到的作为辅助的四个线性函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">unsigned</span> <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x &amp; y) | ((~x) &amp; z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">G</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">unsigned</span> <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x &amp; z) | (y &amp; (~z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">H</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">unsigned</span> <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x ^ y ^ z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">I</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">unsigned</span> <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> y ^ (x | (~z));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）x表示消息的某个子分组（从0到15），&lt;&lt; </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">FF</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">int</span> b, <span class="keyword">unsigned</span> <span class="keyword">int</span> c, <span class="keyword">unsigned</span> <span class="keyword">int</span> d, <span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">unsigned</span> <span class="keyword">int</span> ac)</span> </span>&#123;</span><br><span class="line">a += F(b, c, d) + x + ac;</span><br><span class="line">a = (a &lt;&lt; s) | (a &gt;&gt; (<span class="number">32</span> - s));</span><br><span class="line">a += b;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GG</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">int</span> b, <span class="keyword">unsigned</span> <span class="keyword">int</span> c, <span class="keyword">unsigned</span> <span class="keyword">int</span> d, <span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">unsigned</span> <span class="keyword">int</span> ac)</span> </span>&#123;</span><br><span class="line">a += G(b, c, d) + x + ac;</span><br><span class="line">a = (a &lt;&lt; s) | (a &gt;&gt; (<span class="number">32</span> - s));</span><br><span class="line">a += b;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">HH</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">int</span> b, <span class="keyword">unsigned</span> <span class="keyword">int</span> c, <span class="keyword">unsigned</span> <span class="keyword">int</span> d, <span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">unsigned</span> <span class="keyword">int</span> ac)</span> </span>&#123;</span><br><span class="line">a += H(b, c, d) + x + ac;</span><br><span class="line">a = (a &lt;&lt; s) | (a &gt;&gt; (<span class="number">32</span> - s));</span><br><span class="line">a += b;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">II</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">int</span> b, <span class="keyword">unsigned</span> <span class="keyword">int</span> c, <span class="keyword">unsigned</span> <span class="keyword">int</span> d, <span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">unsigned</span> <span class="keyword">int</span> ac)</span> </span>&#123;</span><br><span class="line">a += I(b, c, d) + x + ac;</span><br><span class="line">a = (a &lt;&lt; s) | (a &gt;&gt; (<span class="number">32</span> - s));</span><br><span class="line">a += b;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）四轮运算 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MD5::transform(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *block) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a = A, b = B, c = C, d = D;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> groups[<span class="number">16</span>];</span><br><span class="line">decode(groups, block, <span class="number">64</span>);</span><br><span class="line"><span class="comment">//groups[15] = 0;</span></span><br><span class="line">a = FF(a, b, c, d, groups[<span class="number">0</span>], S11, <span class="number">0xd76aa478</span>L); <span class="comment">/* 1 */</span></span><br><span class="line">    d = FF(d, a, b, c, groups[<span class="number">1</span>], S12, <span class="number">0xe8c7b756</span>L); <span class="comment">/* 2 */</span></span><br><span class="line">    c = FF(c, d, a, b, groups[<span class="number">2</span>], S13, <span class="number">0x242070db</span>L); <span class="comment">/* 3 */</span></span><br><span class="line">    b = FF(b, c, d, a, groups[<span class="number">3</span>], S14, <span class="number">0xc1bdceee</span>L); <span class="comment">/* 4 */</span></span><br><span class="line">    a = FF(a, b, c, d, groups[<span class="number">4</span>], S11, <span class="number">0xf57c0faf</span>L); <span class="comment">/* 5 */</span></span><br><span class="line">    d = FF(d, a, b, c, groups[<span class="number">5</span>], S12, <span class="number">0x4787c62a</span>L); <span class="comment">/* 6 */</span></span><br><span class="line">    c = FF(c, d, a, b, groups[<span class="number">6</span>], S13, <span class="number">0xa8304613</span>L); <span class="comment">/* 7 */</span></span><br><span class="line">    b = FF(b, c, d, a, groups[<span class="number">7</span>], S14, <span class="number">0xfd469501</span>L); <span class="comment">/* 8 */</span></span><br><span class="line">    a = FF(a, b, c, d, groups[<span class="number">8</span>], S11, <span class="number">0x698098d8</span>L); <span class="comment">/* 9 */</span></span><br><span class="line">    d = FF(d, a, b, c, groups[<span class="number">9</span>], S12, <span class="number">0x8b44f7af</span>L); <span class="comment">/* 10 */</span></span><br><span class="line">    c = FF(c, d, a, b, groups[<span class="number">10</span>], S13, <span class="number">0xffff5bb1</span>L); <span class="comment">/* 11 */</span></span><br><span class="line">    b = FF(b, c, d, a, groups[<span class="number">11</span>], S14, <span class="number">0x895cd7be</span>L); <span class="comment">/* 12 */</span></span><br><span class="line">    a = FF(a, b, c, d, groups[<span class="number">12</span>], S11, <span class="number">0x6b901122</span>L); <span class="comment">/* 13 */</span></span><br><span class="line">    d = FF(d, a, b, c, groups[<span class="number">13</span>], S12, <span class="number">0xfd987193</span>L); <span class="comment">/* 14 */</span></span><br><span class="line">    c = FF(c, d, a, b, groups[<span class="number">14</span>], S13, <span class="number">0xa679438e</span>L); <span class="comment">/* 15 */</span></span><br><span class="line">    b = FF(b, c, d, a, groups[<span class="number">15</span>], S14, <span class="number">0x49b40821</span>L); <span class="comment">/* 16 */</span></span><br><span class="line">    <span class="comment">/*第二轮*/</span></span><br><span class="line">    a = GG(a, b, c, d, groups[<span class="number">1</span>], S21, <span class="number">0xf61e2562</span>L); <span class="comment">/* 17 */</span></span><br><span class="line">    d = GG(d, a, b, c, groups[<span class="number">6</span>], S22, <span class="number">0xc040b340</span>L); <span class="comment">/* 18 */</span></span><br><span class="line">    c = GG(c, d, a, b, groups[<span class="number">11</span>], S23, <span class="number">0x265e5a51</span>L); <span class="comment">/* 19 */</span></span><br><span class="line">    b = GG(b, c, d, a, groups[<span class="number">0</span>], S24, <span class="number">0xe9b6c7aa</span>L); <span class="comment">/* 20 */</span></span><br><span class="line">    a = GG(a, b, c, d, groups[<span class="number">5</span>], S21, <span class="number">0xd62f105d</span>L); <span class="comment">/* 21 */</span></span><br><span class="line">    d = GG(d, a, b, c, groups[<span class="number">10</span>], S22, <span class="number">0x2441453</span>L); <span class="comment">/* 22 */</span></span><br><span class="line">    c = GG(c, d, a, b, groups[<span class="number">15</span>], S23, <span class="number">0xd8a1e681</span>L); <span class="comment">/* 23 */</span></span><br><span class="line">    b = GG(b, c, d, a, groups[<span class="number">4</span>], S24, <span class="number">0xe7d3fbc8</span>L); <span class="comment">/* 24 */</span></span><br><span class="line">    a = GG(a, b, c, d, groups[<span class="number">9</span>], S21, <span class="number">0x21e1cde6</span>L); <span class="comment">/* 25 */</span></span><br><span class="line">    d = GG(d, a, b, c, groups[<span class="number">14</span>], S22, <span class="number">0xc33707d6</span>L); <span class="comment">/* 26 */</span></span><br><span class="line">    c = GG(c, d, a, b, groups[<span class="number">3</span>], S23, <span class="number">0xf4d50d87</span>L); <span class="comment">/* 27 */</span></span><br><span class="line">    b = GG(b, c, d, a, groups[<span class="number">8</span>], S24, <span class="number">0x455a14ed</span>L); <span class="comment">/* 28 */</span></span><br><span class="line">    a = GG(a, b, c, d, groups[<span class="number">13</span>], S21, <span class="number">0xa9e3e905</span>L); <span class="comment">/* 29 */</span></span><br><span class="line">    d = GG(d, a, b, c, groups[<span class="number">2</span>], S22, <span class="number">0xfcefa3f8</span>L); <span class="comment">/* 30 */</span></span><br><span class="line">    c = GG(c, d, a, b, groups[<span class="number">7</span>], S23, <span class="number">0x676f02d9</span>L); <span class="comment">/* 31 */</span></span><br><span class="line">    b = GG(b, c, d, a, groups[<span class="number">12</span>], S24, <span class="number">0x8d2a4c8a</span>L); <span class="comment">/* 32 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第三轮*/</span></span><br><span class="line">    a = HH(a, b, c, d, groups[<span class="number">5</span>], S31, <span class="number">0xfffa3942</span>L); <span class="comment">/* 33 */</span></span><br><span class="line">    d = HH(d, a, b, c, groups[<span class="number">8</span>], S32, <span class="number">0x8771f681</span>L); <span class="comment">/* 34 */</span></span><br><span class="line">    c = HH(c, d, a, b, groups[<span class="number">11</span>], S33, <span class="number">0x6d9d6122</span>L); <span class="comment">/* 35 */</span></span><br><span class="line">    b = HH(b, c, d, a, groups[<span class="number">14</span>], S34, <span class="number">0xfde5380c</span>L); <span class="comment">/* 36 */</span></span><br><span class="line">    a = HH(a, b, c, d, groups[<span class="number">1</span>], S31, <span class="number">0xa4beea44</span>L); <span class="comment">/* 37 */</span></span><br><span class="line">    d = HH(d, a, b, c, groups[<span class="number">4</span>], S32, <span class="number">0x4bdecfa9</span>L); <span class="comment">/* 38 */</span></span><br><span class="line">    c = HH(c, d, a, b, groups[<span class="number">7</span>], S33, <span class="number">0xf6bb4b60</span>L); <span class="comment">/* 39 */</span></span><br><span class="line">    b = HH(b, c, d, a, groups[<span class="number">10</span>], S34, <span class="number">0xbebfbc70</span>L); <span class="comment">/* 40 */</span></span><br><span class="line">    a = HH(a, b, c, d, groups[<span class="number">13</span>], S31, <span class="number">0x289b7ec6</span>L); <span class="comment">/* 41 */</span></span><br><span class="line">    d = HH(d, a, b, c, groups[<span class="number">0</span>], S32, <span class="number">0xeaa127fa</span>L); <span class="comment">/* 42 */</span></span><br><span class="line">    c = HH(c, d, a, b, groups[<span class="number">3</span>], S33, <span class="number">0xd4ef3085</span>L); <span class="comment">/* 43 */</span></span><br><span class="line">    b = HH(b, c, d, a, groups[<span class="number">6</span>], S34, <span class="number">0x4881d05</span>L); <span class="comment">/* 44 */</span></span><br><span class="line">    a = HH(a, b, c, d, groups[<span class="number">9</span>], S31, <span class="number">0xd9d4d039</span>L); <span class="comment">/* 45 */</span></span><br><span class="line">    d = HH(d, a, b, c, groups[<span class="number">12</span>], S32, <span class="number">0xe6db99e5</span>L); <span class="comment">/* 46 */</span></span><br><span class="line">    c = HH(c, d, a, b, groups[<span class="number">15</span>], S33, <span class="number">0x1fa27cf8</span>L); <span class="comment">/* 47 */</span></span><br><span class="line">    b = HH(b, c, d, a, groups[<span class="number">2</span>], S34, <span class="number">0xc4ac5665</span>L); <span class="comment">/* 48 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第四轮*/</span></span><br><span class="line">    a = II(a, b, c, d, groups[<span class="number">0</span>], S41, <span class="number">0xf4292244</span>L); <span class="comment">/* 49 */</span></span><br><span class="line">    d = II(d, a, b, c, groups[<span class="number">7</span>], S42, <span class="number">0x432aff97</span>L); <span class="comment">/* 50 */</span></span><br><span class="line">    c = II(c, d, a, b, groups[<span class="number">14</span>], S43, <span class="number">0xab9423a7</span>L); <span class="comment">/* 51 */</span></span><br><span class="line">    b = II(b, c, d, a, groups[<span class="number">5</span>], S44, <span class="number">0xfc93a039</span>L); <span class="comment">/* 52 */</span></span><br><span class="line">    a = II(a, b, c, d, groups[<span class="number">12</span>], S41, <span class="number">0x655b59c3</span>L); <span class="comment">/* 53 */</span></span><br><span class="line">    d = II(d, a, b, c, groups[<span class="number">3</span>], S42, <span class="number">0x8f0ccc92</span>L); <span class="comment">/* 54 */</span></span><br><span class="line">    c = II(c, d, a, b, groups[<span class="number">10</span>], S43, <span class="number">0xffeff47d</span>L); <span class="comment">/* 55 */</span></span><br><span class="line">    b = II(b, c, d, a, groups[<span class="number">1</span>], S44, <span class="number">0x85845dd1</span>L); <span class="comment">/* 56 */</span></span><br><span class="line">    a = II(a, b, c, d, groups[<span class="number">8</span>], S41, <span class="number">0x6fa87e4f</span>L); <span class="comment">/* 57 */</span></span><br><span class="line">    d = II(d, a, b, c, groups[<span class="number">15</span>], S42, <span class="number">0xfe2ce6e0</span>L); <span class="comment">/* 58 */</span></span><br><span class="line">    c = II(c, d, a, b, groups[<span class="number">6</span>], S43, <span class="number">0xa3014314</span>L); <span class="comment">/* 59 */</span></span><br><span class="line">    b = II(b, c, d, a, groups[<span class="number">13</span>], S44, <span class="number">0x4e0811a1</span>L); <span class="comment">/* 60 */</span></span><br><span class="line">    a = II(a, b, c, d, groups[<span class="number">4</span>], S41, <span class="number">0xf7537e82</span>L); <span class="comment">/* 61 */</span></span><br><span class="line">    d = II(d, a, b, c, groups[<span class="number">11</span>], S42, <span class="number">0xbd3af235</span>L); <span class="comment">/* 62 */</span></span><br><span class="line">    c = II(c, d, a, b, groups[<span class="number">2</span>], S43, <span class="number">0x2ad7d2bb</span>L); <span class="comment">/* 63 */</span></span><br><span class="line">    b = II(b, c, d, a, groups[<span class="number">9</span>], S44, <span class="number">0xeb86d391</span>L); <span class="comment">/* 64 */</span></span><br><span class="line"></span><br><span class="line">A += a;</span><br><span class="line">    B += b;</span><br><span class="line">    C += c;</span><br><span class="line">    D += d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数中两个比较重要的模块</strong>，其中一个是update函数，也是大部分摘要算法都具有的操作：</p><p>作用主要是更新MD5块。然后继续MD5消息摘要操作，处理另一个消息块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MD5::update(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *input, <span class="keyword">int</span> length) &#123;</span><br><span class="line">inputNum += (length &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">64</span> - bufferNum;</span><br><span class="line">    <span class="comment">////将输入的一部分复制到buffer所以它可以形成一个块（size = 64）</span></span><br><span class="line">    <span class="keyword">if</span>(start &lt;= length)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//可以形成一个块，然后对这个块做四轮循环</span></span><br><span class="line">            <span class="built_in">memcpy</span>(&amp;buffer[bufferNum], input, start);</span><br><span class="line">            transform(buffer);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i = start; i &lt;= length - <span class="number">64</span>; i += <span class="number">64</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform(&amp;input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            bufferNum = length - i;  </span><br><span class="line">            <span class="built_in">memcpy</span>(buffer, &amp;input[i], bufferNum);  </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//不能形成块</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;buffer[bufferNum], input, length);</span><br><span class="line">        bufferNum += length;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再是Final函数，作用是使用100000填充buffer, 并添加64位原始大小的输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MD5::Final()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">56</span> - bufferNum;  <span class="comment">//56 = 448/8</span></span><br><span class="line">    <span class="comment">//填充</span></span><br><span class="line">    <span class="keyword">if</span>(temp &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        update(padding, temp);</span><br><span class="line"></span><br><span class="line">        inputNum -= (temp &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        update(padding, <span class="number">64</span> + temp);</span><br><span class="line">        inputNum -= ((<span class="number">64</span> + temp) &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//trans inputNum(输入的位数) to unsigned char (64bits)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> Bits[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//cout &lt;&lt; inputNum &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; inputNum &lt;&lt; endl;</span></span><br><span class="line">        Bits[i] = (inputNum &gt;&gt; <span class="number">8</span>*i) &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; (int)Bits[4] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//添加最初输入的num(后64位)</span></span><br><span class="line">    update(Bits, <span class="number">8</span>); </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> input[<span class="number">4</span>];</span><br><span class="line">    input[<span class="number">0</span>] = A;</span><br><span class="line">   input[<span class="number">1</span>] = B;</span><br><span class="line">   input[<span class="number">2</span>] = C;</span><br><span class="line">   input[<span class="number">3</span>] = D;</span><br><span class="line">   <span class="comment">//将input存入result</span></span><br><span class="line">    encode(result, input, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后将整个模块整合为类：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD5</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> cipher;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> A;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> B;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> C;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> D;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> bufferNum;  <span class="comment">//</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> inputNum;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> result[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MD5();</span><br><span class="line">~MD5();</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fiename)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readCipher</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *input, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *output, <span class="keyword">unsigned</span> <span class="keyword">int</span> *input, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *output, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* input, <span class="keyword">const</span> <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *block)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Final</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><p><strong>将要加密的文本写入到密码本中：</strong><br><img src="https://img-blog.csdnimg.cn/20181209195553162.png" alt="在这里插入图片描述"></p><p><strong>运行结果：</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209195631415.png" alt="在这里插入图片描述"></p><p><strong>然后与加密网站的结果进行对比：</strong></p><p>网站为：<a href="http://tool.chinaz.com/tools/md5.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/tools/md5.aspx</a><br><img src="https://img-blog.csdnimg.cn/20181209195712744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>结果一致，说明加密成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;MD5算法简介：&quot;&gt;&lt;a href=&quot;#MD5算法简介：&quot; class=&quot;headerlink&quot; title=&quot;MD5算法简介：&quot;&gt;&lt;/a&gt;MD5算法简介：&lt;/h4&gt;&lt;p&gt;消息摘要算法第五版（英语：Message-Digest Algorithm 5，缩写为MD5
      
    
    </summary>
    
      <category term="信息安全技术" scheme="http://yoursite.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="信息安全技术" scheme="http://yoursite.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>图像拼接(Image Stitch)</title>
    <link href="http://yoursite.com/2019/07/06/Stitch/"/>
    <id>http://yoursite.com/2019/07/06/Stitch/</id>
    <published>2019-07-06T13:09:16.000Z</published>
    <updated>2019-07-06T13:10:19.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编译运行："><a href="#编译运行：" class="headerlink" title="编译运行："></a>编译运行：</h3><p><strong>运行环境</strong>：</p><p><code>Ubuntu 18</code></p><p><strong>链接库：</strong></p><p><code>VLFeat</code>&amp;&amp;<code>CImg</code></p><p><strong>编译命令：</strong></p><p><code>g++ -o test main.cpp ImageStitching.cpp ImageStitching.h -lpthread -l X11 -Lglnxa64/ -lvl -O3 -std=c++11</code></p><p>(linux下编译比较简单，只需将CImg.h文件和用到的vl库放在同目录下，但是要将libvl.so添加到usr下的动态链接库内)</p><h3 id="读入图像："><a href="#读入图像：" class="headerlink" title="读入图像："></a>读入图像：</h3><p>将目录下的多张图片读入，运用了linux环境下提取目录文件的一个目录指针，然后图片存在了CImgList中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">ptr</span>;</span></span><br><span class="line">DIR *dir;</span><br><span class="line">dir = opendir(<span class="string">"TEST-ImageData1"</span>);</span><br><span class="line"><span class="keyword">while</span> ((ptr = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(ptr-&gt;d_name[<span class="number">0</span>] == <span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">string</span> file = <span class="built_in">string</span>(<span class="string">"TEST-ImageData1/"</span>) + <span class="built_in">string</span>(ptr-&gt;d_name);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; file &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *Ff = file.c_str();</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; picture;</span><br><span class="line">picture.load(Ff);</span><br><span class="line">imgs.push_back(picture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="柱面投影："><a href="#柱面投影：" class="headerlink" title="柱面投影："></a>柱面投影：</h3><p>在全景图像中，由于摄像头的朝向不同，重合部分部分图像不一定满足视觉一致性的要求，因此先对图像进行投影，使其满足要求，以为后面的拼接做准备。在环形全景中，一般选择柱面投影算法，将图像分别投影到以 像素焦距+摄像头与圆心距离 为半径的圆柱上。投影后的图像为上图摄像头前方的圆弧。从圆弧上看，图像的重合部分已经满足视觉一致性的要求 。</p><p><img src="https://img-blog.csdn.net/20160201195938321" alt="img"></p><p><strong>圆柱面坐标转换的公式为：</strong><br>$$<br>x = \frac{x’-\frac{W}{2}}{k}+\frac{W}{2}=\frac{(x’-\frac{W}{2})\sqrt{R^2+(x-\frac{W}{2})^2}}{R}+\frac{W}{2}<br>$$</p><p>$$<br>y = \frac{y’-\frac{H}{2}}{k}+\frac{H}{2}=\frac{(y’-\frac{H}{2})\sqrt{R^2+(x-\frac{W}{2})^2}}{R}+\frac{H}{2}<br>$$</p><p>可以注意到把x和y写在了等式的左边而x’,y’写在了右边，这样做是为了方便进行插值计算 。投影后的图像点坐标未必为整数，而图像的坐标需要为整数，所以必将造成误差 。为了减少这种误差，我们对坐标点进行双线性插值。</p><p>其中半径R的值: <strong>R = W / (2*tan(α/2))</strong>，α的取值一般为相机视场角度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">float</span>&gt; ImageStitching::CylindricalProjection(CImg&lt;<span class="keyword">float</span>&gt; pic) &#123;</span><br><span class="line">    <span class="keyword">int</span> width = pic._width;</span><br><span class="line">    <span class="keyword">int</span> height = pic._height;</span><br><span class="line">    <span class="keyword">int</span> channel = pic._spectrum;</span><br><span class="line">    CImg&lt;<span class="keyword">float</span>&gt; result(width, height, <span class="number">1</span>, channel, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">float</span>  R = width / (<span class="number">2</span>*<span class="built_in">tan</span>(<span class="number">28.0f</span>/<span class="number">2.0f</span>*PI/<span class="number">180.0f</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; height; y++) &#123;</span><br><span class="line">            <span class="keyword">float</span> x0 = x - (<span class="keyword">float</span>)(width / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">float</span> y0 = y - (<span class="keyword">float</span>) (height/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">float</span> _x = x0*<span class="built_in">sqrt</span>(R*R + x0*x0) / R + (<span class="keyword">float</span>) width / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">float</span> _y = y0*<span class="built_in">sqrt</span>(R*R + x0*x0) / R + (<span class="keyword">float</span>) height / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (_x &gt;= <span class="number">0</span> &amp;&amp; _x &lt; width &amp;&amp; _y &gt;=<span class="number">0</span> &amp;&amp; _y &lt;= height) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>;  c &lt; channel; c++) &#123;</span><br><span class="line">                    result(x,y,c) = Interpolation(pic,_x,_y,c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将图像由RGB空间转为灰度空间："><a href="#将图像由RGB空间转为灰度空间：" class="headerlink" title="将图像由RGB空间转为灰度空间："></a>将图像由RGB空间转为灰度空间：</h3><p>这一步是为了下面的sift算法做铺垫：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">float</span>&gt; ImageStitching::convertTogray(CImg&lt;<span class="keyword">float</span>&gt; pic) &#123;</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; picture(pic._width, pic._height, <span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">cimg_forXY(pic,x,y) &#123;</span><br><span class="line"><span class="keyword">float</span> R = pic(x,y,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">float</span> G = pic(x,y,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">float</span> B = pic(x,y,<span class="number">2</span>);</span><br><span class="line">picture(x,y) =  R*<span class="number">0.299</span> + G*<span class="number">0.587</span> + B*<span class="number">0.114</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SIFT算法查找特征点"><a href="#SIFT算法查找特征点" class="headerlink" title="SIFT算法查找特征点"></a>SIFT算法查找特征点</h3><p>SIFT算法的实质是在不同尺度空间上查找关键点(特征点)，并计算关键点方向。SIFT所查找的关键点是一些十分突出，不会因光照，仿射变换和噪音等因素而变化的点，例如角点、边缘点、暗区的亮点以及亮区的暗点。</p><p>算法主要分为以下四步：</p><ol><li><strong>尺度空间极值检测</strong>：搜索所有尺度上的图像位置。通过高斯微分函数来识别潜在的对于尺度和旋转不变的兴趣点。</li><li><strong>关键点定位：</strong>在每个候选位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据它们的稳定程度。</li><li><strong>方向确定：</strong>基于图像局部梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向，尺度和位置进行变换。</li><li><strong>关键点描述：</strong>在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变化。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt; ImageStitching::SIFTFeatures(CImg&lt;<span class="keyword">float</span>&gt; pic) &#123;</span><br><span class="line">    <span class="keyword">int</span> noctaves = <span class="number">4</span>, nlevels = <span class="number">2</span>, o_min = <span class="number">0</span>;</span><br><span class="line">    vl_sift_pix *ImageData = <span class="keyword">new</span> vl_sift_pix[pic._width*pic._height];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pic._width; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pic._height; j++) &#123;</span><br><span class="line">            ImageData[j*pic._width + i] = pic(i,j,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义VlSiftFilt结构体指针</span></span><br><span class="line">VlSiftFilt *SiftFilt = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 创建一个新的sift滤波器</span></span><br><span class="line">SiftFilt = vl_sift_new(pic._width, pic._height, noctaves, nlevels, o_min);</span><br><span class="line">    <span class="comment">//int KeyPoint = 0;</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt; Feature;</span><br><span class="line">    <span class="keyword">if</span> (vl_sift_process_first_octave(SiftFilt, ImageData) != VL_ERR_EOF) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//计算每组中的关键点</span></span><br><span class="line">            vl_sift_detect(SiftFilt);</span><br><span class="line"><span class="comment">//遍历并绘制每个点  </span></span><br><span class="line"><span class="comment">//KeyPoint += SiftFilt-&gt;nkeys;//检测到的关键点的数目</span></span><br><span class="line">            VlSiftKeypoint *pKeyPoint = SiftFilt-&gt;keys;<span class="comment">//检测到的关键点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;SiftFilt-&gt;nkeys; i++) &#123;</span><br><span class="line">                VlSiftKeypoint tempKeyPoint = *pKeyPoint;</span><br><span class="line">                pKeyPoint++;</span><br><span class="line">                <span class="keyword">double</span> angles[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> angleCount = vl_sift_calc_keypoint_orientations(SiftFilt, angles, &amp;tempKeyPoint);<span class="comment">//计算关键点的方向</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;angleCount; j++) &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; Descriptor;</span><br><span class="line">                    <span class="keyword">double</span> tempAngle = angles[j];</span><br><span class="line">vl_sift_pix descriptors[<span class="number">128</span>];</span><br><span class="line"><span class="comment">// 计算每个方向的描述</span></span><br><span class="line">vl_sift_calc_keypoint_descriptor(SiftFilt, descriptors, &amp;tempKeyPoint, tempAngle);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">128</span> ;k++) &#123;</span><br><span class="line">                        Descriptor.push_back(descriptors[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Feature.insert(pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt;(Descriptor, tempKeyPoint));</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下一阶  </span></span><br><span class="line"><span class="keyword">if</span> (vl_sift_process_next_octave(SiftFilt) == VL_ERR_EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//free(pKeyPoint);  </span></span><br><span class="line"><span class="comment">//KeyPoint = NULL;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vl_sift_delete(SiftFilt);</span><br><span class="line"><span class="keyword">delete</span>[]ImageData;</span><br><span class="line">ImageData = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Feature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K-d-Tree最近邻搜索进行特征点匹配："><a href="#K-d-Tree最近邻搜索进行特征点匹配：" class="headerlink" title="K-d Tree最近邻搜索进行特征点匹配："></a>K-d Tree最近邻搜索进行特征点匹配：</h3><h4 id="k-d树算法可以分为两大部分，一部分是有关k-d树本身这种数据结构建立的算法，另一部分是在建立的k-d树上如何进行最邻近查找的算法。"><a href="#k-d树算法可以分为两大部分，一部分是有关k-d树本身这种数据结构建立的算法，另一部分是在建立的k-d树上如何进行最邻近查找的算法。" class="headerlink" title="k-d树算法可以分为两大部分，一部分是有关k-d树本身这种数据结构建立的算法，另一部分是在建立的k-d树上如何进行最邻近查找的算法。"></a>k-d树算法可以分为两大部分，一部分是有关k-d树本身这种数据结构建立的算法，另一部分是在建立的k-d树上如何进行最邻近查找的算法。</h4><p><strong>构建k-d树：</strong></p><p>构造kd树的方法：首先构造根节点，根节点对应于整个k维空间，包含所有的实例点，（至于如何选取划分点，有不同的策略。最常用的是一种方法是：对于所有的样本点，统计它们在每个维上的方差，挑选出方差中的最大值，对应的维就是要进行数据切分的维度。数据方差最大表明沿该维度数据点分散得比较开，这个方向上进行数据分割可以获得最好的分辨率；然后再将所有样本点按切分维度的值进行排序，位于正中间的那个数据点选为分裂结点。）。然后利用递归的方法，分别构造k-d树根节点的左右子树。在超矩形区域上选择一个坐标轴（切分维度）和一个分裂结点，以通过此分裂结点且垂直于切分方向坐标轴的直线作为分隔线，将当前超矩形区域分隔成左右或者上下两个子超矩形区域，对应于分裂结点的左右子树的根节点。实例也就被分到两个不相交的区域中。重复此过程直到子区域内没有实例点时终止。终止时的结点为叶结点。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">算法：createKDTree 构建一棵k-d tree </span><br><span class="line"> </span><br><span class="line">输入：exm_<span class="keyword">set</span> 样本集 </span><br><span class="line"> </span><br><span class="line">输出 : Kd, 类型为kd-tree </span><br><span class="line"> </span><br><span class="line">1. 如果exm_<span class="keyword">set</span>是空的，则返回空的kd-tree </span><br><span class="line"> </span><br><span class="line">2.调用分裂结点选择程序（输入是exm_<span class="keyword">set</span>），返回两个值 </span><br><span class="line"> </span><br><span class="line">       dom_elt:= exm_<span class="keyword">set</span>中的一个样本点 </span><br><span class="line"> </span><br><span class="line">       split := 分裂维的序号 </span><br><span class="line"> </span><br><span class="line">3.exm_<span class="keyword">set</span>_left = &#123;exm∈exm_<span class="keyword">set</span> – dom_elt &amp;&amp; exm[split] &lt;= dom_elt[split]&#125; </span><br><span class="line"> </span><br><span class="line">   exm_<span class="keyword">set</span>_right = &#123;exm∈exm_<span class="keyword">set</span> – dom_elt &amp;&amp; exm[split] &gt; dom_elt[split]&#125; </span><br><span class="line"> </span><br><span class="line">4.left = createKDTree<span class="params">(exm_set_left)</span> </span><br><span class="line"> </span><br><span class="line">right = createKDTree<span class="params">(exm_set_right)</span></span><br></pre></td></tr></table></figure><p><strong>k-d tree最近邻搜索算法</strong></p><p>在k-d tree树中进行数据的k近邻搜索是特征匹配的重要环节，其目的是检索在k-d tree中与待查询点距离最近的k个数据点。</p><p> 最近邻搜索是k近邻的特例，也就是1近邻。将1近邻改扩展到k近邻非常容易。下面介绍最简单的k-d tree最近邻搜索算法。</p><p>基本的思路很简单：首先通过二叉树搜索（比较待查询节点和分裂节点的分裂维的值，小于等于就进入左子树分支，等于就进入右子树分支直到叶子结点），顺着“搜索路径”很快能找到最近邻的近似点，也就是与待查询点处于同一个子空间的叶子结点；然后再回溯搜索路径，并判断搜索路径上的结点的其他子结点空间中是否可能有距离查询点更近的数据点，如果有可能，则需要跳到其他子结点空间中去搜索（将其他子结点加入到搜索路径）。重复这个过程直到搜索路径为空。下面是k-d tree最近邻搜索的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">算法：kdtreeFindNearest <span class="comment">/* k-d tree的最近邻搜索 */</span> </span><br><span class="line"> </span><br><span class="line">输入：Kd <span class="comment">/* k-d tree类型*/</span>  </span><br><span class="line">target <span class="comment">/* 待查询数据点 */</span> </span><br><span class="line"> </span><br><span class="line">输出 : nearest <span class="comment">/* 最近邻数据结点 */</span> </span><br><span class="line">dist <span class="comment">/* 最近邻和查询点的距离 */</span> </span><br><span class="line"> </span><br><span class="line"><span class="number">1.</span> 如果Kd是空的，则设dist为无穷大返回 </span><br><span class="line"><span class="number">2.</span> 向下搜索直到叶子结点 </span><br><span class="line">pSearch = &amp;Kd </span><br><span class="line"><span class="keyword">while</span>(pSearch != <span class="literal">NULL</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">pSearch加入到search_path中;  </span><br><span class="line"><span class="keyword">if</span>(target[pSearch-&gt;split] &lt;= pSearch-&gt;dom_elt[pSearch-&gt;split]) <span class="comment">/* 如果小于就进入左子树 */</span>  </span><br><span class="line">&#123;  </span><br><span class="line">pSearch = pSearch-&gt;left;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">&#123;  </span><br><span class="line">pSearch = pSearch-&gt;right;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">取出search_path最后一个赋给nearest  </span><br><span class="line">dist = Distance(nearest, target);  </span><br><span class="line"><span class="number">3.</span> 回溯搜索路径 </span><br><span class="line"><span class="keyword">while</span>(search_path不为空)  </span><br><span class="line">&#123;  </span><br><span class="line">取出search_path最后一个结点赋给pBack  </span><br><span class="line"><span class="keyword">if</span>(pBack-&gt;left为空 &amp;&amp; pBack-&gt;right为空) <span class="comment">/* 如果pBack为叶子结点 */</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>( Distance(nearest, target) &gt; Distance(pBack-&gt;dom_elt, target) )  </span><br><span class="line">&#123;  </span><br><span class="line">nearest = pBack-&gt;dom_elt;  </span><br><span class="line">dist = Distance(pBack-&gt;dom_elt, target);  </span><br><span class="line">&#125; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">s = pBack-&gt;split;  </span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">abs</span>(pBack-&gt;dom_elt[s] - target[s]) &lt; dist) <span class="comment">/* 如果以target为中心的圆（球或超球），半径为dist的圆与分割超平面相交， 那么就要跳到另一边的子空间去搜索 */</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">if</span>( Distance(nearest, target) &gt; Distance(pBack-&gt;dom_elt, target) )  </span><br><span class="line">&#123;  </span><br><span class="line">nearest = pBack-&gt;dom_elt;  </span><br><span class="line">dist = Distance(pBack-&gt;dom_elt, target);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span>(target[s] &lt;= pBack-&gt;dom_elt[s]) <span class="comment">/* 如果target位于pBack的左子空间，那么就要跳到右子空间去搜索 */</span>  </span><br><span class="line">pSearch = pBack-&gt;right;  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">pSearch = pBack-&gt;left; <span class="comment">/* 如果target位于pBack的右子空间，那么就要跳到左子空间去搜索 */</span>  </span><br><span class="line"><span class="keyword">if</span>(pSearch != <span class="literal">NULL</span>)  </span><br><span class="line">pSearch加入到search_path中  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用VLFeat实现k-d tree算法的代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;point_pair&gt; ImageStitching::KDtreeMatch(<span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt; feature_a, <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt; feature_b) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;point_pair&gt; result;</span><br><span class="line"></span><br><span class="line">    VlKDForest* forest = vl_kdforest_new(VL_TYPE_FLOAT, <span class="number">128</span>, <span class="number">1</span>, VlDistanceL1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> *data = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">128</span> * feature_a.size()];</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = feature_a.begin(); it != feature_a.end(); it++) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; &amp;descriptors = it-&gt;first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">data[i + <span class="number">128</span> * k] = descriptors[i];</span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vl_kdforest_build(forest, feature_a.size(), data);</span><br><span class="line">VlKDForestSearcher* searcher = vl_kdforest_new_searcher(forest);</span><br><span class="line">VlKDForestNeighbor neighbours[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = feature_b.begin(); it != feature_b.end(); it++)&#123;</span><br><span class="line"><span class="keyword">float</span> *temp_data = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">temp_data[i] = (it-&gt;first)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nvisited = vl_kdforestsearcher_query(searcher, neighbours, <span class="number">2</span>, temp_data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> ratio = neighbours[<span class="number">0</span>].distance / neighbours[<span class="number">1</span>].distance;</span><br><span class="line"><span class="keyword">if</span> (ratio &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; des(<span class="number">128</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++) &#123;</span><br><span class="line">des[j] = data[j + neighbours[<span class="number">0</span>].index * <span class="number">128</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VlSiftKeypoint left = feature_a.find(des)-&gt;second;</span><br><span class="line">VlSiftKeypoint right = it-&gt;second;</span><br><span class="line">result.push_back(point_pair(left, right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] temp_data;</span><br><span class="line">temp_data = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vl_kdforestsearcher_delete(searcher);</span><br><span class="line">vl_kdforest_delete(forest);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] data;</span><br><span class="line">data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RANSAC筛选出特征匹配点："><a href="#RANSAC筛选出特征匹配点：" class="headerlink" title="RANSAC筛选出特征匹配点："></a>RANSAC筛选出特征匹配点：</h3><p><strong>RANSAC算法在SIFT特征筛选中的主要流程是：</strong></p><p>(1) 从样本集中随机抽选一个RANSAC样本，即4个匹配点对</p><p>(2) 根据这4个匹配点对计算变换矩阵M</p><p>(3) 根据样本集，变换矩阵M，和误差度量函数计算满足当前变换矩阵的一致集consensus，并返回一致集中元素个数</p><p>(4) 根据当前一致集中元素个数判断是否最优(最大)一致集，若是则更新当前最优一致集</p><p>(5) 更新当前错误概率p，若p大于允许的最小错误概率则重复(1)至(4)继续迭代，直到当前错误概率p小于最小错误概率</p><pre><code>![img](https://img-blog.csdn.net/20151208162540847)</code></pre><p> <strong>其中，p为置信度，一般取0.995；w为”内点”的比例 ; m为计算模型所需要的最少样本数=4；</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">points ImageStitching::RANSAC(<span class="built_in">vector</span>&lt;point_pair&gt; pairs) &#123;</span><br><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">int</span> iterations = <span class="built_in">ceil</span>(<span class="built_in">log</span>(<span class="number">1</span> - <span class="number">0.99</span>) / <span class="built_in">log</span>(<span class="number">1</span> - <span class="built_in">pow</span>(<span class="number">0.5</span>, <span class="number">4</span>)));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; max_inliner_indexs;</span><br><span class="line"><span class="keyword">while</span> (iterations--) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;point_pair&gt; random_pairs;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; seleted_indexs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> index = rand() % pairs.size();</span><br><span class="line"><span class="keyword">while</span> (seleted_indexs.find(index) != seleted_indexs.end()) &#123;</span><br><span class="line">index = rand() % pairs.size();</span><br><span class="line">&#125;</span><br><span class="line">seleted_indexs.insert(index);</span><br><span class="line"></span><br><span class="line">random_pairs.push_back(pairs[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">points H = HomographyMatrix(random_pairs);</span><br><span class="line"><span class="comment">//cout &lt;&lt; H.x1 &lt;&lt; endl;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur_inliner_indexs;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (seleted_indexs.find(i) != seleted_indexs.end()) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> real_x = pairs[i].b.x;</span><br><span class="line"><span class="keyword">float</span> real_y = pairs[i].b.y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> x = H.x1 * pairs[i].a.x + H.x2 * pairs[i].a.y + H.x3 * pairs[i].a.x * pairs[i].a.y + H.x4;</span><br><span class="line"><span class="keyword">float</span> y = H.x5 * pairs[i].a.x + H.x6 * pairs[i].a.y + H.x7 * pairs[i].a.x * pairs[i].a.y + H.x8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> distance = <span class="built_in">sqrt</span>((x - real_x) * (x - real_x) + (y - real_y) * (y - real_y));</span><br><span class="line"><span class="keyword">if</span> (distance &lt; <span class="number">4</span>) &#123;</span><br><span class="line">cur_inliner_indexs.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur_inliner_indexs.size() &gt; max_inliner_indexs.size()) &#123;</span><br><span class="line">max_inliner_indexs = cur_inliner_indexs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> calc_size = max_inliner_indexs.size();</span><br><span class="line"></span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; A(<span class="number">4</span>, calc_size, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; b(<span class="number">1</span>, calc_size, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; calc_size; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> cur_index = max_inliner_indexs[i];</span><br><span class="line"></span><br><span class="line">A(<span class="number">0</span>, i) = pairs[cur_index].a.x;</span><br><span class="line">A(<span class="number">1</span>, i) = pairs[cur_index].a.y;</span><br><span class="line">A(<span class="number">2</span>, i) = pairs[cur_index].a.x * pairs[cur_index].a.y;</span><br><span class="line">A(<span class="number">3</span>, i) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">b(<span class="number">0</span>, i) = pairs[cur_index].b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; x1 = b.get_solve(A);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; calc_size; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> cur_index = max_inliner_indexs[i];</span><br><span class="line"></span><br><span class="line">b(<span class="number">0</span>, i) = pairs[cur_index].b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; x2 = b.get_solve(A);</span><br><span class="line"><span class="keyword">return</span> points(x1(<span class="number">0</span>, <span class="number">0</span>), x1(<span class="number">0</span>, <span class="number">1</span>), x1(<span class="number">0</span>, <span class="number">2</span>), x1(<span class="number">0</span>, <span class="number">3</span>), x2(<span class="number">0</span>, <span class="number">0</span>), x2(<span class="number">0</span>, <span class="number">1</span>), x2(<span class="number">0</span>, <span class="number">2</span>), x2(<span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图像拼接："><a href="#图像拼接：" class="headerlink" title="图像拼接："></a>图像拼接：</h3><p>先是进行进行拷贝，将一副图像按照需要拼接的点拷贝到另一幅图像上。但如果是直接拼接的话可能两幅图像对接点显得很不自然。这里使用Cimg的滤波函数进行边缘的滤波平滑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">float</span>&gt; ImageStitching::Blend(CImg&lt;<span class="keyword">float</span>&gt; pic1, CImg&lt;<span class="keyword">float</span>&gt; pic2) &#123;</span><br><span class="line"><span class="keyword">double</span> sum_a_x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> sum_a_y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a_n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> sum_overlap_x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> sum_overlap_y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> overlap_n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (pic1.width() &gt; pic1.height()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; pic1.width(); x++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!IsBlack(pic1, x, pic1.height() / <span class="number">2</span>)) &#123;</span><br><span class="line">sum_a_x += x;</span><br><span class="line">a_n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!IsBlack(pic1, x, pic1.height() / <span class="number">2</span>) &amp;&amp; !IsBlack(pic2, x, pic1.height() / <span class="number">2</span>)) &#123;</span><br><span class="line">sum_overlap_x += x;</span><br><span class="line">overlap_n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; pic1.height(); y++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!IsBlack(pic1, pic1.width() / <span class="number">2</span>, y)) &#123;</span><br><span class="line">sum_a_y += y;</span><br><span class="line">a_n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!IsBlack(pic1, pic1.width() / <span class="number">2</span>, y) &amp;&amp; !IsBlack(pic2, pic2.width() / <span class="number">2</span>, y)) &#123;</span><br><span class="line">sum_overlap_y += y;</span><br><span class="line">overlap_n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> min_len = (pic1.width() &lt; pic1.height()) ? pic1.width() : pic1.height();</span><br><span class="line"><span class="keyword">int</span> n_level = <span class="built_in">floor</span>(log2(min_len));</span><br><span class="line"><span class="built_in">vector</span>&lt;CImg&lt;<span class="keyword">float</span>&gt; &gt; a_pyramid(n_level);</span><br><span class="line"><span class="built_in">vector</span>&lt;CImg&lt;<span class="keyword">float</span>&gt; &gt; b_pyramid(n_level);</span><br><span class="line"><span class="built_in">vector</span>&lt;CImg&lt;<span class="keyword">float</span>&gt; &gt; mask(n_level);</span><br><span class="line"><span class="comment">// Initialize the base.</span></span><br><span class="line">a_pyramid[<span class="number">0</span>] = pic1;</span><br><span class="line">b_pyramid[<span class="number">0</span>] = pic2;</span><br><span class="line">mask[<span class="number">0</span>] = CImg&lt;<span class="keyword">float</span>&gt;(pic1.width(), pic1.height(), <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pic1.width() &gt; pic1.height()) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum_a_x / a_n &lt; sum_overlap_x / overlap_n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; sum_overlap_x / overlap_n; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; pic1.height(); y++) &#123;</span><br><span class="line">mask[<span class="number">0</span>](x, y) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = sum_overlap_x / overlap_n + <span class="number">1</span>; x &lt; pic1.width(); x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; pic1.height(); y++) &#123;</span><br><span class="line">mask[<span class="number">0</span>](x, y) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (sum_a_y / a_n &lt; sum_overlap_y / overlap_n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; pic1.width(); x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; sum_overlap_y / overlap_n; y++) &#123;</span><br><span class="line">mask[<span class="number">0</span>](x, y) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; pic1.width(); x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = sum_overlap_y / overlap_n; y &lt; pic1.height(); y++) &#123;</span><br><span class="line">mask[<span class="number">0</span>](x, y) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Down sampling a and b, building Gaussian pyramids.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n_level; i++) &#123;</span><br><span class="line">a_pyramid[i] = a_pyramid[i - <span class="number">1</span>].get_blur(<span class="number">2</span>).get_resize(a_pyramid[i - <span class="number">1</span>].width() / <span class="number">2</span>, a_pyramid[i - <span class="number">1</span>].height() / <span class="number">2</span>, <span class="number">1</span>, a_pyramid[i - <span class="number">1</span>].spectrum(), <span class="number">3</span>);</span><br><span class="line">b_pyramid[i] = b_pyramid[i - <span class="number">1</span>].get_blur(<span class="number">2</span>).get_resize(b_pyramid[i - <span class="number">1</span>].width() / <span class="number">2</span>, b_pyramid[i - <span class="number">1</span>].height() / <span class="number">2</span>, <span class="number">1</span>, b_pyramid[i - <span class="number">1</span>].spectrum(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">mask[i] = mask[i - <span class="number">1</span>].get_blur(<span class="number">2</span>).get_resize(mask[i - <span class="number">1</span>].width() / <span class="number">2</span>, mask[i - <span class="number">1</span>].height() / <span class="number">2</span>, <span class="number">1</span>, mask[i - <span class="number">1</span>].spectrum(), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Building Laplacian pyramids.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_level - <span class="number">1</span>; i++) &#123;</span><br><span class="line">a_pyramid[i] = a_pyramid[i] - a_pyramid[i + <span class="number">1</span>].get_resize(a_pyramid[i].width(), a_pyramid[i].height(), <span class="number">1</span>, a_pyramid[i].spectrum(), <span class="number">3</span>);</span><br><span class="line">b_pyramid[i] = b_pyramid[i] - b_pyramid[i + <span class="number">1</span>].get_resize(b_pyramid[i].width(), b_pyramid[i].height(), <span class="number">1</span>, b_pyramid[i].spectrum(), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;CImg&lt;<span class="keyword">float</span>&gt; &gt; blend_pyramid(n_level);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_level; i++) &#123;</span><br><span class="line">blend_pyramid[i] = CImg&lt;<span class="keyword">float</span>&gt;(a_pyramid[i].width(), a_pyramid[i].height(), <span class="number">1</span>, a_pyramid[i].spectrum(), <span class="number">0</span>);</span><br><span class="line">cimg_forXYC(blend_pyramid[i], x, y, c) &#123;</span><br><span class="line">blend_pyramid[i](x, y, c) = a_pyramid[i](x, y, c) * mask[i](x, y) + b_pyramid[i](x, y, c) * (<span class="number">1.0</span> - mask[i](x, y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; res = blend_pyramid[n_level - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n_level - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">res.resize(blend_pyramid[i].width(), blend_pyramid[i].height(), <span class="number">1</span>, blend_pyramid[i].spectrum(), <span class="number">3</span>);</span><br><span class="line">cimg_forXYC(blend_pyramid[i], x, y, c) &#123;</span><br><span class="line">res(x, y, c) = blend_pyramid[i](x, y, c) + res(x, y, c);</span><br><span class="line"><span class="keyword">if</span> (res(x, y, c) &gt; <span class="number">255</span>) res(x, y, c) = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (res(x, y, c) &lt; <span class="number">0</span>) res(x, y, c) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后封装成类："><a href="#最后封装成类：" class="headerlink" title="最后封装成类："></a>最后封装成类：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageStitching</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//源图列表</span></span><br><span class="line">    CImgList&lt;<span class="keyword">float</span>&gt; imgs;</span><br><span class="line">    <span class="comment">//拼接后的图像</span></span><br><span class="line">    CImg&lt;<span class="keyword">float</span>&gt; resultImg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//柱面投影</span></span><br><span class="line">    CImg&lt;<span class="keyword">float</span>&gt; CylindricalProjection(CImg&lt;<span class="keyword">float</span>&gt; pic);</span><br><span class="line">    <span class="comment">//图像从rgb空间转为灰度空间</span></span><br><span class="line">    CImg&lt;<span class="keyword">float</span>&gt; convertTogray(CImg&lt;<span class="keyword">float</span>&gt; pic);</span><br><span class="line">    <span class="comment">//提取图像中的特征点</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt; SIFTFeatures(CImg&lt;<span class="keyword">float</span>&gt; pic);</span><br><span class="line">    <span class="comment">//k-d树进行特征点匹配</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;point_pair&gt; KDtreeMatch(<span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt; feature_a, <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt; feature_b);</span><br><span class="line">    <span class="comment">//利用RANSAC算法求单应矩阵</span></span><br><span class="line">    <span class="function">points <span class="title">RANSAC</span><span class="params">(<span class="built_in">vector</span>&lt;point_pair&gt; pairs)</span></span>;</span><br><span class="line">    <span class="comment">//通过单应矩阵扭曲两幅图像内容</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WarpTwoImg</span><span class="params">(CImg&lt;<span class="keyword">float</span>&gt; src, CImg&lt;<span class="keyword">float</span>&gt; &amp;dst, points H, <span class="keyword">float</span> offset_x, <span class="keyword">float</span> offset_y)</span></span>;</span><br><span class="line">    <span class="comment">//移动两幅图像</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MoveTwoImg</span><span class="params">(CImg&lt;<span class="keyword">float</span>&gt; src, CImg&lt;<span class="keyword">float</span>&gt; &amp;dst, <span class="keyword">int</span> offset_x, <span class="keyword">int</span> offset_y)</span></span>;</span><br><span class="line">    <span class="comment">//图像拼接</span></span><br><span class="line">    CImg&lt;<span class="keyword">float</span>&gt; Blend(CImg&lt;<span class="keyword">float</span>&gt; pic1, CImg&lt;<span class="keyword">float</span>&gt; pic2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ImageStitching();</span><br><span class="line">    ~ImageStitching();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StitchProcess</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果拼接出的图像："><a href="#结果拼接出的图像：" class="headerlink" title="结果拼接出的图像："></a>结果拼接出的图像：</h3><p><img src="https://img-blog.csdnimg.cn/20181209194726866.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20181209194741175.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="实验总结："><a href="#实验总结：" class="headerlink" title="实验总结："></a>实验总结：</h4><p>程序复杂度过高，第二组图跑了半个小时，不过也跟自己虚拟机分配的内存和处理器不足有关。代码而言一方面是SIFT算法本身复杂度就比较高，网上有提到SIFT的简化版SURF的复杂度会低很多，其次自己在边缘处的一些插值算法以及图像拼接处的平滑等也大大提高了算法复杂度。有时间之后会思考去改进一下。</p><p>再就是最大的缺点感觉柱面投影时图片边缘存在许多毛刺，这个本来以为用了插值算法会大大减少这种像素点，结果还是看起来比较明显。同时图像接合处的用滤波的效果感觉不如开始使用opencv库尝试的时候溶解效果好，到时会去读一下opencv中溶解的源码了解一下这类的算法。</p><p><strong>完整代码参见：</strong><br><a href="https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp6" target="_blank" rel="noopener">https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp6</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;编译运行：&quot;&gt;&lt;a href=&quot;#编译运行：&quot; class=&quot;headerlink&quot; title=&quot;编译运行：&quot;&gt;&lt;/a&gt;编译运行：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;运行环境&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ubuntu 18&lt;/code&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>自适应的霍夫曼编码与原始的霍夫曼编码的比较</title>
    <link href="http://yoursite.com/2019/07/06/%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E4%B8%8E%E5%8E%9F%E5%A7%8B%E7%9A%84%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2019/07/06/自适应的霍夫曼编码与原始的霍夫曼编码的比较/</id>
    <published>2019-07-06T13:07:54.000Z</published>
    <updated>2019-07-06T13:08:30.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h2><h4 id="a-自适应的霍夫曼编码与原始的霍夫曼编码相比什么优点："><a href="#a-自适应的霍夫曼编码与原始的霍夫曼编码相比什么优点：" class="headerlink" title="(a) 自适应的霍夫曼编码与原始的霍夫曼编码相比什么优点："></a>(a) 自适应的霍夫曼编码与原始的霍夫曼编码相比什么优点：</h4><ol><li>原始的Huffman算法给出了一种静态的编码树构造方案，要求在实际编码之前统计被编码对象中符号出现的几率，并据此进行编码树的构造。所以应用此方案时必须对输入符号流进行两遍扫描，而在大多数多媒体应用中数据分布的先前统计数据是不可行的。</li><li>另外，静态编码树构造方案不能对符号流的局部统计规律变化做出反应，因为它从始至终都使用完全不变的编码树。而自适应Huffman编码不需要事先构造Huffman树，而是随着编码的进行，逐步构造Huffman树。同时，这种编码方案对符号的统计也动态进行，随着程序的运行，同一个符号的编码可能发生改变（变得更长或更短）。</li><li>再者就静态编码在储存或传输Huffman编码结果之前，还必须先储存或传输Huffman编码树，自适应霍夫曼编码则不需要，这大大节省了内存开销。</li></ol><h4 id="b"><a href="#b" class="headerlink" title="(b)"></a>(b)</h4><h5 id="i-接收到的后续几个字母是什么"><a href="#i-接收到的后续几个字母是什么" class="headerlink" title="(i)接收到的后续几个字母是什么"></a>(i)接收到的后续几个字母是什么</h5><p>接收到的后续的几个字母分别是 <strong>b(01) a(01) c(00 10) c(101)</strong></p><p>(推导过程同第二问)</p><p><strong>(ii)画出接收每一个后续字母后的自适应霍夫曼树</strong></p><p><img src="https://img-blog.csdnimg.cn/2018120919340015.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>fig 1</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209193415577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>fig 2</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209193427609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>fig 3</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209193435475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>fig 4</strong></p><p><strong>推导过程：</strong></p><table><thead><tr><th>步骤</th><th>字符</th><th>分析</th></tr></thead><tbody><tr><td>一</td><td>01</td><td>从7-11图定位到01为b，然后b的权值+1,此时b的节点权值变为3&gt;a(2)，b与a交换位置，huffman树变为fig1</td></tr><tr><td>二</td><td>01</td><td>从fig1定位到01为a，然后a权值+1，此时a的节点权值变为3=b(3)，树的节点不做变动，huffman树变为fig2</td></tr><tr><td>三</td><td>00 10</td><td>根据fig2定位到00是new，意味着有新字符的加入，然后根据下面的10知道新加入的字符是c，然后用包含c和new的子树替换旧的new节点，然后将a的父节点的权值+1变为4&gt;b(3)，与b交换位置，得到fig3</td></tr><tr><td>四</td><td>101</td><td>根据fig3定位到c，然后将相应的节点权值分别+1，发现没有需要置换的节点和子树，得到fig4</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一题：&quot;&gt;&lt;a href=&quot;#第一题：&quot; class=&quot;headerlink&quot; title=&quot;第一题：&quot;&gt;&lt;/a&gt;第一题：&lt;/h2&gt;&lt;h4 id=&quot;a-自适应的霍夫曼编码与原始的霍夫曼编码相比什么优点：&quot;&gt;&lt;a href=&quot;#a-自适应的霍夫曼编码与原始的霍夫曼
      
    
    </summary>
    
      <category term="多媒体技术" scheme="http://yoursite.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="多媒体技术" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>GIF压缩与JPEG压缩对比</title>
    <link href="http://yoursite.com/2019/07/06/GIF%E5%8E%8B%E7%BC%A9%E4%B8%8EJPEG%E5%8E%8B%E7%BC%A9%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2019/07/06/GIF压缩与JPEG压缩对比/</id>
    <published>2019-07-06T13:06:15.000Z</published>
    <updated>2019-07-06T13:06:42.916Z</updated>
    
    <content type="html"><![CDATA[<h4 id="图片示范"><a href="#图片示范" class="headerlink" title="图片示范"></a>图片示范</h4><p><img src="https://img-blog.csdnimg.cn/20181209193758218.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="动物卡通图片"><center><strong>fig: 动物卡通图片</strong></center></p><p><img src="https://img-blog.csdnimg.cn/20181209193850976.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><center><strong>fig: 动物图片</strong></center></p><h4 id="GIF格式"><a href="#GIF格式" class="headerlink" title="GIF格式"></a>GIF格式</h4><p>其中GIF格式采用的是LZW的无损压缩算法，这是一种字典索引的压缩方法，原理是减少每点的存储位数以减少图像文件的大小，也就是通常所说的颜色抖动。因而实际存储数据的并不是图像的直接色彩，而是存储的index，通过index来查询存储颜色的字典（类似我们上次作业实现的采色板）。index通常最高是存储八位，也就是2^8=256种颜色。</p><p>但实际在用rgb存储时，一副全色图像是采用直接色彩存储，每色块存8*3=24位。</p><ul><li>我尝试对老师给的动物图片先转为bmp其大小为2095k，然后用ps转为8位gif，发现大小变为了257k，差不多变为原来的1/(2^3=8)</li></ul><p>所以对于色彩变化不明显的简单图片我们一般采用gif压缩，原因就是基于LZW的原理：原始数据串中有大量的子串多次重复出现的话LZW压缩效果效果就会越好。针对具体图像来说也就是颜色种类越少越好，像素块色彩值重复度就高。gif压缩不会丢失任何数据而且又比同等效果的jpg图要小。</p><h4 id="JPEG格式"><a href="#JPEG格式" class="headerlink" title="JPEG格式"></a>JPEG格式</h4><p>JPEG压缩是一种偏向平衡性的格式，它会舍弃掉人眼根本无法感知的颜色信息，以使文件尽可能小并且细节不丢失。因此，它是一种有损格式。它颜色丰富并且很适合那些允许轻微失真的像素色彩丰富的图片（如相片）。 </p><ul><li>jpeg的压缩比例主要是在于量化一步中对于图像细节的保留程度，这一步采用的量化表也是从广泛实验中根据人对色彩的敏感程度得出。而且根据亮度和色度的精度要求不同采用不同量化表。前者细量化，后者粗量化。</li><li>最后的熵编码一般采用霍夫曼编码，而JPEG的霍夫曼表是由一定规则生成，只要给出少量的描述即可生成相应的JPEG的霍夫曼表，这也减少了存储的字符位数。 </li></ul><p>JPEG的图片相比gif的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，用来表达更生动的图像效果，比如颜色渐变。 </p><h4 id="图片存储格式分析"><a href="#图片存储格式分析" class="headerlink" title="图片存储格式分析"></a>图片存储格式分析</h4><p>所以对于动物图片这张图，它的颜色丰富度比较低，同时也已经存为jpg了，再二次压缩为jpg会失真度较高，也就是显得很糊，因而我们适合采用gif压缩。</p><p>而动物卡通图片这张图颜色种类丰富，渐变也比较明显，因而只用256种色彩存储很难达到较好的色彩效果，所以采用jpeg压缩。</p><p><strong>首先先比较第一张动物图片。</strong>先看压缩率，将第一幅图存为同等效果的jpg和gif，gif的图片大小为410k，而jpg的图片大小为521k；接着再看失真率，因为gif是无损压缩，而jpg是有损压缩，所以gif图片视觉的清晰度要高于jpg压缩，失真度较小。所以第一幅图无论是从压缩率还是失真率来说gif压缩都会略胜一筹。</p><h3 id="结果对比部分："><a href="#结果对比部分：" class="headerlink" title="结果对比部分："></a>结果对比部分：</h3><p><strong>jpg</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209194404217.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>gif</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209194417507.gif" alt="在这里插入图片描述"></p><p><strong>然后比较第二幅动物卡通图片。</strong>从压缩率来看，从同一张图片进行同等效果的压缩后gif的大小为348k，而jpg的大小为210k。接着根据失真度比较，gif最多只能存储8位，也就是256种颜色。而jpg虽然有一定的数据精度损失，但是是以直接色彩的方式存储，颜色丰富程度要远好于gif，而对于一些细节的渐变效果也比较好，所以这幅图jpg的视觉效果较好。所以综合压缩率和失真率来说这幅图用jpeg压缩效果更好。</p><p><strong>jpg</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209194238817.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>gif</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209194250127.gif" alt="在这里插入图片描述"></p><p><strong>ps:</strong>为什么同样是gif压缩第一幅图就会比jpg占内存小而第二幅图就会比jpg大呢？个人分析是因为第一幅图色彩丰富度太低，图片颜色种类少于256种，所以gif存储不需要8位(1~7位即可)就可以将图片色彩全部表示。而第二幅图色彩丰富度较高，颜色种类多于256种，gif最多也只能存八位，所以是将图片以8位索引的形式存的，图片大小就大于gif。</p><p>之后试了一下将第一幅图用ps强行存为8位，图片的内存大小也确实要比jpg大，所以得出结论如果将gif存为8位（256色索引），它的压缩效果是要比jpeg压缩差的，而且视觉上的色彩丰富程度也不达jpg。然而如果图片色彩丰富度低，例如能用128甚至更少的色彩存储，那么gif的压缩效果是会比jpg好，同时因为是无损压缩又不会造成图片的失真。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;图片示范&quot;&gt;&lt;a href=&quot;#图片示范&quot; class=&quot;headerlink&quot; title=&quot;图片示范&quot;&gt;&lt;/a&gt;图片示范&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181209193758218.jpg?x-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JPEG压缩算法</title>
    <link href="http://yoursite.com/2019/07/06/JPEG%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/07/06/JPEG压缩算法/</id>
    <published>2019-07-06T13:04:46.000Z</published>
    <updated>2019-07-06T13:05:31.983Z</updated>
    
    <content type="html"><![CDATA[<p><strong>编译环境</strong></p><p>windows10下MinGW</p><p><strong>编译语言</strong></p><p>c++ &amp;&amp; CImg库</p><p><strong>运行命令</strong></p><p><code>g++ -o test main.cpp jpegCompress.cpp jpegCompress.h -O2 -lgdi32</code></p><h4 id="1-8x8分块"><a href="#1-8x8分块" class="headerlink" title="1. 8x8分块"></a>1. 8x8分块</h4><p>因为之后的DCT变换是要对8x8的子块为一个单位进行处理，所以为了方便第一步我们就进行分块。所以源图的width和height必须要是8的倍数，所以我们对源图进行初始化处理，如果不是8的倍数的话我们要用0对其进行两侧的填充。</p><p><strong>初始化处理：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//载入图片，并对图片进行初始化处理</span></span><br><span class="line"><span class="comment">//如果图片的宽高不是8的倍数，则将两边均匀填0</span></span><br><span class="line">source.load(fileName);</span><br><span class="line"><span class="keyword">int</span> width = source._width;</span><br><span class="line"><span class="keyword">int</span> height = source._height;</span><br><span class="line"><span class="keyword">int</span> width1 = width % <span class="number">8</span> == <span class="number">0</span> ? width : (width / <span class="number">8</span> + <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> height1 = height % <span class="number">8</span> ==<span class="number">0</span> ? height : (height / <span class="number">8</span> + <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line">CImg&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; source_a(width1, height1, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">cimg_forXY(source_a, x, y) &#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; width &amp;&amp; y &lt; height) &#123;</span><br><span class="line">source_a(x + (width1 - width) / <span class="number">2</span>, y + (height1 - height) / <span class="number">2</span>, <span class="number">0</span>) = source(x, y, <span class="number">0</span>);</span><br><span class="line">source_a(x + (width1 - width) / <span class="number">2</span>, y + (height1 - height) / <span class="number">2</span>, <span class="number">1</span>) = source(x, y, <span class="number">1</span>);</span><br><span class="line">source_a(x + (width1 - width) / <span class="number">2</span>, y + (height1 - height) / <span class="number">2</span>, <span class="number">2</span>) = source(x, y, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">source = source_a;</span><br><span class="line">Width = source._width;</span><br><span class="line">Height = source._height;</span><br></pre></td></tr></table></figure><p><strong>分块：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次取8x8的小块进行处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> yPos=<span class="number">0</span>; yPos&lt;Height; yPos+=<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> xPos=<span class="number">0</span>; xPos&lt;Width; xPos+=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><h4 id="2-颜色空间转换"><a href="#2-颜色空间转换" class="headerlink" title="2.颜色空间转换"></a>2.颜色空间转换</h4><p> JPEG采用的是YCrCb颜色空间，而正常的编程软件读入图片后都会转为rgb格式，这也是bmp文件存储的颜色空间。所以要进行颜色空间转换。。YCrCb颜色空间中，Y代表亮度，Cr,Cb则代表色度和饱和度(也有人将Cb,Cr两者统称为色度)，三者通常以Y,U,V来表示，即用U代表Cb，用V代表Cr。RGB和YCrCb之间的转换关系如下：<br>$$<br>Y = 0.299R+0.587G+0.114B<br>$$</p><p>$$<br>Cb = -0.1687R-0.3313G+0.5B+128<br>$$</p><p>$$<br>Cr = 0.5R=0.418G-0.0813B+128<br>$$</p><p><strong>代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JpegCompress::RGB2YCbCr(<span class="keyword">int</span> xPos, <span class="keyword">int</span> yPos, <span class="keyword">char</span>* y_channel, <span class="keyword">char</span>* cd_channel, <span class="keyword">char</span>* cr_channel)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;<span class="number">8</span>; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">8</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R = source(xPos+x,yPos+y,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> G = source(xPos+x,yPos+y,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> B = source(xPos+x,yPos+y,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">y_channel[y*<span class="number">8</span>+x] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(<span class="number">0.299f</span> * R + <span class="number">0.587f</span> * G + <span class="number">0.114f</span> * B - <span class="number">128</span>);</span><br><span class="line">cd_channel[y*<span class="number">8</span>+x] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(<span class="number">-0.1687f</span> * R - <span class="number">0.3313f</span> * G + <span class="number">0.5f</span> * B );</span><br><span class="line">cr_channel[y*<span class="number">8</span>+x] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(<span class="number">0.5f</span> * R - <span class="number">0.4187f</span> * G - <span class="number">0.0813f</span> * B);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现效果：</strong><br><img src="https://img-blog.csdnimg.cn/20181209192404758.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>对应的分别是Y,Cb,Cr三个空间的图片：</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209192346295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3-离散余弦变换-DCT"><a href="#3-离散余弦变换-DCT" class="headerlink" title="3.离散余弦变换(DCT)"></a>3.离散余弦变换(DCT)</h4><p>$$<br>F(u,v) = alpha(u)<em>alpha(v)</em>\sum_{x=0}^{7}\sum_{y=0}^{7} f(x,y)\cos(\frac{2x+1}{16}u\pi)cos(\frac{2y+1}{16}v\pi) \qquad u,v=0,1,…,7<br>$$</p><p>$$<br>alpha(u) = \left{<br>\begin{aligned}<br>1/ \sqrt{8} \qquad when ;  u = 0 \<br>1 / \quad 2  \qquad when ; u  \neq 0<br>\end{aligned}<br>\right.<br>$$</p><p>8x8的二维像素块经过DCT操作之后，就得到了8x8的变换系数矩阵。这些系数，都有具体的物理含义，例如，U=0，V=0时的F（0,0）是原来的64个数据的均值，相当于直流分量，也有人称之为DC系数或者直流系数。随着U，V的增加，相另外的63个系数则代表了水平空间频率和垂直空间频率分量（高频分量）的大小，多半是一些接近于0的正负浮点数，我们称之为交流系数AC。DCT变换后的8*8的系数矩阵中，低频分量集中在矩阵的左上角。高频成分则集中在右下角。</p><p><strong>DCT变换代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JpegCompress::DCT(<span class="keyword">const</span> <span class="keyword">char</span>* channel_data, <span class="keyword">float</span>* fdc_data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;<span class="number">8</span>; v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;<span class="number">8</span>; u++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> alpha_u = (u==<span class="number">0</span>) ? <span class="number">1</span>/<span class="built_in">sqrt</span>(<span class="number">8.0f</span>) : <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">float</span> alpha_v = (v==<span class="number">0</span>) ? <span class="number">1</span>/<span class="built_in">sqrt</span>(<span class="number">8.0f</span>) : <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">float</span> f_xy = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">8</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;<span class="number">8</span>; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> data = channel_data[y*<span class="number">8</span>+x];</span><br><span class="line">data *= <span class="built_in">cos</span>((<span class="number">2</span>*x+<span class="number">1</span>)*u*PI/<span class="number">16.0f</span>);</span><br><span class="line">data *= <span class="built_in">cos</span>((<span class="number">2</span>*y+<span class="number">1</span>)*v*PI/<span class="number">16.0f</span>);</span><br><span class="line">f_xy += data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fdc_data[v*<span class="number">8</span>+u] = f_xy * alpha_u * alpha_v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于大多数图像的高频分量比较小，相应的图像高频分量的DCT系数经常接近于0，再加上高频分量中只包含了图像的细微的细节变化信息，而人眼对这种高频成分的失真不太敏感，所以，可以考虑将这一些高频成分予以抛弃，从而降低需要传输的数据量。这样一来，传送DCT变换系数的所需要的编码长度要远远小于传送图像像素的编码长度。到达接收端之后通过反离散余弦变换就可以得到原来的数据，虽然这么做存在一定的失真，但人眼是可接受的，而且对这种微小的变换是不敏感的。</p><h4 id="4-量化"><a href="#4-量化" class="headerlink" title="4.量化"></a>4.量化</h4><p>量化阶段需要两个8*8量化矩阵数据，一个是专门处理亮度的频率系数，另一个则是针对色度的频率系数，将频率系数除以量化矩阵的值之后取整，即完成了量化过程。当频率系数经过量化之后，将频率系数由浮点数转变为整数，这才便于执行最后的编码。不难发现，经过量化阶段之后，所有的数据只保留了整数近似值，也就再度损失了一些数据内容。在JPEG算法中，由于对亮度和色度的精度要求不同，分别对亮度和色度采用不同的量化表。前者细量化，后者粗量化。</p><p><img src="https://img-blog.csdnimg.cn/20181209192631703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标准亮度量化表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Luminance_Quantization_Table[<span class="number">64</span>] = </span><br><span class="line">&#123;</span><br><span class="line"><span class="number">16</span>,  <span class="number">11</span>,  <span class="number">10</span>,  <span class="number">16</span>,  <span class="number">24</span>,  <span class="number">40</span>,  <span class="number">51</span>,  <span class="number">61</span>,</span><br><span class="line"><span class="number">12</span>,  <span class="number">12</span>,  <span class="number">14</span>,  <span class="number">19</span>,  <span class="number">26</span>,  <span class="number">58</span>,  <span class="number">60</span>,  <span class="number">55</span>,</span><br><span class="line"><span class="number">14</span>,  <span class="number">13</span>,  <span class="number">16</span>,  <span class="number">24</span>,  <span class="number">40</span>,  <span class="number">57</span>,  <span class="number">69</span>,  <span class="number">56</span>,</span><br><span class="line"><span class="number">14</span>,  <span class="number">17</span>,  <span class="number">22</span>,  <span class="number">29</span>,  <span class="number">51</span>,  <span class="number">87</span>,  <span class="number">80</span>,  <span class="number">62</span>,</span><br><span class="line"><span class="number">18</span>,  <span class="number">22</span>,  <span class="number">37</span>,  <span class="number">56</span>,  <span class="number">68</span>, <span class="number">109</span>, <span class="number">103</span>,  <span class="number">77</span>,</span><br><span class="line"><span class="number">24</span>,  <span class="number">35</span>,  <span class="number">55</span>,  <span class="number">64</span>,  <span class="number">81</span>, <span class="number">104</span>, <span class="number">113</span>,  <span class="number">92</span>,</span><br><span class="line"><span class="number">49</span>,  <span class="number">64</span>,  <span class="number">78</span>,  <span class="number">87</span>, <span class="number">103</span>, <span class="number">121</span>, <span class="number">120</span>, <span class="number">101</span>,</span><br><span class="line"><span class="number">72</span>,  <span class="number">92</span>,  <span class="number">95</span>,  <span class="number">98</span>, <span class="number">112</span>, <span class="number">100</span>, <span class="number">103</span>,  <span class="number">99</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标准色差量化表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Chrominance_Quantization_Table[<span class="number">64</span>] = </span><br><span class="line">&#123;</span><br><span class="line"><span class="number">17</span>, <span class="number">18</span>, <span class="number">24</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line"><span class="number">18</span>, <span class="number">21</span>, <span class="number">26</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line"><span class="number">24</span>, <span class="number">26</span>, <span class="number">56</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line"><span class="number">47</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line"><span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line"><span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line"><span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line"><span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>量化表也是控制 JPEG 压缩比的关键。这个步骤除掉了一些高频量, 损失了很高细节。但事实上人眼对高空间频率远没有低频敏感.所以处理后的视觉损失很小。</li><li>另一个重要原因是所有的图片的点与点之间会有一个色彩过渡的过程. 大量的图象信息被包含在低空间频率中。经过量化处理后, 在高空间频率段, 将出现大量连续的零。</li><li>我的调整方式是设为10个等级，等级越高压缩比例也越大，得到的图片越小。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JpegCompress::InitQualityTables(<span class="keyword">int</span> quality)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> quant = Luminance_Quantization_Table[i] * quality / <span class="number">10</span>;</span><br><span class="line">quant == <span class="number">0</span> ? Y_Table[ZigZag[i]] = <span class="number">1</span>:Y_Table[ZigZag[i]] = quant;</span><br><span class="line">quant = Chrominance_Quantization_Table[i] * quality / <span class="number">10</span>;</span><br><span class="line">quant == <span class="number">0</span> ? CbCr_Table[ZigZag[i]] = <span class="number">1</span>:CbCr_Table[ZigZag[i]] = quant;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用得到的处理后的量化表进行量化处理：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JpegCompress::Quality(<span class="keyword">float</span>* fdc_data, <span class="keyword">short</span>* Quant, <span class="keyword">unsigned</span> <span class="keyword">char</span>* Table) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;<span class="number">8</span>; v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;<span class="number">8</span>; u++)</span><br><span class="line">&#123;</span><br><span class="line">Quant[ZigZag[v*<span class="number">8</span>+u]] = round(fdc_data[v*<span class="number">8</span>+u] / Table[ZigZag[v*<span class="number">8</span>+u]]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>矩阵的量化最后一步是把量化后的二维矩阵转变成一个一维数组，以方便后面的霍夫曼压缩，但在做这个顺序转换时，需要按照一个特定的取值顺序 。也就是我们说的<strong>ZigZag扫描</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于对量化后的矩阵进行顺序调整</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ZigZag[<span class="number">64</span>] =</span><br><span class="line">&#123; </span><br><span class="line"> <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">27</span>, <span class="number">28</span>,</span><br><span class="line"> <span class="number">2</span>,  <span class="number">4</span>,  <span class="number">7</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">26</span>, <span class="number">29</span>, <span class="number">42</span>,</span><br><span class="line"> <span class="number">3</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">41</span>, <span class="number">43</span>,</span><br><span class="line"> <span class="number">9</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">40</span>, <span class="number">44</span>, <span class="number">53</span>,</span><br><span class="line"><span class="number">10</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">32</span>, <span class="number">39</span>, <span class="number">45</span>, <span class="number">52</span>, <span class="number">54</span>,</span><br><span class="line"><span class="number">20</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">38</span>, <span class="number">46</span>, <span class="number">51</span>, <span class="number">55</span>, <span class="number">60</span>,</span><br><span class="line"><span class="number">21</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">50</span>, <span class="number">56</span>, <span class="number">59</span>, <span class="number">61</span>,</span><br><span class="line"><span class="number">35</span>, <span class="number">36</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">62</span>, <span class="number">63</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-Huffman编码"><a href="#5-Huffman编码" class="headerlink" title="5.Huffman编码"></a>5.Huffman编码</h4><h5 id="a-DC系数的DPCM编码："><a href="#a-DC系数的DPCM编码：" class="headerlink" title="a. DC系数的DPCM编码："></a>a. DC系数的DPCM编码：</h5><p>即取同一个图像分量中每个DC值与前一个DC值的差值来进行编码。这样对差值进行编码所需要的位数会比对原值进行编码所需要的位数少了很多 。</p><ul><li>这是基于DC系数的两个特点：<ul><li>系数的数值比较大；</li><li>相邻的8*8图像块的DC系数值变化不大；</li></ul></li></ul><p><strong>代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对DC分量进行DPCM编码</span></span><br><span class="line"><span class="keyword">int</span> dcDiff = (<span class="keyword">int</span>)(Quant[<span class="number">0</span>] - prev);</span><br><span class="line">prev = Quant[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (dcDiff == <span class="number">0</span>) &#123;</span><br><span class="line">outputBit[ptr] = DC_Table[<span class="number">0</span>];</span><br><span class="line">ptr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Bit B;</span><br><span class="line"><span class="keyword">int</span> v = <span class="built_in">abs</span>(dcDiff);</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (v) &#123;</span><br><span class="line">length++;</span><br><span class="line">v /= <span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line">B.value = dcDiff&gt;<span class="number">0</span> ? dcDiff : (<span class="built_in">pow</span>(<span class="number">2</span>,length)+dcDiff<span class="number">-1</span>);</span><br><span class="line">B.length = length;</span><br><span class="line">outputBit[ptr] = DC_Table[B.length];</span><br><span class="line">ptr++;</span><br><span class="line">outputBit[ptr] = B;</span><br><span class="line">ptr++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-AC系数的游长编码："><a href="#b-AC系数的游长编码：" class="headerlink" title="b. AC系数的游长编码："></a>b. AC系数的游长编码：</h5><p>量化之后的AC系数的特点是，63个系数中含有很多值为0的系数，尤其是在ZigZag扫描之后0大部分集中在数组的后面位置。因此，可以采用行程编码RLC（Run Length Coding）来更进一步降低数据的传输量。利用该编码方式，可以将一个字符串中重复出现的连续字符用两个字节来代替，其中，第一个字节代表重复的次数，第二个字节代表被重复的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对AC分量进行游长编码</span></span><br><span class="line"><span class="keyword">int</span> end = <span class="number">63</span>;</span><br><span class="line"><span class="comment">//找到最后不为0的之前部分，后面为0的全部置为EOB</span></span><br><span class="line"><span class="keyword">while</span>((end &gt; <span class="number">0</span>) &amp;&amp; (Quant[end] == <span class="number">0</span>)) end--;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=end; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> start = i;</span><br><span class="line"><span class="keyword">while</span>((Quant[i] == <span class="number">0</span>) &amp;&amp; (i &lt;= end)) i++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = i - start;</span><br><span class="line"><span class="keyword">if</span> (count &gt;= <span class="number">16</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=count/<span class="number">16</span>; j++) &#123;</span><br><span class="line">outputBit[ptr] = AC_Table[<span class="number">0xF0</span>];</span><br><span class="line">ptr++;</span><br><span class="line">&#125;</span><br><span class="line">count = count%<span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line">Bit B;</span><br><span class="line"><span class="keyword">int</span> v = <span class="built_in">abs</span>(Quant[i]);</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (v) &#123;</span><br><span class="line">length++;</span><br><span class="line">v /= <span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line">B.value = Quant[i]&gt;<span class="number">0</span> ? Quant[i] : (<span class="built_in">pow</span>(<span class="number">2</span>,length)+Quant[i]<span class="number">-1</span>);</span><br><span class="line">B.length = length;</span><br><span class="line">outputBit[ptr] = AC_Table[(count * <span class="number">16</span>) | B.length];</span><br><span class="line">ptr++;</span><br><span class="line">outputBit[ptr] = B;</span><br><span class="line">ptr++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (end != <span class="number">63</span>) &#123;</span><br><span class="line">outputBit[ptr] = AC_Table[<span class="number">0x00</span>];</span><br><span class="line">ptr++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-熵编码（Huffman编码）"><a href="#c-熵编码（Huffman编码）" class="headerlink" title="c. 熵编码（Huffman编码）"></a>c. 熵编码（Huffman编码）</h5><p>Huffman编码时DC系数与AC系数分别采用不同的Huffman编码表，对于亮度和色度也采用不同的Huffman编码表。因此，需要4张Huffman编码表才能完成熵编码的工作。具体的Huffman编码采用查表的方式来高效地完成。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标准直流分量色度亮度哈夫曼表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> Standard_DC_Luminance_NRCodes[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Standard_DC_Luminance_Values[] = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> Standard_DC_Chrominance_NRCodes[] = &#123; <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Standard_DC_Chrominance_Values[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标准交流分量色度亮度哈夫曼表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> Standard_AC_Luminance_NRCodes[] = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x7d</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Standard_AC_Luminance_Values[] = </span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x11</span>, <span class="number">0x05</span>, <span class="number">0x12</span>,</span><br><span class="line"><span class="number">0x21</span>, <span class="number">0x31</span>, <span class="number">0x41</span>, <span class="number">0x06</span>, <span class="number">0x13</span>, <span class="number">0x51</span>, <span class="number">0x61</span>, <span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x22</span>, <span class="number">0x71</span>, <span class="number">0x14</span>, <span class="number">0x32</span>, <span class="number">0x81</span>, <span class="number">0x91</span>, <span class="number">0xa1</span>, <span class="number">0x08</span>,</span><br><span class="line"><span class="number">0x23</span>, <span class="number">0x42</span>, <span class="number">0xb1</span>, <span class="number">0xc1</span>, <span class="number">0x15</span>, <span class="number">0x52</span>, <span class="number">0xd1</span>, <span class="number">0xf0</span>,</span><br><span class="line"><span class="number">0x24</span>, <span class="number">0x33</span>, <span class="number">0x62</span>, <span class="number">0x72</span>, <span class="number">0x82</span>, <span class="number">0x09</span>, <span class="number">0x0a</span>, <span class="number">0x16</span>,</span><br><span class="line"><span class="number">0x17</span>, <span class="number">0x18</span>, <span class="number">0x19</span>, <span class="number">0x1a</span>, <span class="number">0x25</span>, <span class="number">0x26</span>, <span class="number">0x27</span>, <span class="number">0x28</span>,</span><br><span class="line"><span class="number">0x29</span>, <span class="number">0x2a</span>, <span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x37</span>, <span class="number">0x38</span>, <span class="number">0x39</span>,</span><br><span class="line"><span class="number">0x3a</span>, <span class="number">0x43</span>, <span class="number">0x44</span>, <span class="number">0x45</span>, <span class="number">0x46</span>, <span class="number">0x47</span>, <span class="number">0x48</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x4a</span>, <span class="number">0x53</span>, <span class="number">0x54</span>, <span class="number">0x55</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x58</span>, <span class="number">0x59</span>,</span><br><span class="line"><span class="number">0x5a</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>, <span class="number">0x66</span>, <span class="number">0x67</span>, <span class="number">0x68</span>, <span class="number">0x69</span>,</span><br><span class="line"><span class="number">0x6a</span>, <span class="number">0x73</span>, <span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0x76</span>, <span class="number">0x77</span>, <span class="number">0x78</span>, <span class="number">0x79</span>,</span><br><span class="line"><span class="number">0x7a</span>, <span class="number">0x83</span>, <span class="number">0x84</span>, <span class="number">0x85</span>, <span class="number">0x86</span>, <span class="number">0x87</span>, <span class="number">0x88</span>, <span class="number">0x89</span>,</span><br><span class="line"><span class="number">0x8a</span>, <span class="number">0x92</span>, <span class="number">0x93</span>, <span class="number">0x94</span>, <span class="number">0x95</span>, <span class="number">0x96</span>, <span class="number">0x97</span>, <span class="number">0x98</span>,</span><br><span class="line"><span class="number">0x99</span>, <span class="number">0x9a</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>, <span class="number">0xa4</span>, <span class="number">0xa5</span>, <span class="number">0xa6</span>, <span class="number">0xa7</span>,</span><br><span class="line"><span class="number">0xa8</span>, <span class="number">0xa9</span>, <span class="number">0xaa</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>, <span class="number">0xb4</span>, <span class="number">0xb5</span>, <span class="number">0xb6</span>,</span><br><span class="line"><span class="number">0xb7</span>, <span class="number">0xb8</span>, <span class="number">0xb9</span>, <span class="number">0xba</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>, <span class="number">0xc4</span>, <span class="number">0xc5</span>,</span><br><span class="line"><span class="number">0xc6</span>, <span class="number">0xc7</span>, <span class="number">0xc8</span>, <span class="number">0xc9</span>, <span class="number">0xca</span>, <span class="number">0xd2</span>, <span class="number">0xd3</span>, <span class="number">0xd4</span>,</span><br><span class="line"><span class="number">0xd5</span>, <span class="number">0xd6</span>, <span class="number">0xd7</span>, <span class="number">0xd8</span>, <span class="number">0xd9</span>, <span class="number">0xda</span>, <span class="number">0xe1</span>, <span class="number">0xe2</span>,</span><br><span class="line"><span class="number">0xe3</span>, <span class="number">0xe4</span>, <span class="number">0xe5</span>, <span class="number">0xe6</span>, <span class="number">0xe7</span>, <span class="number">0xe8</span>, <span class="number">0xe9</span>, <span class="number">0xea</span>,</span><br><span class="line"><span class="number">0xf1</span>, <span class="number">0xf2</span>, <span class="number">0xf3</span>, <span class="number">0xf4</span>, <span class="number">0xf5</span>, <span class="number">0xf6</span>, <span class="number">0xf7</span>, <span class="number">0xf8</span>,</span><br><span class="line"><span class="number">0xf9</span>, <span class="number">0xfa</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> Standard_AC_Chrominance_NRCodes[] = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0x77</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Standard_AC_Chrominance_Values[] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x11</span>, <span class="number">0x04</span>, <span class="number">0x05</span>, <span class="number">0x21</span>,</span><br><span class="line"><span class="number">0x31</span>, <span class="number">0x06</span>, <span class="number">0x12</span>, <span class="number">0x41</span>, <span class="number">0x51</span>, <span class="number">0x07</span>, <span class="number">0x61</span>, <span class="number">0x71</span>,</span><br><span class="line"><span class="number">0x13</span>, <span class="number">0x22</span>, <span class="number">0x32</span>, <span class="number">0x81</span>, <span class="number">0x08</span>, <span class="number">0x14</span>, <span class="number">0x42</span>, <span class="number">0x91</span>,</span><br><span class="line"><span class="number">0xa1</span>, <span class="number">0xb1</span>, <span class="number">0xc1</span>, <span class="number">0x09</span>, <span class="number">0x23</span>, <span class="number">0x33</span>, <span class="number">0x52</span>, <span class="number">0xf0</span>,</span><br><span class="line"><span class="number">0x15</span>, <span class="number">0x62</span>, <span class="number">0x72</span>, <span class="number">0xd1</span>, <span class="number">0x0a</span>, <span class="number">0x16</span>, <span class="number">0x24</span>, <span class="number">0x34</span>,</span><br><span class="line"><span class="number">0xe1</span>, <span class="number">0x25</span>, <span class="number">0xf1</span>, <span class="number">0x17</span>, <span class="number">0x18</span>, <span class="number">0x19</span>, <span class="number">0x1a</span>, <span class="number">0x26</span>,</span><br><span class="line"><span class="number">0x27</span>, <span class="number">0x28</span>, <span class="number">0x29</span>, <span class="number">0x2a</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x37</span>, <span class="number">0x38</span>,</span><br><span class="line"><span class="number">0x39</span>, <span class="number">0x3a</span>, <span class="number">0x43</span>, <span class="number">0x44</span>, <span class="number">0x45</span>, <span class="number">0x46</span>, <span class="number">0x47</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x49</span>, <span class="number">0x4a</span>, <span class="number">0x53</span>, <span class="number">0x54</span>, <span class="number">0x55</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x58</span>,</span><br><span class="line"><span class="number">0x59</span>, <span class="number">0x5a</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>, <span class="number">0x66</span>, <span class="number">0x67</span>, <span class="number">0x68</span>,</span><br><span class="line"><span class="number">0x69</span>, <span class="number">0x6a</span>, <span class="number">0x73</span>, <span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0x76</span>, <span class="number">0x77</span>, <span class="number">0x78</span>,</span><br><span class="line"><span class="number">0x79</span>, <span class="number">0x7a</span>, <span class="number">0x82</span>, <span class="number">0x83</span>, <span class="number">0x84</span>, <span class="number">0x85</span>, <span class="number">0x86</span>, <span class="number">0x87</span>,</span><br><span class="line"><span class="number">0x88</span>, <span class="number">0x89</span>, <span class="number">0x8a</span>, <span class="number">0x92</span>, <span class="number">0x93</span>, <span class="number">0x94</span>, <span class="number">0x95</span>, <span class="number">0x96</span>,</span><br><span class="line"><span class="number">0x97</span>, <span class="number">0x98</span>, <span class="number">0x99</span>, <span class="number">0x9a</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>, <span class="number">0xa4</span>, <span class="number">0xa5</span>,</span><br><span class="line"><span class="number">0xa6</span>, <span class="number">0xa7</span>, <span class="number">0xa8</span>, <span class="number">0xa9</span>, <span class="number">0xaa</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>, <span class="number">0xb4</span>,</span><br><span class="line"><span class="number">0xb5</span>, <span class="number">0xb6</span>, <span class="number">0xb7</span>, <span class="number">0xb8</span>, <span class="number">0xb9</span>, <span class="number">0xba</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>,</span><br><span class="line"><span class="number">0xc4</span>, <span class="number">0xc5</span>, <span class="number">0xc6</span>, <span class="number">0xc7</span>, <span class="number">0xc8</span>, <span class="number">0xc9</span>, <span class="number">0xca</span>, <span class="number">0xd2</span>,</span><br><span class="line"><span class="number">0xd3</span>, <span class="number">0xd4</span>, <span class="number">0xd5</span>, <span class="number">0xd6</span>, <span class="number">0xd7</span>, <span class="number">0xd8</span>, <span class="number">0xd9</span>, <span class="number">0xda</span>,</span><br><span class="line"><span class="number">0xe2</span>, <span class="number">0xe3</span>, <span class="number">0xe4</span>, <span class="number">0xe5</span>, <span class="number">0xe6</span>, <span class="number">0xe7</span>, <span class="number">0xe8</span>, <span class="number">0xe9</span>,</span><br><span class="line"><span class="number">0xea</span>, <span class="number">0xf2</span>, <span class="number">0xf3</span>, <span class="number">0xf4</span>, <span class="number">0xf5</span>, <span class="number">0xf6</span>, <span class="number">0xf7</span>, <span class="number">0xf8</span>,</span><br><span class="line"><span class="number">0xf9</span>, <span class="number">0xfa</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参照jpeg官方的文件交换格式将标准霍夫曼表转换为图像中应用的包含（Huffman_size、Huffman_code）的相应四张查询表。     </p><p>在《ISO/IEC10918-1, 1993(e), Annex C》中，用三个流程图，进行了详细的阐述，下面是其相应的官方转换Matlab代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">% 根据DHT产生HUFFSIZE[]、HUFFCODE[]</span><br><span class="line">% 参考<span class="string">"ISO/IEC10918-1, 1993(e), Annex C"</span></span><br><span class="line">% dxq@<span class="number">2014</span><span class="number">-04</span><span class="number">-24</span></span><br><span class="line"></span><br><span class="line">function[ehufco,ehufsi]=dedht(dht)</span><br><span class="line">bits =dht(<span class="number">1</span>:<span class="number">16</span>);</span><br><span class="line">huffval =dht(<span class="number">17</span>:end);</span><br><span class="line">% 参考<span class="string">"ISO/IEC10918-1, 1993(e), Annex C ,Figure C.1"</span></span><br><span class="line">k = <span class="number">0</span> ;</span><br><span class="line">j = <span class="number">1</span> ;</span><br><span class="line">fori=<span class="number">1</span>:<span class="number">16</span></span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span>:bits(i)</span><br><span class="line">        huffsize(k+<span class="number">1</span>)=i;</span><br><span class="line">        k=k+<span class="number">1</span>;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">huffsize(k+<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line">lastk = k;</span><br><span class="line"></span><br><span class="line">% 参考<span class="string">"ISO/IEC10918-1, 1993(e), Annex C ,Figure C.2"</span></span><br><span class="line">code = <span class="number">0</span>;</span><br><span class="line">k=<span class="number">1</span>;</span><br><span class="line">si =huffsize(<span class="number">1</span>);</span><br><span class="line">whilehuffsize(k)&gt;<span class="number">0</span></span><br><span class="line">    huffcode(k)=code ;</span><br><span class="line">    code = code + <span class="number">1</span> ;</span><br><span class="line">    k = k+ <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> huffsize(k)==si</span><br><span class="line">        huffcode(k)=code ;</span><br><span class="line">        code = code + <span class="number">1</span> ;</span><br><span class="line">        k = k+ <span class="number">1</span> ;</span><br><span class="line">    end</span><br><span class="line">    <span class="keyword">if</span> huffsize(k)==<span class="number">0</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    end</span><br><span class="line">    code = code * <span class="number">2</span> ;</span><br><span class="line">    si = si + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> huffsize(k)~= si</span><br><span class="line">        code = code * <span class="number">2</span> ;</span><br><span class="line">        si = si + <span class="number">1</span>;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% 参考<span class="string">"ISO/IEC10918-1, 1993(e), Annex C ,Figure C.3"</span></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:lastk</span><br><span class="line">    i=huffval(k);</span><br><span class="line">    ehufco(i+<span class="number">1</span>)=uint32(huffcode(k));</span><br><span class="line">    ehufsi(i+<span class="number">1</span>)=uint32(huffsize(k));</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>改写为c++代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JpegCompress::InitHuffmanTables()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> code_value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Standard_DC_Luminance_NRCodes[i<span class="number">-1</span>]; j++)</span><br><span class="line">&#123;</span><br><span class="line">Y_DC_Huffman[Standard_DC_Luminance_Values[pos]].value = code_value;</span><br><span class="line">Y_DC_Huffman[Standard_DC_Luminance_Values[pos]].length = i;</span><br><span class="line">pos++;</span><br><span class="line">code_value++;</span><br><span class="line">&#125;</span><br><span class="line">code_value *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos = <span class="number">0</span>; code_value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Standard_AC_Luminance_NRCodes[i<span class="number">-1</span>]; j++)</span><br><span class="line">&#123;</span><br><span class="line">Y_AC_Huffman[Standard_AC_Luminance_Values[pos]].value = code_value;</span><br><span class="line">Y_AC_Huffman[Standard_AC_Luminance_Values[pos]].length = i;</span><br><span class="line">pos++;</span><br><span class="line">code_value++;</span><br><span class="line">&#125;</span><br><span class="line">code_value *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos = <span class="number">0</span>; code_value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Standard_DC_Chrominance_NRCodes[i<span class="number">-1</span>]; j++)</span><br><span class="line">&#123;</span><br><span class="line">CbCr_DC_Huffman[Standard_DC_Chrominance_Values[pos]].value = code_value;</span><br><span class="line">CbCr_DC_Huffman[Standard_DC_Chrominance_Values[pos]].length = i;</span><br><span class="line">pos++;</span><br><span class="line">code_value++;</span><br><span class="line">&#125;</span><br><span class="line">code_value *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos = <span class="number">0</span>; code_value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Standard_AC_Chrominance_NRCodes[i<span class="number">-1</span>]; j++)</span><br><span class="line">&#123;</span><br><span class="line">CbCr_AC_Huffman[Standard_AC_Chrominance_Values[pos]].value = code_value;</span><br><span class="line">CbCr_AC_Huffman[Standard_AC_Chrominance_Values[pos]].length = i;</span><br><span class="line">pos++;</span><br><span class="line">code_value++;</span><br><span class="line">&#125;</span><br><span class="line">code_value *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>d. 范式霍夫曼编码的格式：</strong></p><p>为了提高储存效率, JPEG 里并不直接保存数值, 而是将数值按位数分成 16 组:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                数值                 组              实际保存值</span><br><span class="line">                <span class="number">0</span>                   <span class="number">0</span>                   -</span><br><span class="line">              <span class="number">-1</span>,<span class="number">1</span>                  <span class="number">1</span>                  <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">           <span class="number">-3</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">3</span>                <span class="number">2</span>              <span class="number">00</span>,<span class="number">01</span>,<span class="number">10</span>,<span class="number">11</span></span><br><span class="line">     <span class="number">-7</span>,<span class="number">-6</span>,<span class="number">-5</span>,<span class="number">-4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>            <span class="number">3</span>    <span class="number">000</span>,<span class="number">001</span>,<span class="number">010</span>,<span class="number">011</span>,<span class="number">100</span>,<span class="number">101</span>,<span class="number">110</span>,<span class="number">111</span></span><br><span class="line">       <span class="number">-15</span>,..,<span class="number">-8</span>,<span class="number">8</span>,..,<span class="number">15</span>            <span class="number">4</span>       <span class="number">0000</span>,..,<span class="number">0111</span>,<span class="number">1000</span>,..,<span class="number">1111</span></span><br><span class="line">      <span class="number">-31</span>,..,<span class="number">-16</span>,<span class="number">16</span>,..,<span class="number">31</span>           <span class="number">5</span>     <span class="number">00000</span>,..,<span class="number">01111</span>,<span class="number">10000</span>,..,<span class="number">11111</span></span><br><span class="line">      <span class="number">-63</span>,..,<span class="number">-32</span>,<span class="number">32</span>,..,<span class="number">63</span>           <span class="number">6</span>                   .</span><br><span class="line">     <span class="number">-127</span>,..,<span class="number">-64</span>,<span class="number">64</span>,..,<span class="number">127</span>          <span class="number">7</span>                   .</span><br><span class="line">    <span class="number">-255</span>,..,<span class="number">-128</span>,<span class="number">128</span>,..,<span class="number">255</span>         <span class="number">8</span>                   .</span><br><span class="line">    <span class="number">-511</span>,..,<span class="number">-256</span>,<span class="number">256</span>,..,<span class="number">511</span>         <span class="number">9</span>                   .</span><br><span class="line">   <span class="number">-1023</span>,..,<span class="number">-512</span>,<span class="number">512</span>,..,<span class="number">1023</span>       <span class="number">10</span>                   .</span><br><span class="line">  <span class="number">-2047</span>,..,<span class="number">-1024</span>,<span class="number">1024</span>,..,<span class="number">2047</span>      <span class="number">11</span>                   .</span><br><span class="line">  <span class="number">-4095</span>,..,<span class="number">-2048</span>,<span class="number">2048</span>,..,<span class="number">4095</span>      <span class="number">12</span>                   .</span><br><span class="line">  <span class="number">-8191</span>,..,<span class="number">-4096</span>,<span class="number">4096</span>,..,<span class="number">8191</span>      <span class="number">13</span>                   .</span><br><span class="line"> <span class="number">-16383</span>,..,<span class="number">-8192</span>,<span class="number">8192</span>,..,<span class="number">16383</span>     <span class="number">14</span>                   .</span><br><span class="line"><span class="number">-32767</span>,..,<span class="number">-16384</span>,<span class="number">16384</span>,..,<span class="number">32767</span>    <span class="number">15</span>                   .</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//范式霍夫曼编码表数值范围</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">short</span> paradigm_table[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>,<span class="number">256</span>,<span class="number">512</span>,<span class="number">1024</span>,<span class="number">2048</span>,<span class="number">4096</span>,<span class="number">8192</span>,<span class="number">16384</span>,<span class="number">32768</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((value &amp; paradigm_table[pos]) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">newByte = newByte  | paradigm_table[newBytePos];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>至此，终于完成了霍夫曼编码。</strong></p><h4 id="6-jpeg文件的写入"><a href="#6-jpeg文件的写入" class="headerlink" title="6.jpeg文件的写入"></a>6.jpeg文件的写入</h4><p>查询官方的jpeg格式要求，附在txt文档中。</p><p><strong>jpeg头文件：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JpegCompress::JpegHeader(FILE* fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//SOI</span></span><br><span class="line">WriteShort(<span class="number">0xFFD8</span>, fp);<span class="comment">// marker = 0xFFD8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//APPO</span></span><br><span class="line">WriteShort(<span class="number">0xFFE0</span>,fp);<span class="comment">// marker = 0xFFE0</span></span><br><span class="line">WriteShort(<span class="number">16</span>, fp);<span class="comment">// length = 16 for usual JPEG</span></span><br><span class="line">fwrite(<span class="string">"JFIF"</span>, <span class="number">1</span>, <span class="number">5</span>, fp);<span class="comment">// 'JFIF\0'</span></span><br><span class="line">WriteByte(<span class="number">1</span>, fp);<span class="comment">// version_hi</span></span><br><span class="line">WriteByte(<span class="number">1</span>, fp);<span class="comment">// version_low</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">// xyunits = 0 no units, normal density</span></span><br><span class="line">WriteShort(<span class="number">1</span>, fp);<span class="comment">// xdensity</span></span><br><span class="line">WriteShort(<span class="number">1</span>, fp);<span class="comment">// ydensity</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">// thumbWidth</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">// thumbHeight</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DQT</span></span><br><span class="line">WriteShort(<span class="number">0xFFDB</span>, fp);<span class="comment">//marker = 0xFFDB</span></span><br><span class="line">WriteShort(<span class="number">132</span>, fp);<span class="comment">//size=132</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">//QTYinfo== 0:  bit 0..3: number of QT = 0 (table for Y) </span></span><br><span class="line"><span class="comment">//bit 4..7: precision of QT</span></span><br><span class="line"><span class="comment">//bit 8: 0</span></span><br><span class="line">fwrite(Y_Table, <span class="number">1</span>,  <span class="number">64</span>, fp);<span class="comment">//YTable</span></span><br><span class="line">WriteByte(<span class="number">1</span>, fp);<span class="comment">//QTCbinfo = 1 (quantization table for Cb,Cr)</span></span><br><span class="line">fwrite(CbCr_Table, <span class="number">1</span>, <span class="number">64</span>, fp);<span class="comment">//CbCrTable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SOFO</span></span><br><span class="line">WriteShort(<span class="number">0xFFC0</span>, fp);<span class="comment">//marker = 0xFFC0</span></span><br><span class="line">WriteShort(<span class="number">17</span>, fp);<span class="comment">//length = 17 for a truecolor YCbCr JPG</span></span><br><span class="line">WriteByte(<span class="number">8</span>, fp);<span class="comment">//precision = 8: 8 bits/sample </span></span><br><span class="line">WriteShort(Height&amp;<span class="number">0xFFFF</span>, fp);<span class="comment">//height</span></span><br><span class="line">WriteShort(Width&amp;<span class="number">0xFFFF</span>, fp);<span class="comment">//width</span></span><br><span class="line">WriteByte(<span class="number">3</span>, fp);<span class="comment">//nrofcomponents = 3</span></span><br><span class="line"></span><br><span class="line">WriteByte(<span class="number">1</span>, fp);<span class="comment">//IdY = 1</span></span><br><span class="line">WriteByte(<span class="number">0x11</span>, fp);<span class="comment">//HVY sampling factors for Y (bit 0-3 vert., 4-7 hor.)(SuBamp 1x1)</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">//QTY </span></span><br><span class="line"></span><br><span class="line">WriteByte(<span class="number">2</span>, fp);<span class="comment">//IdCb = 2</span></span><br><span class="line">WriteByte(<span class="number">0x11</span>, fp);<span class="comment">//HVCb = 0x11(SuBamp 1x1)</span></span><br><span class="line">WriteByte(<span class="number">1</span>, fp);<span class="comment">//QTCb = 1</span></span><br><span class="line"></span><br><span class="line">WriteByte(<span class="number">3</span>, fp);<span class="comment">//IdCr = 3</span></span><br><span class="line">WriteByte(<span class="number">0x11</span>, fp);<span class="comment">//HVCr = 0x11 (SuBamp 1x1)</span></span><br><span class="line">WriteByte(<span class="number">1</span>, fp);<span class="comment">//QTCr </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DHT</span></span><br><span class="line">WriteShort(<span class="number">0xFFC4</span>, fp);<span class="comment">//marker = 0xFFC4</span></span><br><span class="line">WriteShort(<span class="number">0x01A2</span>, fp);<span class="comment">//length = 0x01A2</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">//HTYDCinfo bit 0..3</span></span><br><span class="line"><span class="comment">//bit 4</span></span><br><span class="line"><span class="comment">//bit 5..7</span></span><br><span class="line">fwrite(Standard_DC_Luminance_NRCodes, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_DC_Luminance_NRCodes), fp);<span class="comment">//DC_L_NRC</span></span><br><span class="line">fwrite(Standard_DC_Luminance_Values, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_DC_Luminance_Values), fp);<span class="comment">//DC_L_VALUE</span></span><br><span class="line">WriteByte(<span class="number">0x10</span>, fp);<span class="comment">//HTYACinfo</span></span><br><span class="line">fwrite(Standard_AC_Luminance_NRCodes, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_AC_Luminance_NRCodes), fp);</span><br><span class="line">fwrite(Standard_AC_Luminance_Values, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_AC_Luminance_Values), fp); </span><br><span class="line">WriteByte(<span class="number">0x01</span>, fp);<span class="comment">//HTCbDCinfo</span></span><br><span class="line">fwrite(Standard_DC_Chrominance_NRCodes, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_DC_Chrominance_NRCodes), fp);</span><br><span class="line">fwrite(Standard_DC_Chrominance_Values, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_DC_Chrominance_Values), fp);</span><br><span class="line">WriteByte(<span class="number">0x11</span>, fp);<span class="comment">//HTCbACinfo</span></span><br><span class="line">fwrite(Standard_AC_Chrominance_NRCodes, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_AC_Chrominance_NRCodes), fp);</span><br><span class="line">fwrite(Standard_AC_Chrominance_Values, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_AC_Chrominance_Values), fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//SOS</span></span><br><span class="line">WriteShort(<span class="number">0xFFDA</span>, fp);<span class="comment">//marker = 0xFFC4</span></span><br><span class="line">WriteShort(<span class="number">12</span>, fp);<span class="comment">//length = 12</span></span><br><span class="line">WriteByte(<span class="number">3</span>, fp);<span class="comment">//nrofcomponents, Should be 3: truecolor JPG</span></span><br><span class="line"></span><br><span class="line">WriteByte(<span class="number">1</span>, fp);<span class="comment">//Idy=1</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">//HTYbits 0..3: AC table (0..3)</span></span><br><span class="line"><span class="comment">//bits 4..7: DC table (0..3)</span></span><br><span class="line">WriteByte(<span class="number">2</span>, fp);<span class="comment">//IdCb</span></span><br><span class="line">WriteByte(<span class="number">0x11</span>, fp);<span class="comment">//HTCb</span></span><br><span class="line"></span><br><span class="line">WriteByte(<span class="number">3</span>, fp);<span class="comment">//IdCr</span></span><br><span class="line">WriteByte(<span class="number">0x11</span>, fp);<span class="comment">//HTCr</span></span><br><span class="line"></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">//Ss</span></span><br><span class="line">WriteByte(<span class="number">0x3F</span>, fp);<span class="comment">//Se</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">//Bf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编码部分的写入：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JpegCompress::WriteToJpeg(<span class="keyword">const</span> Bit* B, <span class="keyword">int</span> counts, <span class="keyword">int</span>&amp; newByte, <span class="keyword">int</span>&amp; newBytePos, FILE* fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;counts; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> value = B[i].value;</span><br><span class="line"><span class="keyword">int</span> pos = B[i].length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (pos &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((value &amp; paradigm_table[pos]) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">newByte = newByte  | paradigm_table[newBytePos];</span><br><span class="line">&#125;</span><br><span class="line">pos--;</span><br><span class="line">newBytePos--;</span><br><span class="line"><span class="keyword">if</span> (newBytePos &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">WriteByte((<span class="keyword">unsigned</span> <span class="keyword">char</span>)(newByte), fp);</span><br><span class="line"><span class="keyword">if</span> (newByte == <span class="number">255</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 特殊处理</span></span><br><span class="line">WriteByte((<span class="keyword">unsigned</span> <span class="keyword">char</span>)(<span class="number">0x00</span>), fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化更新</span></span><br><span class="line">newBytePos = <span class="number">7</span>;</span><br><span class="line">newByte = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-实现效果："><a href="#7-实现效果：" class="headerlink" title="7.实现效果："></a>7.实现效果：</h4><p>对不同等级的量化程度进行测试，均得到理想效果：</p><p>例如下面是量化等级为5时的结果图：</p><p><img src="https://img-blog.csdnimg.cn/20181209192830119.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20181209192837786.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>参考文献：</strong></p><p><a href="https://www.codingnow.com/2000/download/jpeg.txt" target="_blank" rel="noopener">https://www.codingnow.com/2000/download/jpeg.txt</a></p><p><a href="https://www.impulseadventure.com/photo/jpeg-huffman-coding.html" target="_blank" rel="noopener">https://www.impulseadventure.com/photo/jpeg-huffman-coding.html</a></p><p><a href="https://www.w3.org/Graphics/JPEG/jfif.txt" target="_blank" rel="noopener">https://www.w3.org/Graphics/JPEG/jfif.txt</a></p><p><a href="https://blog.csdn.net/carson2005/article/details/7753499" target="_blank" rel="noopener">https://blog.csdn.net/carson2005/article/details/7753499</a></p><p><a href="https://blog.csdn.net/fzh2712/article/details/28318715" target="_blank" rel="noopener">https://blog.csdn.net/fzh2712/article/details/28318715</a></p><p><strong>附录：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">附:JPEG 文件格式</span><br><span class="line">~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - 文件头 (2 bytes):  $ff, $d8 (SOI) (JPEG 文件标识)</span></span><br><span class="line"><span class="code">  - 任意数量的段 , 见后面</span></span><br><span class="line"><span class="code">  - 文件结束 (2 bytes): $ff, $d9 (EOI)</span></span><br><span class="line"></span><br><span class="line">段的格式:</span><br><span class="line">~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - header (4 bytes):</span></span><br><span class="line"><span class="code">       $ff     段标识</span></span><br><span class="line"><span class="code">        n      段的类型 (1 byte)</span></span><br><span class="line"><span class="code">       sh, sl  该段长度, 包括这两个字节, 但是不包括前面的 $ff 和 n.</span></span><br><span class="line"><span class="code">               注意: 长度不是 intel 次序, 而是 Motorola 的, 高字节在前,</span></span><br><span class="line"><span class="code">       低字节在后!</span></span><br><span class="line"><span class="code">  - 该段的内容, 最多 65533 字节</span></span><br><span class="line"></span><br><span class="line"><span class="code"> 注意:</span></span><br><span class="line"><span class="code">  - 有一些无参数的段 (下面那些前面注明星号的)</span></span><br><span class="line"><span class="code">    这些段没有长度描述 (而且没有内容), 只有 $ff 和类型字节.</span></span><br><span class="line"><span class="code">  - 段之间无论有多少 $ff 都是合法的, 必须被忽略掉.</span></span><br><span class="line"></span><br><span class="line">段的类型:</span><br><span class="line">~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">   *TEM   = $01   可以忽略掉</span></span><br><span class="line"></span><br><span class="line"><span class="code">    SOF0  = $c0   帧开始 (baseline JPEG), 细节附后</span></span><br><span class="line"><span class="code">    SOF1  = $c1   dito</span></span><br><span class="line"><span class="code">    SOF2  = $c2   通常不支持</span></span><br><span class="line"><span class="code">    SOF3  = $c3   通常不支持</span></span><br><span class="line"></span><br><span class="line"><span class="code">    SOF5  = $c5   通常不支持</span></span><br><span class="line"><span class="code">    SOF6  = $c6   通常不支持</span></span><br><span class="line"><span class="code">    SOF7  = $c7   通常不支持</span></span><br><span class="line"></span><br><span class="line"><span class="code">    SOF9  = $c9   arithmetic 编码(Huffman 的一种扩展算法), 通常不支持</span></span><br><span class="line"><span class="code">    SOF10 = $ca   通常不支持</span></span><br><span class="line"><span class="code">    SOF11 = $cb   通常不支持</span></span><br><span class="line"></span><br><span class="line"><span class="code">    SOF13 = $cd   通常不支持</span></span><br><span class="line"><span class="code">    SOF14 = $ce   通常不支持</span></span><br><span class="line"><span class="code">    SOF14 = $ce   通常不支持</span></span><br><span class="line"><span class="code">    SOF15 = $cf   通常不支持</span></span><br><span class="line"></span><br><span class="line"><span class="code">    DHT   = $c4   定义 Huffman Table,  细节附后</span></span><br><span class="line"><span class="code">    JPG   = $c8   未定义/保留 (引起解码错误)</span></span><br><span class="line"><span class="code">    DAC   = $cc   定义 Arithmetic Table, 通常不支持</span></span><br><span class="line"></span><br><span class="line"><span class="code">   *RST0  = $d0   RSTn 用于 resync, 通常被忽略</span></span><br><span class="line"><span class="code">   *RST1  = $d1</span></span><br><span class="line"><span class="code">   *RST2  = $d2</span></span><br><span class="line"><span class="code">   *RST3  = $d3</span></span><br><span class="line"><span class="code">   *RST4  = $d4</span></span><br><span class="line"><span class="code">   *RST5  = $d5</span></span><br><span class="line"><span class="code">   *RST6  = $d6</span></span><br><span class="line"><span class="code">   *RST7  = $d7</span></span><br><span class="line"></span><br><span class="line"><span class="code">    SOI   = $d8   图片开始</span></span><br><span class="line"><span class="code">    EOI   = $d9   图片结束</span></span><br><span class="line"><span class="code">    SOS   = $da   扫描行开始, 细节附后</span></span><br><span class="line"><span class="code">    DQT   = $db   定义 Quantization Table, 细节附后</span></span><br><span class="line"><span class="code">    DNL   = $dc   通常不支持, 忽略</span></span><br><span class="line"><span class="code">    DRI   = $dd   定义重新开始间隔, 细节附后</span></span><br><span class="line"><span class="code">    DHP   = $de   忽略 (跳过)</span></span><br><span class="line"><span class="code">    EXP   = $df   忽略 (跳过)</span></span><br><span class="line"></span><br><span class="line"><span class="code">    APP0  = $e0   JFIF APP0 segment marker (细节略)</span></span><br><span class="line"><span class="code">    APP15 = $ef   忽略</span></span><br><span class="line"></span><br><span class="line"><span class="code">    JPG0  = $f0   忽略 (跳过)</span></span><br><span class="line"><span class="code">    JPG13 = $fd   忽略 (跳过)</span></span><br><span class="line"><span class="code">    COM   = $fe   注释, 细节附后</span></span><br><span class="line"></span><br><span class="line"><span class="code"> 其它的段类型都保留必须跳过</span></span><br><span class="line"></span><br><span class="line">SOF0: Start Of Frame 0:</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - $ff, $c0 (SOF0)</span></span><br><span class="line"><span class="code">  - 长度 (高字节, 低字节), 8+components*3</span></span><br><span class="line"><span class="code">  - 数据精度 (1 byte) 每个样本位数, 通常是 8 (大多数软件不支持 12 和 16)</span></span><br><span class="line"><span class="code">  - 图片高度 (高字节, 低字节), 如果不支持 DNL 就必须 &gt;0</span></span><br><span class="line"><span class="code">  - 图片宽度 (高字节, 低字节), 如果不支持 DNL 就必须 &gt;0</span></span><br><span class="line"><span class="code">  - components 数量(1 byte), 灰度图是 1, YCbCr/YIQ 彩色图是 3, CMYK 彩色图</span></span><br><span class="line"><span class="code">    是 4</span></span><br><span class="line"><span class="code">  - 每个 component: 3 bytes</span></span><br><span class="line"><span class="code">     - component id (1 = Y, 2 = Cb, 3 = Cr, 4 = I, 5 = Q)</span></span><br><span class="line"><span class="code">     - 采样系数 (bit 0-3 vert., 4-7 hor.)</span></span><br><span class="line"><span class="code">     - quantization table 号</span></span><br><span class="line"></span><br><span class="line">DRI: Define Restart Interval:</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - $ff, $dd (DRI)</span></span><br><span class="line"><span class="code">  - 长度 (高字节, 低字节), 必须是 4</span></span><br><span class="line"><span class="code">  - MCU 块的单元中的重新开始间隔 (高字节, 低字节),</span></span><br><span class="line"><span class="code">    意思是说, 每 n 个 MCU 块就有一个 RSTn 标记.</span></span><br><span class="line"><span class="code">    第一个标记是 RST0, 然后是 RST1 等, RST7 后再从 RST0 重复 </span></span><br><span class="line"></span><br><span class="line">DQT: Define Quantization Table:</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - $ff, $db (DQT)</span></span><br><span class="line"><span class="code">  - 长度 (高字节, 低字节)</span></span><br><span class="line"><span class="code">  - QT 信息 (1 byte):</span></span><br><span class="line"><span class="code">     bit 0..3: QT 号(0..3, 否则错误)</span></span><br><span class="line"><span class="code">     bit 4..7: QT 精度, 0 = 8 bit, 否则 16 bit</span></span><br><span class="line"><span class="code">  - n 字节的 QT, n = 64*(精度+1)</span></span><br><span class="line"></span><br><span class="line"><span class="code"> 备注:</span></span><br><span class="line"><span class="code">  - 一个单独的 DQT 段可以包含多个 QT, 每个都有自己的信息字节</span></span><br><span class="line"><span class="code">  - 当精度=1 (16 bit), 每个字都是高位在前低位在后</span></span><br><span class="line"></span><br><span class="line">DAC: Define Arithmetic Table:</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"><span class="code"> 法律原因, 现在的软件不支持 arithmetic 编码.</span></span><br><span class="line"><span class="code"> 不能生产使用 arithmetic 编码的 JPEG 文件</span></span><br><span class="line"></span><br><span class="line">DHT: Define Huffman Table:</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - $ff, $c4 (DHT)</span></span><br><span class="line"><span class="code">  - 长度 (高字节, 低字节)</span></span><br><span class="line"><span class="code">  - HT 信息 (1 byte):</span></span><br><span class="line"><span class="code">     bit 0..3: HT 号 (0..3, 否则错误)</span></span><br><span class="line"><span class="code">     bit 4   : HT 类型, 0 = DC table, 1 = AC table</span></span><br><span class="line"><span class="code">     bit 5..7: 必须是 0</span></span><br><span class="line"><span class="code">  - 16 bytes: 长度是 1..16 代码的符号数. 这 16 个数的和应该 &lt;=256</span></span><br><span class="line"><span class="code">  - n bytes: 一个包含了按递增次序代码长度排列的符号表</span></span><br><span class="line"><span class="code">    (n = 代码总数)</span></span><br><span class="line"></span><br><span class="line"><span class="code"> 备注:</span></span><br><span class="line"><span class="code">  - 一个单独的 DHT 段可以包含多个 HT, 每个都有自己的信息字节</span></span><br><span class="line"></span><br><span class="line">COM: 注释:</span><br><span class="line">~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - $ff, $fe (COM)</span></span><br><span class="line"><span class="code">  - 注释长度 (高字节, 低字节) = L+2</span></span><br><span class="line"><span class="code">  - 注释为长度为 L 的字符流</span></span><br><span class="line"></span><br><span class="line">SOS: Start Of Scan:</span><br><span class="line">~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - $ff, $da (SOS)</span></span><br><span class="line"><span class="code">  - 长度 (高字节, 低字节), 必须是 6+2*(扫描行内组件的数量)</span></span><br><span class="line"><span class="code">  - 扫描行内组件的数量 (1 byte), 必须 &gt;= 1 , &lt;=4 (否则是错的) 通常是 3</span></span><br><span class="line"><span class="code">  - 每个组件: 2 bytes</span></span><br><span class="line"><span class="code">     - component id (1 = Y, 2 = Cb, 3 = Cr, 4 = I, 5 = Q), 见 SOF0</span></span><br><span class="line"><span class="code">     - 使用的 Huffman 表:</span></span><br><span class="line"><span class="code">- bit 0..3: AC table (0..3)</span></span><br><span class="line"><span class="code">- bit 4..7: DC table (0..3)</span></span><br><span class="line"><span class="code">  - 忽略 3 bytes (???)</span></span><br><span class="line"></span><br><span class="line"><span class="code"> 备注:</span></span><br><span class="line"><span class="code">  - 图片数据 (一个个扫描行) 紧接着 SOS 段.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;编译环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;windows10下MinGW&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;c++ &amp;amp;&amp;amp; CImg库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行命令&lt;/strong&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="多媒体技术" scheme="http://yoursite.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="多媒体技术" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>自定义协议实现点对点大文件传输</title>
    <link href="http://yoursite.com/2019/07/06/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%AF%B9%E7%82%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    <id>http://yoursite.com/2019/07/06/自定义协议实现点对点大文件传输/</id>
    <published>2019-07-06T13:03:08.000Z</published>
    <updated>2019-07-06T13:03:39.834Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20181120233209761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这一部分其实就是实现客户端与服务端的一个大文件的传输，因为题目要求是只需要自定义应用层协议，所以本项目是基于TCP(传输层)协议下实现的。采用的是python的struct模块对传输信息进行打包以便应对不同类型的传输文件，同时可以转为用于传输的byte类型。</p><p>针对大文件的传输开始是想直接用动态分配内存给文件传输分配一个大容量的堆作为缓冲区，但感觉这样就违背了本题的意思而且对于文件传输的效率不高，于是采用小缓冲区分段对文件进行传输。</p><p><strong>实现的功能为：</strong></p><p>服务端接收来自客户端的需求请求后</p><p>服务端实现三个功能：<br>1.客户端请求下载服务端的文件，服务端返回给客户端可下载的文件列表，服务端根据列表选项完成下载<br>2.客户端请求上传文件，选择一个本地的文件进行上传<br>3.客户端请求断开连接同时关闭服务器</p><p><strong>待完善功能：</strong></p><p>实现多线程连接 (本题来说必要性不大感觉)</p><p>利用python的gui模块做一个整洁好看的界面 (尝试过被出现的奇奇怪怪的bug打败)</p><p><strong>客户端：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">接收来自客户端的需求请求后</span></span><br><span class="line"><span class="string">服务端实现三个功能：</span></span><br><span class="line"><span class="string">1.客户端请求下载服务端的文件，服务端返回给客户端可下载的文件列表，服务端根据列表选项完成下载</span></span><br><span class="line"><span class="string">2.客户端请求上传文件，选择一个本地的文件进行上传</span></span><br><span class="line"><span class="string">3.客户端请求断开连接同时关闭服务器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">CS之间的传输的应用层协议自定义为：</span></span><br><span class="line"><span class="string">基于TCP传输层协议下：</span></span><br><span class="line"><span class="string">使用python的struct模块，对发送的数据进行pack打包</span></span><br><span class="line"><span class="string">将包内数据转为可传输的byte类型，接收端接收后拆包为str或int等类型进行应用</span></span><br><span class="line"><span class="string">根据包头信息对包类型以及大小的定义可以完成不同类型的数据的网络传输</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">filepath = <span class="string">'.'</span> + <span class="string">'/'</span> <span class="comment">#服务器用于和客户端传输文件的文件库</span></span><br><span class="line"></span><br><span class="line">HOST = <span class="string">''</span></span><br><span class="line">PORT = <span class="number">8686</span></span><br><span class="line">BUF_SIZE = <span class="number">1024</span> <span class="comment">#缓冲区大小</span></span><br><span class="line">ADDR = (HOST, PORT) <span class="comment">#socket</span></span><br><span class="line"></span><br><span class="line">SerSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">SerSock.bind(ADDR)</span><br><span class="line"><span class="comment">#开始监听</span></span><br><span class="line">SerSock.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'Waiting for connection...'</span>)</span><br><span class="line">CliSock, addr = SerSock.accept()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'...connected from: '</span>, addr)</span><br><span class="line">CliSock.send(<span class="string">'connected successfully'</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment">#接收客户端请求的功能需求</span></span><br><span class="line">data = CliSock.recv(BUF_SIZE)</span><br><span class="line">data = data.decode()</span><br><span class="line"><span class="keyword">if</span> data == <span class="string">'1'</span>:</span><br><span class="line"><span class="comment">#显示给客户端可以下载的文件列表</span></span><br><span class="line">CliSock.send(<span class="string">'the list of files you can download: '</span>.encode())</span><br><span class="line">dirs = os.listdir(filepath)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="comment">#统计列表中文件的数量发送给客户端</span></span><br><span class="line"><span class="keyword">for</span> dir <span class="keyword">in</span> dirs:</span><br><span class="line">count = count + <span class="number">1</span></span><br><span class="line">CliSock.send(struct.pack(<span class="string">'i'</span>, count)) <span class="comment">#i表示传输的包为int型</span></span><br><span class="line"><span class="comment">#将列表中的文件名逐一发送给客户端</span></span><br><span class="line"><span class="keyword">for</span> dir <span class="keyword">in</span> dirs:</span><br><span class="line"><span class="comment">#256si：s表示char类型, i表示int类型, 256表示包可传送的字节大小</span></span><br><span class="line">CliSock.send(struct.pack(<span class="string">'256si'</span>, bytes(dir, <span class="string">'utf-8'</span>), os.stat(filepath+dir).st_size))</span><br><span class="line">file = CliSock.recv(struct.calcsize(<span class="string">'128si'</span>))</span><br><span class="line"><span class="keyword">if</span> file:</span><br><span class="line"><span class="comment">#解包,接收客户端下载需求</span></span><br><span class="line">fname, fisize= struct.unpack(<span class="string">'128si'</span>, file)</span><br><span class="line">fs = fname.decode().strip(<span class="string">'\0'</span>)</span><br><span class="line"><span class="keyword">if</span> fs <span class="keyword">in</span> dirs:</span><br><span class="line"><span class="comment">#将包的具体信息发送给客户端</span></span><br><span class="line">fhead = struct.pack(<span class="string">'256si'</span>,os.path.basename(fs).encode(), os.stat(filepath+fs).st_size)</span><br><span class="line">CliSock.send(fhead)</span><br><span class="line"><span class="comment">#读取文件并将文件按照缓冲区(1KB)上限拆分发送</span></span><br><span class="line">fs = filepath+fs</span><br><span class="line">fp = open(fs, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">fdata = fp.read(BUF_SIZE)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> fdata:</span><br><span class="line">print(<span class="string">'send successfully'</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">CliSock.send(fdata)</span><br><span class="line">fp.close()</span><br><span class="line"><span class="comment">#CliSock.close()</span></span><br><span class="line"><span class="comment">#break</span></span><br><span class="line"><span class="keyword">elif</span> data == <span class="string">'2'</span>:</span><br><span class="line"><span class="comment">#接收来自服务端发送的文件的名称及大小信息</span></span><br><span class="line">file = CliSock.recv(struct.calcsize(<span class="string">'256si'</span>))</span><br><span class="line"><span class="keyword">if</span> file:</span><br><span class="line">fname, fsize = struct.unpack(<span class="string">'256si'</span>, file)</span><br><span class="line">fs = fname.decode().strip(<span class="string">'\0'</span>)</span><br><span class="line">newfile = os.path.join(<span class="string">'new_'</span> + fs)</span><br><span class="line"><span class="comment">#将接收的新文件放在服务端用于接收客户端文件的目录下</span></span><br><span class="line">newfile = filepath + newfile</span><br><span class="line">fp = open(newfile, <span class="string">'wb'</span>)</span><br><span class="line"><span class="comment">#获取每次服务端发送来的文件内容，并逐一写入新文件中</span></span><br><span class="line"><span class="comment">#判断不足1024时要只写入剩下的字节，否则会产生错码</span></span><br><span class="line">resize = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> resize == fsize:</span><br><span class="line"><span class="keyword">if</span> fsize - resize &gt; BUF_SIZE:</span><br><span class="line">data = CliSock.recv(BUF_SIZE)</span><br><span class="line">resize = resize + len(data)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">data = CliSock.recv(fsize - resize)</span><br><span class="line">resize = fsize</span><br><span class="line">fp.write(data)</span><br><span class="line">fp.close()</span><br><span class="line">print(<span class="string">'receive successfully'</span>)</span><br><span class="line"><span class="comment">#CliSock.close()</span></span><br><span class="line"><span class="comment">#break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#退出</span></span><br><span class="line"><span class="keyword">elif</span> data == <span class="string">'exit'</span>:</span><br><span class="line">CliSock.close()</span><br><span class="line">print(<span class="string">'shut down the connection with client successfully! '</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="comment">#代表客户端的输入无法识别，不做处理</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="comment">#CliSock.close()</span></span><br><span class="line">SerSock.close()</span><br><span class="line">print(<span class="string">'exit server successfully! '</span>)</span><br></pre></td></tr></table></figure><p><strong>客户端：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'localhost'</span></span><br><span class="line">PORT = <span class="number">8686</span></span><br><span class="line">BUF_SIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line">CliSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">CliSock.connect(ADDR)</span><br><span class="line"></span><br><span class="line">print(str(CliSock.recv(BUF_SIZE), <span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment">#功能UI</span></span><br><span class="line">print(<span class="string">'\n'</span>+<span class="string">'------- 1 express download a file -------'</span>+<span class="string">'\n'</span>+<span class="string">'-------- 2 express upload a file --------'</span>+<span class="string">'\n'</span>+<span class="string">'--- exit express shut down server and client ---'</span>+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment">#选择功能需求发送给服务端</span></span><br><span class="line">type = input(<span class="string">'What type of service do you need? '</span>+<span class="string">'\n'</span>)</span><br><span class="line">CliSock.send(type.encode())</span><br><span class="line"><span class="keyword">if</span> type == <span class="string">'1'</span>:</span><br><span class="line">print(str(CliSock.recv(BUF_SIZE),<span class="string">'utf-8'</span>) + <span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#获取文件总数</span></span><br><span class="line">filesize = CliSock.recv(struct.calcsize(<span class="string">'i'</span>))</span><br><span class="line">filesize, = struct.unpack(<span class="string">'i'</span>, filesize)</span><br><span class="line"><span class="comment">#filesize = int(filesize.decode())</span></span><br><span class="line">fdict = &#123;&#125; <span class="comment">#记录文件名为索引的文件大小</span></span><br><span class="line">filenum = filesize</span><br><span class="line"><span class="comment">#获得服务端返回的可下载文件列表并一一显示</span></span><br><span class="line"><span class="keyword">while</span> filesize:</span><br><span class="line">filepath = CliSock.recv(struct.calcsize(<span class="string">'256si'</span>))</span><br><span class="line">file_name, ffsize= struct.unpack(<span class="string">'256si'</span>, filepath)</span><br><span class="line">file_name = file_name.decode(<span class="string">'utf-8'</span>).strip(<span class="string">'\0'</span>)</span><br><span class="line">print(file_name+<span class="string">'    ------ '</span> +str(ffsize//<span class="number">1024</span>+<span class="number">1</span>)+<span class="string">'KB'</span>)</span><br><span class="line">fdict[file_name] = ffsize</span><br><span class="line">filesize = filesize - <span class="number">1</span> </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'\n'</span>+<span class="string">'the sum of the file is %d'</span> %filenum + <span class="string">'\n'</span>)</span><br><span class="line">file = input(<span class="string">'Select the file you want to download: '</span>+<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#将想下载的文件名传输给服务端以便获得服务端发送的该文件具体信息</span></span><br><span class="line">fhead = struct.pack(<span class="string">'128si'</span>, file.encode(), fdict[file])</span><br><span class="line">CliSock.send(fhead)</span><br><span class="line"><span class="comment">#接收服务端发送来的文件详细信息</span></span><br><span class="line">files = CliSock.recv(struct.calcsize(<span class="string">'256si'</span>))</span><br><span class="line"><span class="keyword">if</span> files:</span><br><span class="line">fname, fsize = struct.unpack(<span class="string">'256si'</span>, files)</span><br><span class="line">fs = fname.decode().strip(<span class="string">'\0'</span>)</span><br><span class="line"><span class="comment">#新文件的存储名</span></span><br><span class="line">newfile = os.path.join(<span class="string">'new_'</span> + fs)</span><br><span class="line">fp = open(newfile, <span class="string">'wb'</span>)</span><br><span class="line">print(<span class="string">'Its receiving..., wait a minute...'</span>+<span class="string">'\n'</span>)</span><br><span class="line">resize = <span class="number">0</span></span><br><span class="line"><span class="comment">#获取每次服务端发送来的文件内容，并逐一写入新文件中</span></span><br><span class="line"><span class="comment">#判断不足1024时要只写入剩下的字节，否则会产生错码</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> resize == fsize:</span><br><span class="line"><span class="keyword">if</span> fsize - resize &gt; BUF_SIZE:</span><br><span class="line">data = CliSock.recv(BUF_SIZE)</span><br><span class="line">resize = resize + len(data)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">data = CliSock.recv(fsize - resize)</span><br><span class="line">resize = fsize</span><br><span class="line">fp.write(data)</span><br><span class="line">fp.close()</span><br><span class="line">print(<span class="string">'receive successfully'</span>)</span><br><span class="line"><span class="comment">#CliSock.close()</span></span><br><span class="line"><span class="comment">#break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> type == <span class="string">'2'</span>:</span><br><span class="line">data = input(<span class="string">'input the dir of the file you want to upload: '</span>+<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#选择要上传的文件名, 若文件名错误或不存在则重新输入</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> os.path.isfile(data):</span><br><span class="line">data = input(<span class="string">'Wrong! Please input again: '</span>+<span class="string">'\n'</span>)</span><br><span class="line">fhead = struct.pack(<span class="string">'256si'</span>,os.path.basename(data).encode(), os.stat(data).st_size)</span><br><span class="line">CliSock.send(fhead)</span><br><span class="line">fp = open(data, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">fdata = fp.read(BUF_SIZE)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> fdata:</span><br><span class="line">print(<span class="string">'send successfully'</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">CliSock.send(fdata)</span><br><span class="line">fp.close()</span><br><span class="line"><span class="comment">#CliSock.close()</span></span><br><span class="line"><span class="comment">#break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#退出客户端与服务端的连接</span></span><br><span class="line"><span class="keyword">elif</span> type == <span class="string">'exit'</span>:</span><br><span class="line">CliSock.close()</span><br><span class="line">print(<span class="string">'shut down the connection with server successfully! '</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">type = input(<span class="string">'wrong input. Please input again: '</span>+<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181120233209761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>区块链阅读(stateRoot, nonce, Hyperledger Fabric)</title>
    <link href="http://yoursite.com/2019/07/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%98%85%E8%AF%BB-stateRoot-nonce-HyperledgerFabric/"/>
    <id>http://yoursite.com/2019/07/06/区块链阅读-stateRoot-nonce-HyperledgerFabric/</id>
    <published>2019-07-06T12:28:06.000Z</published>
    <updated>2019-07-06T12:29:01.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区块链阅读报告"><a href="#区块链阅读报告" class="headerlink" title="区块链阅读报告"></a>区块链阅读报告</h2><h3 id="为什么要有stateRoot？"><a href="#为什么要有stateRoot？" class="headerlink" title="为什么要有stateRoot？"></a>为什么要有stateRoot？</h3><p>以太坊中的每一个块都包含一个stateRoot，这是一种特殊类型的Merkle树 (Merkle Patricia Tree) 的根哈希。它存储系统的整个状态：所有账户余额，合同存储，合同代码和账户里的nonce。</p><p>这样做的目的是只允许给出最后一个块的节点，以及最后一个块实际上是最新块的保证，通过简单的下载，可以非常快速地与区块链“同步”而无需处理任何历史交易从网络中的节点开始的树的其余部分，通过检查所有哈希是否匹配来验证树是否正确，然后从那里继续。 </p><p>对于轻型客户端，stateRoot更加有利：它们可以通过简单地向网络询问树的特定分支来立即确定任何帐户的确切平衡和状态，而无需遵循比特币的多步骤1-of-N “询问所有交易输出，然后要求所有交易支出这些产出，并采取其余的”轻客户模型。 </p><h3 id="nonce值有什么用？"><a href="#nonce值有什么用？" class="headerlink" title="nonce值有什么用？"></a>nonce值有什么用？</h3><p><strong>Nonce</strong>是一个在加密通信只能使用一次的数字。在认证协议中，它往往是一个随机或伪随机数，以避免重放攻击。Nonce也用于流密码以确保安全。如果需要使用相同的密钥加密一个以上的消息，就需要Nonce来确保不同的消息与该密钥加密的密钥流不同。 </p><p>在以太坊中，为了防止交易重复进行，以太坊要求每笔交易必须有一个nonce数值。nonce值从0开始递增，每发送一笔交易，nonce便加1。</p><p>只有当前面nonce值较小的交易处理完成之后才会处理后面nonce值较大的交易。</p><p><strong>以太坊处理nonce的规则：</strong></p><ol><li>当nonce小于之前已经有交易使用的nonce值，交易会被拒绝；</li><li>当nonce大于当前应该使用的nonce时，交易会一直处于队列之中进行等待，交易依次执行，直到补齐中间间隔的nonce值，才可以执行。</li><li>当有一笔处于pending状态的交易，新的一笔交易与其拥有相同的nonce值，如果新交易的gas price太小，无法覆盖pending状态的交易，如果新交易的gas price高于原交易的110%，则原交易会被覆盖掉。</li></ol><h3 id="Hyperledger-Fabric的特点，和Composer的关系"><a href="#Hyperledger-Fabric的特点，和Composer的关系" class="headerlink" title="Hyperledger Fabric的特点，和Composer的关系?"></a>Hyperledger Fabric的特点，和Composer的关系?</h3><p>*<em>Hyperledger Fabric的特点: *</em></p><ul><li>开放性<ul><li>超级账本是linux基金会2015年底成立的。自成立后吸引了大批企业，包括IBM、accenture、intel、cisco、HITACHI等大企业的加入。现在的Fabric源代码主要由IBM和Digital Asset这两家公司提供。是IBM开源的blockchain项目。</li></ul></li><li>开源<ul><li>Fabric的源代码的开源的，所有开发者或企业机构都可以自由地下载，进行研究，在此基础上结合业务场景，在不同的商业场景上应用落地。</li></ul></li><li>SDK支持多语言，减低门槛<ul><li>目前Fabric SDK支持go、java、js，python四种主流语言，大多数开发者可以快速的上手，降低了开发的门槛和成本。此外，还有一个Hyper ledger Composer工具，可以快速地搭建环境。</li></ul></li><li>可插拔，可扩展<ul><li>Fabric中的CA、数据库、共识算法都是可插拔的。而且，Fabric中的链码是通过docker实现。</li></ul></li><li>基于联盟链的前提，兼顾数据共享和隐私保护<ul><li>Fabric最多的特点是引入了链码和通道的概念。在Fabric中，通过channel，也即通道隔离数据，只有在这个通道的节点才能共享账本，二访问不了其他账本。通过建立不同的通道，可实现按需共享的目的。更符合现实生活的商业场景。</li></ul></li></ul><p><strong>Hyperledger Fabric和Composer的关系：</strong></p><p>Hyperledger Fabric是一个私有区块链网络，为事务性企业应用程序提供基础。 </p><p>Hyperledger Composer是一个加速开发基于Hyperledger Fabric构建的应用程序的框架 。</p><p>Composer框架在其自己的隔离运行时中运行，并通过连接配置文件连接到Fabric网络，该配置文件允许部署由Composer框架生成的已定义的业务网络定义<strong>（BND）</strong>存档文件<strong>（.bna文件）</strong> 。</p><h3 id="联盟链智能合约和中心账本的区别？"><a href="#联盟链智能合约和中心账本的区别？" class="headerlink" title="联盟链智能合约和中心账本的区别？"></a>联盟链智能合约和中心账本的区别？</h3><p>联盟区块链是指其共识过程受到预选节点控制的区块链；例如，不妨想象一个有15个金融机构组成的共同体，每个机构都运行着一个节点，而且为了使每个区块生效需要获得其中10个机构的确认（2/3确认）。区块链或许允许每个人都可读取，或者只受限于参与者，或走混合型路线，例如区块的根哈希及其API（应用程序接口）对外公开，API可允许外界用来作有限次数的查询和获取区块链状态的信息。这些区块链可视为“部分去中心化”。 其智能合约的记账方式也是介于分布式记账和中心记账之间。</p><p>而中心账簿则是完全中心化的记账方式，只由一方(中心机构)实现记账。这种中心化的记账方式，无法保证数据的安全性，也建立不起一个可信的机制，即无法让人信服这个账本数据的真实性。比如银行，企业的财务账本，一旦出现某个人做假账，将会出现什么样的后果，而如果他们的财务数据突然被一把火烧了，产生的灾难可想而知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;区块链阅读报告&quot;&gt;&lt;a href=&quot;#区块链阅读报告&quot; class=&quot;headerlink&quot; title=&quot;区块链阅读报告&quot;&gt;&lt;/a&gt;区块链阅读报告&lt;/h2&gt;&lt;h3 id=&quot;为什么要有stateRoot？&quot;&gt;&lt;a href=&quot;#为什么要有stateRoot？&quot; c
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Color transfer between images(lab颜色空间)</title>
    <link href="http://yoursite.com/2019/07/06/images-lab%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/"/>
    <id>http://yoursite.com/2019/07/06/images-lab颜色空间/</id>
    <published>2019-07-06T12:21:45.000Z</published>
    <updated>2019-07-06T13:16:34.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>可以根据课程 PPT 和对应参考文献(“Color transfer between images”)实现颜色转换。</p><p>  (a) 测试图像集合不低于 5 对图像(参考图和原图)；</p><p>  (b) 最后对实验结果进行分析，特别是存在问题进行分析，给出初步的改进建议方法和给出参考文献。 </p><h3 id="图像间的颜色转化："><a href="#图像间的颜色转化：" class="headerlink" title="图像间的颜色转化："></a>图像间的颜色转化：</h3><p>这个算法的核心关键在于两部分：</p><ul><li>1是rgb空间和lab空间的相互转化</li><li>2是在lab空间根据两幅图提取的均值和标准差进行转换处理</li></ul><p><strong>rgb-lab</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">float</span>&gt; ImgConverse::RGB_LAB(CImg&lt;<span class="keyword">float</span>&gt; picture, <span class="keyword">float</span> *mean, <span class="keyword">float</span> *<span class="built_in">std</span>) &#123;</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; pic = picture;</span><br><span class="line"><span class="keyword">float</span> sum[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">float</span> sum_std[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">sum[i] = <span class="number">0.0</span>; sum_std[i] = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> size = pic.width()*pic.height();</span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line"><span class="keyword">float</span> r = pic(x, y, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">float</span> g = pic(x, y, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">float</span> b = pic(x, y, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">float</span> L = <span class="number">0.3811</span> * r + <span class="number">0.5783</span> * g + <span class="number">0.0402</span> * b;</span><br><span class="line"><span class="keyword">float</span> M = <span class="number">0.1967</span> * r + <span class="number">0.7244</span> * g + <span class="number">0.0782</span> * b;</span><br><span class="line"><span class="keyword">float</span> S = <span class="number">0.0241</span> * r + <span class="number">0.1288</span> * g + <span class="number">0.8444</span> * b;</span><br><span class="line"><span class="keyword">if</span> (L == <span class="number">0</span>) L = <span class="built_in">log</span>(<span class="number">1</span>); <span class="keyword">else</span> L = <span class="built_in">log</span>(L);</span><br><span class="line"><span class="keyword">if</span> (M == <span class="number">0</span>) M = <span class="built_in">log</span>(<span class="number">1</span>); <span class="keyword">else</span> M = <span class="built_in">log</span>(M);</span><br><span class="line"><span class="keyword">if</span> (S == <span class="number">0</span>) S = <span class="built_in">log</span>(<span class="number">1</span>); <span class="keyword">else</span> S = <span class="built_in">log</span>(S);</span><br><span class="line"><span class="keyword">float</span> l = (<span class="number">1.0</span> / <span class="built_in">sqrt</span>(<span class="number">3</span>)) * (L + M + S);</span><br><span class="line"><span class="keyword">float</span> A = <span class="number">1.0</span> / <span class="built_in">sqrt</span>(<span class="number">6</span>) * L + <span class="number">1.0</span> / <span class="built_in">sqrt</span>(<span class="number">6</span>) * M - <span class="number">2.0</span> / <span class="built_in">sqrt</span>(<span class="number">6</span>) * S;</span><br><span class="line"><span class="keyword">float</span> B= <span class="number">1.0</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>) * L - <span class="number">1.0</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>) * M;</span><br><span class="line">pic(x, y, <span class="number">0</span>) = l; pic(x, y, <span class="number">1</span>) = A; pic(x, y, <span class="number">2</span>) = B;</span><br><span class="line">sum[<span class="number">0</span>] += l;</span><br><span class="line">sum[<span class="number">1</span>] += A;</span><br><span class="line">sum[<span class="number">2</span>] += B;</span><br><span class="line">&#125;</span><br><span class="line">mean[<span class="number">0</span>] = sum[<span class="number">0</span>] / size;</span><br><span class="line">mean[<span class="number">1</span>] = sum[<span class="number">1</span>] / size;</span><br><span class="line">mean[<span class="number">2</span>] = sum[<span class="number">2</span>] / size;</span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line">sum_std[<span class="number">0</span>] += <span class="built_in">pow</span>((pic(x, y, <span class="number">0</span>) - mean[<span class="number">0</span>]), <span class="number">2</span>);</span><br><span class="line">sum_std[<span class="number">1</span>] += <span class="built_in">pow</span>((pic(x, y, <span class="number">1</span>) - mean[<span class="number">1</span>]), <span class="number">2</span>);</span><br><span class="line">sum_std[<span class="number">2</span>] += <span class="built_in">pow</span>((pic(x, y, <span class="number">2</span>) - mean[<span class="number">2</span>]), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>[<span class="number">0</span>] = <span class="built_in">sqrt</span>(sum_std[<span class="number">0</span>] / size);</span><br><span class="line"><span class="built_in">std</span>[<span class="number">1</span>] = <span class="built_in">sqrt</span>(sum_std[<span class="number">1</span>] / size);</span><br><span class="line"><span class="built_in">std</span>[<span class="number">2</span>] = <span class="built_in">sqrt</span>(sum_std[<span class="number">2</span>] / size);</span><br><span class="line"><span class="keyword">return</span> pic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lab-rgb</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">float</span>&gt; ImgConverse::LAB_RGB(CImg&lt;<span class="keyword">float</span>&gt; picture) &#123;</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; pic = picture;</span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line"><span class="keyword">float</span> L = <span class="built_in">sqrt</span>(<span class="number">3</span>) / <span class="number">3</span> * pic(x, y, <span class="number">0</span>) + <span class="built_in">sqrt</span>(<span class="number">6</span>) / <span class="number">6</span> * pic(x, y, <span class="number">1</span>) + <span class="built_in">sqrt</span>(<span class="number">2</span>) / <span class="number">2</span> * pic(x, y, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">float</span> M = <span class="built_in">sqrt</span>(<span class="number">3</span>) / <span class="number">3</span> * pic(x, y, <span class="number">0</span>) + <span class="built_in">sqrt</span>(<span class="number">6</span>) / <span class="number">6</span> * pic(x, y, <span class="number">1</span>) - <span class="built_in">sqrt</span>(<span class="number">2</span>) / <span class="number">2</span> * pic(x, y, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">float</span> S = <span class="built_in">sqrt</span>(<span class="number">3</span>) / <span class="number">3</span> * pic(x, y, <span class="number">0</span>) - <span class="built_in">sqrt</span>(<span class="number">6</span>) / <span class="number">3</span> * pic(x, y, <span class="number">1</span>);</span><br><span class="line">L = <span class="built_in">exp</span>(L);</span><br><span class="line">M = <span class="built_in">exp</span>(M);</span><br><span class="line">S = <span class="built_in">exp</span>(S);</span><br><span class="line">pic(x, y, <span class="number">0</span>) = <span class="number">4.4679</span> * L - <span class="number">3.5873</span> * M + <span class="number">0.1193</span> * S;</span><br><span class="line">pic(x, y, <span class="number">1</span>) = <span class="number">-1.2186</span> * L + <span class="number">2.3809</span> * M - <span class="number">0.1624</span> * S;</span><br><span class="line">pic(x, y, <span class="number">2</span>) = <span class="number">0.0497</span> * L - <span class="number">0.2439</span> * M + <span class="number">1.2045</span> * S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转化处理：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImgConverse::colorTransfer() &#123;</span><br><span class="line">sourceImg.display(<span class="string">"源图"</span>);</span><br><span class="line">targetImg.display(<span class="string">"目标图"</span>);</span><br><span class="line">sourcelab = RGB_LAB(sourceImg, mean0, std0);</span><br><span class="line">targetlab = RGB_LAB(targetImg, mean1, std1);</span><br><span class="line">result = sourcelab;</span><br><span class="line">cimg_forXY(result, x, y) &#123;</span><br><span class="line">result(x, y, <span class="number">0</span>) = (result(x, y, <span class="number">0</span>) - mean0[<span class="number">0</span>])*std1[<span class="number">0</span>] / std0[<span class="number">0</span>] + mean1[<span class="number">0</span>];</span><br><span class="line">result(x, y, <span class="number">1</span>) = (result(x, y, <span class="number">1</span>) - mean0[<span class="number">1</span>])*std1[<span class="number">1</span>] / std0[<span class="number">1</span>] + mean1[<span class="number">1</span>];</span><br><span class="line">result(x, y, <span class="number">2</span>) = (result(x, y, <span class="number">2</span>) - mean0[<span class="number">2</span>])*std1[<span class="number">2</span>] / std0[<span class="number">2</span>] + mean1[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//targetlab = LAB_RGB(targetlab);</span></span><br><span class="line">result = LAB_RGB(result);</span><br><span class="line">result.display(<span class="string">"结果图"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试效果："><a href="#测试效果：" class="headerlink" title="测试效果："></a>测试效果：</h4><p>先拿ppt上的测试图进行一个效果测试，发现结果还不错。<br><img src="https://img-blog.csdnimg.cn/20181120231811254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181120231821626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181120231839898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>之后又测试了几张图</strong><br><img src="https://img-blog.csdnimg.cn/20181120231914301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181120231929905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181120231940371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181120232010800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181120232024199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181120232037701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="效果分析："><a href="#效果分析：" class="headerlink" title="效果分析："></a>效果分析：</h4><p> 从以上多张图的效果分析我们可以看出算法只是以参考区域的色彩信息作为准则，而完全忽略了目标区域的边缘，纹理等细节信息，只追求色彩与参考区域的完全一致，可能会使目标区域的细节信息过度丢失。通俗的说也就是有的图片效果会给人一种蒙蒙的感觉。</p><p>所以想到的解决方法也是用边缘分割以及通过调整梯度的阈值来获取局部边缘纹理等信息，通过调整不同目标对象的颜色迁移的幅度大小，实现的功能是类似与photoshop中添加蒙版以及通过调整流量和不透明度来是图片融合效果不显得那么突兀。</p><p><strong>参考文献：</strong></p><ul><li><p>Color transfer between images</p></li><li><p>Novel Algorithm for Local Color Transfer Based on Preserving Detail Texture</p></li></ul><p><strong>完整代码参见：</strong><br><a href="https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp4" target="_blank" rel="noopener">https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp4</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h3&gt;&lt;p&gt;可以根据课程 PPT 和对应参考文献(“Color transfer between images”)实现颜色转换。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>灰度直方图处理以及改进方法(hsv空间以及边缘检测)</title>
    <link href="http://yoursite.com/2019/07/06/%E7%81%B0%E5%BA%A6%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%A4%84%E7%90%86%E4%BB%A5%E5%8F%8A%E6%94%B9%E8%BF%9B%E6%96%B9%E6%B3%95-hsv%E7%A9%BA%E9%97%B4%E4%BB%A5%E5%8F%8A%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/07/06/灰度直方图处理以及改进方法-hsv空间以及边缘检测/</id>
    <published>2019-07-06T12:18:36.000Z</published>
    <updated>2019-07-06T12:19:20.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>用 CImg 编写灰度图像直方图均衡化： </p><p>   (a) 同学用手机拍摄不同光照情况下的图像，作为测试样本，不低于 5 张；</p><p>   (b) 分别针对灰度图像和彩色图像分别用直方图均衡化的方法完成结果；</p><p>   (c) 最后对实验结果进行分析，特别是彩色图像直接采用直方图均衡化效果如何进行分析，如果要改进应该从哪些方面进行改进。 </p><h3 id="直方图均衡化："><a href="#直方图均衡化：" class="headerlink" title="直方图均衡化："></a>直方图均衡化：</h3><h4 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h4><p>整个模块的核心代码是直方图均衡化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">int</span>&gt; ImgConverse::Hist(CImg&lt;<span class="keyword">int</span>&gt; picture) &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; img1 = picture;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic = img1;</span><br><span class="line"><span class="keyword">int</span> size = img1.size();</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; hist = img1.histogram(<span class="number">256</span>, <span class="number">0</span>, <span class="number">255</span>); <span class="comment">//histogram的第一个参数是共有256个灰度级，第二个参数是灰度的最小值，第三个是灰度最大值</span></span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">sum += (<span class="keyword">double</span>)hist(i) / size;</span><br><span class="line"><span class="keyword">int</span> Sum = (<span class="keyword">int</span>)(sum * <span class="number">255</span>);</span><br><span class="line">index.insert(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(i, Sum));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter = index.begin();</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator end = index.end();</span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line">pic(x, y) = index[pic(x, y)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<strong>灰度图</strong>的直方图均衡化比较简单，可以直接对灰度图进行直方图的均衡化处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将图片转为灰度图</span></span><br><span class="line"><span class="keyword">void</span> ImgConverse::toGray() &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic(img._width, img._height, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">cimg_forXY(img, x, y) &#123;</span><br><span class="line">pic(x, y) = img(x, y, <span class="number">0</span>) * <span class="number">0.2126</span> + img(x, y, <span class="number">1</span>) * <span class="number">0.7152</span> + img(x, y, <span class="number">2</span>) * <span class="number">0.0722</span>;</span><br><span class="line">&#125;</span><br><span class="line">gray_img = pic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ImgConverse::Hist_gray() &#123;</span><br><span class="line">toGray();</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic = gray_img;</span><br><span class="line">pic.display(<span class="string">"处理前图片"</span>);</span><br><span class="line"><span class="comment">//用于获取各个灰度级对应像素点的个数</span></span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; hist = pic.histogram(<span class="number">256</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="comment">//描绘直方图</span></span><br><span class="line">hist.display_graph(<span class="string">"处理前直方图"</span>);</span><br><span class="line">pic = Hist(gray_img);</span><br><span class="line">pic.display(<span class="string">"处理后图片"</span>);</span><br><span class="line">hist_equalImg = pic;</span><br><span class="line">hist = pic.histogram(<span class="number">256</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">hist.display_graph(<span class="string">"处理后直方图"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于<strong>彩色图片</strong>，因为其有rgb三个通道，所以处理过程会相对麻烦一点，我采取了两种办法</p><ol><li>将图片的rgb三个通道分别进行直方图均衡化再合并</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImgConverse::Hist_color() &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; _img = img;</span><br><span class="line">_img.display(<span class="string">"处理前图片"</span>);</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; hist = _img.histogram(<span class="number">256</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">hist.display_graph(<span class="string">"处理前直方图"</span>);</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; img_r(img._width, img._height, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; img_g = img_r, img_b = img_r;</span><br><span class="line">cimg_forXY(img, x, y) &#123;</span><br><span class="line">img_r(x, y) = img(x, y, <span class="number">0</span>);</span><br><span class="line">img_g(x, y) = img(x, y, <span class="number">1</span>);</span><br><span class="line">img_b(x, y) = img(x, y, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">img_r = Hist(img_r);</span><br><span class="line">img_g = Hist(img_g);</span><br><span class="line">img_b = Hist(img_b);</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic(img._width, img._height, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">cimg_forXY(img, x, y) &#123;</span><br><span class="line">pic(x, y, <span class="number">0</span>) = img_r(x, y);</span><br><span class="line">pic(x, y, <span class="number">1</span>) = img_g(x, y);</span><br><span class="line">pic(x, y, <span class="number">2</span>) = img_b(x, y);</span><br><span class="line">&#125;</span><br><span class="line">pic.display(<span class="string">"处理后图片"</span>);</span><br><span class="line">hist_equalImg = pic;</span><br><span class="line">hist = pic.histogram(<span class="number">256</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">hist.display_graph(<span class="string">"处理后直方图"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将彩色图从RGB空间转换到HSI(色彩，饱和度，亮度) 空间后再对其亮度空间进行直方图均衡化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将图片由rgb空间转为hsi空间并对其亮度空间进行直方图均衡</span></span><br><span class="line"><span class="keyword">void</span> ImgConverse::RGB_HSI() &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; img_ = img;</span><br><span class="line">img_.display(<span class="string">"处理前图片"</span>);</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; img0 = img_.histogram(<span class="number">256</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">img0.display_graph(<span class="string">"处理后直方图"</span>);</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; pic = img; <span class="comment">//定义float类型的目的是对其进行归一化</span></span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; hsi = img;</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; hsi_i(img.width(), img.height(), <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">hsi.RGBtoHSI(); <span class="comment">//将rgb空间转换到hsi(色彩,饱和度,亮度)空间，只对其中的亮度空间进行处理</span></span><br><span class="line">cimg_forXY(hsi, x, y) &#123;</span><br><span class="line">hsi_i(x, y) = hsi(x, y, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; hsi_ii = hsi_i.normalize(<span class="number">0</span>,<span class="number">255</span>);</span><br><span class="line">hsi_ii = Hist(hsi_ii);</span><br><span class="line">hsi_i = hsi_ii;</span><br><span class="line">hsi_i = hsi_i.normalize(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">cimg_forXY(hsi, x, y) &#123;</span><br><span class="line">hsi(x, y, <span class="number">2</span>) = hsi_i(x, y);</span><br><span class="line">&#125;</span><br><span class="line">hsi.HSItoRGB();</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; hist = hsi.normalize(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">hist.display(<span class="string">"处理后图片"</span>);</span><br><span class="line">hist_equalImg = hist;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; hist0 = pic.histogram(<span class="number">256</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">hist0.display_graph(<span class="string">"处理后直方图"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试效果："><a href="#测试效果：" class="headerlink" title="测试效果："></a>测试效果：</h4><p>下面一组图对应着分别在灰度图和彩色图处理下的直方图均衡化效果图以及灰度分布直方图，<strong>每一组的最后一张彩色图是转为lab空间下的图片</strong>。<br><img src="https://img-blog.csdnimg.cn/20181120231050438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181120231103878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181120231135114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181120231201896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181120231217216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181120231231705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>从分析效果可以看出对于彩色图的处理来说明显转为lab的效果要比直接三通道处理效果好得多。</strong></p><h4 id="效果分析："><a href="#效果分析：" class="headerlink" title="效果分析："></a>效果分析：</h4><p><em>均衡化有优点也有缺点</em></p><p><strong>优点是：</strong></p><ul><li><p>这种方法通常用来增加许多图像的局部对比度，尤其是当图像的有用数据的对比度相当接近的时候。通过这种方法，亮度可以更好地在直方图上分布。这样就可以用于增强局部的对比度而不影响整体的对比度，直方图均衡化通过有效地扩展常用的亮度来实现这种功能。这种方法对于背景和前景都太亮或者太暗的图像非常有用，这种方法尤其是可以带来X光图像中更好的骨骼结构显示以及曝光过度或者曝光不足照片中更好的细节。</p></li><li><p>这种方法的一个主要优势是它是一个相当直观的技术并且是可逆操作，如果已知均衡化函数，那么就可以恢复原始的直方图，并且计算量也不大。这种方法的一个缺点是它对处理的数据不加选择，它可能会增加背景杂讯的对比度并且降低有用信号的对比度。</p></li></ul><p><strong>缺点是：</strong></p><ul><li>变换后图像的灰度级减少，某些细节消失；</li><li>某些图像，如直方图有高峰，经处理后对比度不自然的过分增强。  </li></ul><p><strong>针对提出的缺点举一个例子：</strong></p><p>对孙俪这张图进行一下直方图均衡化，效果<em>孙俪看了想打人.jpg</em></p><p><img src="https://img-blog.csdnimg.cn/2018112023084961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181120230911992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>究其原因，主要是上张图对图片进行了一个整体的处理，而实际上我们并不想对背景板啊，墙啊这些进行处理，因为这些接近于纯色，他们处理后的对比度确实增强了，但拉低了人物的对比度，所以我们应用上节课学过的边缘分割先取图片边缘，然后只对其中不为零的点进行直方图均衡，得到的效果如下：<br><img src="https://img-blog.csdnimg.cn/2018112023092875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>但其实这个效果仍然有点微弱，实际更想做的是将主体这一个大类进行直方图均衡化而不仅仅是一个边缘，这个查了一下可能要用到语义分割和实例分割的知识，难度有点大，以后有时间希望能再深入做一下。<br><img src="https://img-blog.csdnimg.cn/20181120230939753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>完整代码参见：</strong><br><a href="https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp4" target="_blank" rel="noopener">https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp4</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h3&gt;&lt;p&gt;用 CImg 编写灰度图像直方图均衡化： &lt;/p&gt;
&lt;p&gt;   (a) 同学用手机拍摄不同光照情况下的图像，作为测试样本，不低于 5
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>ImageMorping</title>
    <link href="http://yoursite.com/2019/07/06/ImageMorping/"/>
    <id>http://yoursite.com/2019/07/06/ImageMorping/</id>
    <published>2019-07-06T12:13:42.000Z</published>
    <updated>2019-07-06T12:14:19.326Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目：ImageMorphing"><a href="#题目：ImageMorphing" class="headerlink" title="题目：ImageMorphing"></a>题目：ImageMorphing</h3><ul><li><strong>实现下面两张图中间11帧的变换</strong></li><li>参考文献：<a href="http://202.116.81.74/cache/1/03/web.media.mit.edu/9232d3e36ce968ec4fe798131c11e185/07_Image%20Morphing.pdf" target="_blank" rel="noopener">http://202.116.81.74/cache/1/03/web.media.mit.edu/9232d3e36ce968ec4fe798131c11e185/07_Image%20Morphing.pdf</a><br><img src="https://img-blog.csdnimg.cn/20181120230243901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p><img src="https://img-blog.csdnimg.cn/20181120230250880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h3><h4 id="1-网格的生成"><a href="#1-网格的生成" class="headerlink" title="1. 网格的生成"></a>1. 网格的生成</h4><p><strong>将源图像和目标图像通过建立特征点，形成点集，然后通过三角剖分的方法形成三角形网络</strong></p><p>1）把源图像中形成的三角形和目标图像生成的三角形（三角形对）对应起来。（对整体的源图像和目标图像来说，他们划分出网格之后，应该是同构的。）</p><p>因此将源图和目标图中需要建立网格的同构点存到两个文本中，再将所需要建立的图片的三角形网格对应的坐标位置存储在另一个文本中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读入源图中面部特征点</span></span><br><span class="line">ifstream filePoint;</span><br><span class="line">filePoint.open(<span class="string">"source.txt"</span>);</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (getline(filePoint, s)) &#123;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">ss &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="function">point <span class="title">p</span><span class="params">(x, y)</span></span>;</span><br><span class="line">source_point.push_back(p);</span><br><span class="line">&#125;</span><br><span class="line">filePoint.close();</span><br><span class="line"><span class="comment">//读入目标图中面部特征点</span></span><br><span class="line">filePoint.open(<span class="string">"target.txt"</span>);</span><br><span class="line"><span class="keyword">while</span> (getline(filePoint, s)) &#123;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">ss &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="function">point <span class="title">p</span><span class="params">(x, y)</span></span>;</span><br><span class="line">target_point.push_back(p);</span><br><span class="line">&#125;</span><br><span class="line">filePoint.close();</span><br><span class="line"><span class="comment">//读入需要建立的仿射变换网格点</span></span><br><span class="line">filePoint.open(<span class="string">"grid.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>, p3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (getline(filePoint, s)) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">ss &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; p3;</span><br><span class="line">p.push_back(p1);</span><br><span class="line">p.push_back(p2);</span><br><span class="line">p.push_back(p3);</span><br><span class="line">triangle_grid.push_back(p);</span><br><span class="line">&#125;</span><br><span class="line">filePoint.close();</span><br></pre></td></tr></table></figure><p>2）通过源三角形和目标三角形的顶点坐标值，使用仿射变换求出变换从源三角形到目标三角形的变换矩阵T。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取中间每一帧图片的三角形网格</span></span><br><span class="line"><span class="keyword">void</span> ImageMorphing::get_middleGrid() &#123;</span><br><span class="line"><span class="comment">//存储每一帧中间图的点</span></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="built_in">vector</span>&lt;point&gt;&gt; mid_point;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; frame; ++i) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;point&gt; temp;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; source_point.size(); ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="keyword">float</span>(source_point[j].x) + <span class="keyword">float</span>(<span class="keyword">float</span>(i + <span class="number">1</span>) / (frame + <span class="number">1</span>)) * <span class="keyword">float</span>(target_point[j].x - source_point[j].x);</span><br><span class="line"><span class="keyword">int</span> y = <span class="keyword">float</span>(source_point[j].y) + <span class="keyword">float</span>(<span class="keyword">float</span>(i + <span class="number">1</span>) / (frame + <span class="number">1</span>)) * <span class="keyword">float</span>(target_point[j].y - source_point[j].y);</span><br><span class="line"><span class="function">point <span class="title">p</span><span class="params">(x, y)</span></span>;</span><br><span class="line">temp.push_back(p);</span><br><span class="line">&#125;</span><br><span class="line">mid_point.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取中间每一帧的三角形网格</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; frame; ++i) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;triangle&gt; temp;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; triangle_grid.size(); ++j) &#123;</span><br><span class="line"><span class="function">triangle <span class="title">t</span><span class="params">(mid_point[i][triangle_grid[j][<span class="number">0</span>]], mid_point[i][triangle_grid[j][<span class="number">1</span>]], mid_point[i][triangle_grid[j][<span class="number">2</span>]])</span></span>;</span><br><span class="line">temp.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line">mid_triangle.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ImageMorphing::AffineTransform() &#123;</span><br><span class="line"><span class="comment">//获取每一帧图与源图网格的变换矩阵</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; frame; ++i) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;CImg&lt;<span class="keyword">float</span>&gt;&gt; temp;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; triangle_grid.size(); ++j) &#123;</span><br><span class="line">triangle src = mid_triangle[i][j];</span><br><span class="line">triangle dst = source_triangle[j];</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; A(<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; y1(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), y2(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; c1(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), c2(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">A(<span class="number">0</span>, <span class="number">0</span>) = src.a.x; A(<span class="number">1</span>, <span class="number">0</span>) = src.a.y;</span><br><span class="line">A(<span class="number">0</span>, <span class="number">1</span>) = src.b.x; A(<span class="number">1</span>, <span class="number">1</span>) = src.b.y;</span><br><span class="line">A(<span class="number">0</span>, <span class="number">2</span>) = src.c.x; A(<span class="number">1</span>, <span class="number">2</span>) = src.c.y;</span><br><span class="line">y1(<span class="number">0</span>, <span class="number">0</span>) = dst.a.x; y2(<span class="number">0</span>, <span class="number">0</span>) = dst.a.y;</span><br><span class="line">y1(<span class="number">0</span>, <span class="number">1</span>) = dst.b.x; y2(<span class="number">0</span>, <span class="number">1</span>) = dst.b.y;</span><br><span class="line">y1(<span class="number">0</span>, <span class="number">2</span>) = dst.c.x; y2(<span class="number">0</span>, <span class="number">2</span>) = dst.c.y;</span><br><span class="line">c1 = y1.solve(A);</span><br><span class="line">c2 = y2.solve(A);</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; transform(<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k) &#123;</span><br><span class="line">transform(k, <span class="number">0</span>) = c1(<span class="number">0</span>, k);</span><br><span class="line">transform(k, <span class="number">1</span>) = c2(<span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br><span class="line">transform(<span class="number">2</span>, <span class="number">2</span>) = <span class="number">1</span>;</span><br><span class="line">temp.push_back(transform);</span><br><span class="line">&#125;</span><br><span class="line">source_matrix.push_back(temp);</span><br><span class="line"><span class="comment">//temp.clear();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取每一帧图与目标图网格的变换矩阵</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; frame; ++i) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;CImg&lt;<span class="keyword">float</span>&gt;&gt; temp;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; triangle_grid.size(); ++j) &#123;</span><br><span class="line">triangle src = mid_triangle[i][j];</span><br><span class="line">triangle dst = target_triangle[j];</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; A(<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; y1(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), y2(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; c1(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), c2(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">A(<span class="number">0</span>, <span class="number">0</span>) = src.a.x; A(<span class="number">1</span>, <span class="number">0</span>) = src.a.y;</span><br><span class="line">A(<span class="number">0</span>, <span class="number">1</span>) = src.b.x; A(<span class="number">1</span>, <span class="number">1</span>) = src.b.y;</span><br><span class="line">A(<span class="number">0</span>, <span class="number">2</span>) = src.c.x; A(<span class="number">1</span>, <span class="number">2</span>) = src.c.y;</span><br><span class="line">y1(<span class="number">0</span>, <span class="number">0</span>) = dst.a.x; y2(<span class="number">0</span>, <span class="number">0</span>) = dst.a.y;</span><br><span class="line">y1(<span class="number">0</span>, <span class="number">1</span>) = dst.b.x; y2(<span class="number">0</span>, <span class="number">1</span>) = dst.b.y;</span><br><span class="line">y1(<span class="number">0</span>, <span class="number">2</span>) = dst.c.x; y2(<span class="number">0</span>, <span class="number">2</span>) = dst.c.y;</span><br><span class="line">c1 = y1.solve(A);</span><br><span class="line">c2 = y2.solve(A);</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; transform(<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k) &#123;</span><br><span class="line">transform(k, <span class="number">0</span>) = c1(<span class="number">0</span>, k);</span><br><span class="line">transform(k, <span class="number">1</span>) = c2(<span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br><span class="line">transform(<span class="number">2</span>, <span class="number">2</span>) = <span class="number">1</span>;</span><br><span class="line">temp.push_back(transform);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">target_matrix.push_back(temp);</span><br><span class="line"><span class="comment">//temp.clear();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-中间帧生成"><a href="#2-中间帧生成" class="headerlink" title="2. 中间帧生成"></a>2. 中间帧生成</h4><p><strong>对其中一个三角形对来说,中间帧的生成过程是这样的：</strong></p><p>1) 通过变换矩阵T，求得三角形对的对应像素点坐标。</p><p>2) 定位源三角形内部像素点P0的RGB值，经过线型插值运算：Pinternal=(1-1/n)P0+(1/n)P1（Pinternal是中间帧像素点RGB值，P1是目标像素点RGB值，n为变形动画的帧数）获得中间帧中点Pinternal的RGB值。</p><p>通过以上方法，求得其余三角形的中间帧点Pinternal的RGB值，并将他们写入中间帧缓存中，最终生成中间帧图像。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对图片进行变换处理</span></span><br><span class="line"><span class="keyword">void</span> ImageMorphing::Morphing_process() &#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">result.push_back(source);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; frame; ++i) &#123;</span><br><span class="line"><span class="keyword">float</span> k = <span class="keyword">float</span>(i + <span class="number">1</span>) / (frame + <span class="number">1</span>);</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; middle(target.width(), target.height(), <span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">cimg_forXY(middle, x, y) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; mid_triangle[<span class="number">0</span>].size(); ++j) &#123;</span><br><span class="line"><span class="function">point <span class="title">p</span><span class="params">(x, y)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (IsTriangle(p, mid_triangle[i][j])) &#123;</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; x0(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; b1(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), b2(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">x0(<span class="number">0</span>, <span class="number">0</span>) = x;</span><br><span class="line">x0(<span class="number">0</span>, <span class="number">1</span>) = y;</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; A1 = source_matrix[i][j];</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; A2 = target_matrix[i][j];</span><br><span class="line">b1 = A1 * x0;</span><br><span class="line">b2 = A2 * x0;</span><br><span class="line">middle(x, y, <span class="number">0</span>) = (<span class="number">1</span> - k) * source(b1(<span class="number">0</span>, <span class="number">0</span>), b1(<span class="number">0</span>, <span class="number">1</span>), <span class="number">0</span>) + k * target(b2(<span class="number">0</span>, <span class="number">0</span>), b2(<span class="number">0</span>, <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">middle(x, y, <span class="number">1</span>) = (<span class="number">1</span> - k) * source(b1(<span class="number">0</span>, <span class="number">0</span>), b1(<span class="number">0</span>, <span class="number">1</span>), <span class="number">1</span>) + k * target(b2(<span class="number">0</span>, <span class="number">0</span>), b2(<span class="number">0</span>, <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">middle(x, y, <span class="number">2</span>) = (<span class="number">1</span> - k) * source(b1(<span class="number">0</span>, <span class="number">0</span>), b1(<span class="number">0</span>, <span class="number">1</span>), <span class="number">2</span>) + k * target(b2(<span class="number">0</span>, <span class="number">0</span>), b2(<span class="number">0</span>, <span class="number">1</span>), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result.push_back(middle);</span><br><span class="line">&#125;</span><br><span class="line">result.push_back(target);</span><br><span class="line"><span class="comment">//保存结果的gif动图</span></span><br><span class="line">result.save_gif_external(<span class="string">"a.gif"</span>);</span><br><span class="line"><span class="comment">//存储每一帧图片</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="built_in">string</span> s = to_string(i + <span class="number">1</span>);</span><br><span class="line">s += <span class="string">".bmp"</span>;</span><br><span class="line">result[i].save_bmp(s.c_str());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断点是否在该三角形网格内</span></span><br><span class="line"><span class="comment">//若点p在ABC组成的三角形内，则p = A +  u * (C – A) + v * (B - A)</span></span><br><span class="line"><span class="comment">//u &gt;= 0  v &gt;= 0 u + v &lt;= 1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsTriangle</span><span class="params">(point p, triangle t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> x0 = t.c.x - t.a.x, y0 = t.c.y - t.a.y;</span><br><span class="line"><span class="keyword">float</span> x1 = t.b.x - t.a.x, y1 = t.b.y - t.a.y;</span><br><span class="line"><span class="keyword">float</span> x2 = p.x - t.a.x, y2 = p.y - t.a.y;</span><br><span class="line"><span class="keyword">float</span> temp = x0 * x0 + y0 * y0, temp1 = x0 * x1 + y0 * y1, temp2 = x0 * x2 + y0 * y2, temp3 = x1 * x1 + y1 * y1, temp4 = x1 * x2 + y1 * y2;</span><br><span class="line"><span class="keyword">float</span> u = <span class="keyword">float</span>(temp3 * temp2 - temp1 * temp4) / (<span class="keyword">float</span>)(temp * temp3 - temp1 * temp1);</span><br><span class="line"><span class="keyword">float</span> v = <span class="keyword">float</span>(temp * temp4 - temp1 * temp2) / (<span class="keyword">float</span>)(temp * temp3 - temp1 * temp1);</span><br><span class="line"><span class="keyword">if</span> (u &gt;= <span class="number">0</span> &amp;&amp; v &gt;= <span class="number">0</span> &amp;&amp; u + v &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-最后封装成一个完整的类"><a href="#3-最后封装成一个完整的类" class="headerlink" title="3.最后封装成一个完整的类"></a>3.最后封装成一个完整的类</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CImg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cimg_library;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> frame 11 <span class="comment">//图片变换的帧数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//像素点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">point(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0) :x(x0), y(y0) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//网格三角</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">triangle</span> &#123;</span></span><br><span class="line">point a, b, c;</span><br><span class="line">triangle(point a0, point b0, point c0) :a(a0), b(b0), c(c0) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageMorphing</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; source; <span class="comment">//源图</span></span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; target; <span class="comment">//目标图</span></span><br><span class="line">CImgList&lt;<span class="keyword">float</span>&gt; result; <span class="comment">//结果图片集</span></span><br><span class="line"><span class="built_in">vector</span>&lt;point&gt; source_point; <span class="comment">//源图网格点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;point&gt; target_point; <span class="comment">//目标图网格点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;triangle&gt; source_triangle; <span class="comment">//源图网格</span></span><br><span class="line"><span class="built_in">vector</span>&lt;triangle&gt; target_triangle; <span class="comment">//目标图网格</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;triangle&gt;&gt; mid_triangle; <span class="comment">//中间帧网格</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; triangle_grid; <span class="comment">//需要参与变换的网格</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;CImg&lt;<span class="keyword">float</span>&gt;&gt;&gt; source_matrix; <span class="comment">//源图到中间帧的变换矩阵</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;CImg&lt;<span class="keyword">float</span>&gt;&gt;&gt; target_matrix; <span class="comment">//目标图到中间帧的变换矩阵</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ImageMorphing();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_middleGrid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AffineTransform</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Morphing_process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果测试："><a href="#结果测试：" class="headerlink" title="结果测试："></a>结果测试：</h3><p>源图和目标图中一共取了83个点，共建立了153个网格：<br><img src="https://img-blog.csdnimg.cn/20181120230152801.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>结果图像的gif：</strong><br><img src="https://img-blog.csdnimg.cn/20181120224637896.gif" alt="在这里插入图片描述"><br><strong>完整代码请参考：</strong><br><a href="https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp5" target="_blank" rel="noopener">https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp5</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目：ImageMorphing&quot;&gt;&lt;a href=&quot;#题目：ImageMorphing&quot; class=&quot;headerlink&quot; title=&quot;题目：ImageMorphing&quot;&gt;&lt;/a&gt;题目：ImageMorphing&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>霍夫变换</title>
    <link href="http://yoursite.com/2019/07/06/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/07/06/霍夫变换/</id>
    <published>2019-07-06T12:12:29.000Z</published>
    <updated>2019-07-06T12:13:10.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><ul><li><strong>直线</strong>：</li></ul><p>一条直线在图像中是一系列离散点的集合，通过一个直线的离散极坐标公式，可以表达出直线的离散点几何等式如下：<br>$$<br>X *cos(theta) + y * sin(theta)  = r<br>$$<br>其中角度theta指r与X轴之间的夹角，r为到直线几何垂直距离。任何在直线上点，x,  y都可以表达，其中 r， theta是常量。我们接下来要绘制每个(r, theta)值根据像素点坐标P(x, y)值，那么图像就从图像笛卡尔坐标系统转换到极坐标霍夫空间系统，这种从点到曲线的变换称为直线的霍夫变换。变换通过量化霍夫参数空间为有限个值间隔等分或者累加格子。当霍夫变换算法开始，每个像素坐标点P(x, y)被转换到(r, theta)的曲线点上面，累加到对应的格子数据点，当一个波峰出现时候，说明有直线存在。</p><ul><li><strong>圆</strong></li></ul><p>同以上一样的原理，我们可以用来检测圆，只是对于圆的参数方程变为如下等式：<br>$$<br>(x –a ) ^2 + (y-b) ^ 2 = r^2<br>$$<br>其中(a, b)为圆的中心点坐标，r圆的半径。这样霍夫的参数空间就变成一个三维参数空间。给定圆半径转为二维霍夫参数空间。</p><h2 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h2><ul><li>实验基于上一次代码的实现，用sobel算子先实现边缘检测，然后再在边缘检测的基础上通过调节高斯滤波的内核size、标准差以及双阈值检测的阈值大小来实现对图像检测的效果。</li><li>效果基本实现，缺点是直线检测中的图片4侧面两条边因为过亮所以干扰比较强，没有实现很好的能直接检测四条边，而是通过检测出的直线后排除较短的两条直线剩下中间的纸张。还有一个问题就是圆检测是做不到智能地检测出图像中圆的数量，而是要一个预估数量值(其实也可以通过设置一个很大的检测值来通过设置投票值的大小实现数量检测，不过算法复杂度要很高)。</li><li>没办法实现用一套边缘检测参数测出所有的图像，干扰程度大的图片需要调参来实现。</li></ul><h3 id="直线："><a href="#直线：" class="headerlink" title="直线："></a>直线：</h3><ul><li><strong>过程中用到的类成员：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">int</span>&gt; HoughImg; <span class="comment">//直线的霍夫空间图像</span></span><br><span class="line"><span class="built_in">vector</span>&lt;lineParameter&gt; HoughLine; <span class="comment">//直线检测得出的直线的参数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;lineParameter&gt; Hough_Line; <span class="comment">//临时存储直线参数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;  <span class="comment">//用于筛选出最长的四条边</span></span><br><span class="line"><span class="built_in">vector</span>&lt;parameter&gt; HoughPoint; <span class="comment">//直线检测的角点</span></span><br></pre></td></tr></table></figure><ul><li><strong>过程中用到的类成员函数：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将直线变换为极坐标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Polar_Line</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//霍夫直线检测</span></span><br><span class="line">CImg&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; LineDetect(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//描绘角点</span></span><br><span class="line">CImg&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; drawPoint();</span><br><span class="line"><span class="comment">//直线检测操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LineDetect_Image</span><span class="params">(<span class="built_in">string</span>, <span class="keyword">int</span>, <span class="keyword">double</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>*<em>将直角坐标转到极坐标并统计“票数”： *</em></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Hough::Polar_Line() &#123;</span><br><span class="line">  CImg&lt;<span class="keyword">int</span>&gt; pic = thres;</span><br><span class="line">  <span class="keyword">int</span> rows = pic.width();</span><br><span class="line">  <span class="keyword">int</span> cols = pic.height();</span><br><span class="line">  <span class="keyword">int</span> maxLength = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(rows, <span class="number">2</span>) + <span class="built_in">pow</span>(cols, <span class="number">2</span>));</span><br><span class="line">  HoughImg.resize(<span class="number">360</span>, maxLength, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  HoughImg.fill(<span class="number">0</span>);</span><br><span class="line">  cimg_forXY(pic, x, y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pic(x,y) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">360</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = (<span class="keyword">int</span>)x * <span class="built_in">cos</span>(M_PI*i / <span class="number">180</span>) + y * <span class="built_in">sin</span>(M_PI*i / <span class="number">180</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; maxLength) &#123;</span><br><span class="line">          HoughImg(i, r)++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>筛选出得票数最高的我们需求数量的直线，并剔除干扰直线：</strong></li></ul><p>(其中的三个参数分别表示要检测出的直线数量（都是4），干扰直线的数量，以及认为是同一条直线需要剔除掉的检测距离)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; Hough::LineDetect(<span class="keyword">int</span> lineNum, <span class="keyword">int</span> linedisturb, <span class="keyword">int</span> distance) &#123;</span><br><span class="line">  <span class="keyword">int</span> linenum = lineNum;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> Num = lineNum;</span><br><span class="line">  CImg&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; pic = thres;</span><br><span class="line">   </span><br><span class="line">  pic.resize(pic.width(),pic.height(),<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;parameter&gt; Lines;</span><br><span class="line">  <span class="built_in">vector</span>&lt;parameter&gt; result;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lineweight;</span><br><span class="line">  cimg_forXY(HoughImg, x, y) &#123;</span><br><span class="line">    parameter a;</span><br><span class="line">    a.x = x;</span><br><span class="line">    a.y = y;</span><br><span class="line">    Lines.push_back(a);</span><br><span class="line">    lineweight.push_back(HoughImg(x, y));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortlineweight = lineweight;</span><br><span class="line">  sort(sortlineweight.begin(), sortlineweight.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">int</span> fnums = lineNum + linedisturb;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fnums; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> weight = sortlineweight[i], index;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = find(lineweight.begin(), lineweight.end(), weight);</span><br><span class="line">    index = iter - lineweight.begin();</span><br><span class="line">    <span class="keyword">int</span> x1 = Lines[index].x, y1 = Lines[index].y;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; x1 &lt;&lt; " " &lt;&lt; y1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x0 = result[k].x;</span><br><span class="line">        <span class="keyword">int</span> y0 = result[k].y;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x1-x0,<span class="number">2</span>)+<span class="built_in">pow</span>(y1-y0,<span class="number">2</span>)) &lt; distance) &#123;</span><br><span class="line">          flag = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">      result.push_back(Lines[index]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      fnums++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> red[] = &#123; <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="comment">//cout &lt;&lt; result.size() &lt;&lt; endl;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a0 = <span class="number">0</span>;</span><br><span class="line">    nums.push_back(a0);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; result[i].x &lt;&lt; " " &lt;&lt; result[i].y &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//此时sin角度值为0，k为无穷，单独讨论</span></span><br><span class="line">    <span class="keyword">if</span> (result[i].x == <span class="number">0</span> || result[i].x == <span class="number">180</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (result[i].x == <span class="number">0</span>) &#123;</span><br><span class="line">        r = result[i].y;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "Line " &lt;&lt; i+1 &lt;&lt; ": x=" &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        r  -= (result[i].y);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "Line " &lt;&lt; i+1 &lt;&lt; ": x=" &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//const int x_min = 0;</span></span><br><span class="line">      <span class="comment">//const int x_max = pic.width() - 1;</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> y_min = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> y_max = pic.height() - <span class="number">1</span>;</span><br><span class="line">      lineParameter temp;</span><br><span class="line">      temp.k = DBL_MAX;</span><br><span class="line">      temp.b = r;</span><br><span class="line">      Hough_Line.push_back(temp);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> yi = y_min; yi &lt; y_max; yi++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thres.atXY(r, yi) != <span class="number">0</span>) &#123;</span><br><span class="line">          nums[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//pic.draw_line(r , y_min, r, y_max, red);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">double</span> theta = <span class="keyword">double</span>(result[i].x)*M_PI/<span class="number">180</span>;</span><br><span class="line">      <span class="keyword">int</span> r = result[i].y;</span><br><span class="line">      <span class="comment">//cout &lt;&lt; "Line " &lt;&lt; i &lt;&lt; "  " &lt;&lt; theta &lt;&lt; "  " &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">      <span class="keyword">double</span> k = (<span class="keyword">double</span>)(-<span class="built_in">cos</span>(theta) / <span class="built_in">sin</span>(theta));</span><br><span class="line">      <span class="keyword">double</span> b = (<span class="keyword">double</span>) r / <span class="built_in">sin</span>(theta);</span><br><span class="line">      lineParameter temp;</span><br><span class="line">      temp.k = k;</span><br><span class="line">      temp.b = b;</span><br><span class="line">      Hough_Line.push_back(temp);</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> x_min = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> x_max = pic.width() - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> y_min = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> y_max = pic.height() - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> x0 = (<span class="keyword">double</span>)(y_min - b) / k;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> x1 = (<span class="keyword">double</span>)(y_max - b) / k;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> y0 = x_min * k + b;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> y1 = x_max * k + b;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">abs</span>(k) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> yi = y1; yi &lt; y_max; yi++) &#123;</span><br><span class="line">          <span class="keyword">int</span> xi = (<span class="keyword">double</span>)(yi - b) / k;</span><br><span class="line">          <span class="keyword">if</span> (thres.atXY(xi,yi) != <span class="number">0</span> || thres.atXY(xi+<span class="number">1</span>,yi) != <span class="number">0</span> || thres.atXY(xi,yi+<span class="number">1</span>) != <span class="number">0</span> || thres.atXY(xi+<span class="number">1</span>,yi+<span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            nums[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pic.draw_line(x0, y_min, x1, y_max, red);</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> xi = x_min; xi &lt; x_max; xi++) &#123;</span><br><span class="line">          <span class="keyword">int</span> yi = k*xi + b;</span><br><span class="line">          <span class="keyword">if</span> (thres.atXY(xi,yi) != <span class="number">0</span> || thres.atXY(xi+<span class="number">1</span>,yi) != <span class="number">0</span> || thres.atXY(xi,yi+<span class="number">1</span>) != <span class="number">0</span> || thres.atXY(xi+<span class="number">1</span>,yi+<span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            nums[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pic.draw_line(x_min, y0, x_max, y1, red);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; nums[i] &lt;&lt; endl;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortnums = nums;</span><br><span class="line">  sort(sortnums.begin(), sortnums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineNum; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> weight1 = sortnums[i], index1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter1 = find(nums.begin(), nums.end(), weight1);</span><br><span class="line">    index1 = iter1 - nums.begin();</span><br><span class="line">    HoughLine.push_back(Hough_Line[index1]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; HoughLine.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x_min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x_max = pic.width() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> y_min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> y_max = pic.height() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> b = HoughLine[i].b;</span><br><span class="line">    <span class="keyword">if</span> (HoughLine[i].k &lt; DBL_MAX) &#123;</span><br><span class="line">      <span class="keyword">double</span> k = HoughLine[i].k;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> x0 = (<span class="keyword">double</span>)(y_min - b) / k;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> x1 = (<span class="keyword">double</span>)(y_max - b) / k;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> y0 = x_min * k + b;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> y1 = x_max * k + b;</span><br><span class="line">      <span class="keyword">if</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line "</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">": y="</span> &lt;&lt; k &lt;&lt; <span class="string">"*x+"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line "</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">": y="</span> &lt;&lt; k &lt;&lt; <span class="string">"*x"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line "</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">": y="</span> &lt;&lt; k &lt;&lt; <span class="string">"*x"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">abs</span>(k) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        pic.draw_line(x0, y_min, x1, y_max, red);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        pic.draw_line(x_min, y0, x_max, y1, red);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Line "</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">": x="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      pic.draw_line(b , y_min, b, y_max, red);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//pic.display();</span></span><br><span class="line">  sort(HoughLine.begin(), HoughLine.end());</span><br><span class="line">  <span class="comment">//得出四个角点的坐标</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineNum; i++) &#123;</span><br><span class="line">      <span class="keyword">double</span> k0 = HoughLine[i].k;</span><br><span class="line">      <span class="keyword">double</span> b0 = HoughLine[i].b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; lineNum; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (HoughLine[j].k &lt; DBL_MAX) &#123;</span><br><span class="line">        x =  (<span class="keyword">double</span>)(HoughLine[j].b - b0) / (<span class="keyword">double</span>)(k0 - HoughLine[j].k);</span><br><span class="line">        y =  (<span class="keyword">double</span>)(k0*HoughLine[j].b - HoughLine[j].k*b0) / (<span class="keyword">double</span>)(k0 - HoughLine[j].k);</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//K无穷大时的取值</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        x = HoughLine[j].b;</span><br><span class="line">        y = k0*x+b0;</span><br><span class="line">      &#125;</span><br><span class="line">      parameter p;</span><br><span class="line">      p.x = x; p.y = y;</span><br><span class="line">      <span class="keyword">if</span> (p.x &gt; <span class="number">0</span> &amp;&amp; p.x &lt; img.width() &amp;&amp; p.y &gt; <span class="number">0</span> &amp;&amp; p.y &lt; img.height()) &#123;</span><br><span class="line">          <span class="keyword">bool</span> flag1 = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; HoughPoint.size();k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.x == HoughPoint[k].x &amp;&amp; p.y == HoughPoint[k].y) &#123;</span><br><span class="line">              flag1 = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (flag1) &#123;</span><br><span class="line">            HoughPoint.push_back(p);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>*<em>绘制直线相交的角点： *</em></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; Hough::drawPoint() &#123;</span><br><span class="line">  <span class="comment">/*for (int i = 0; i &lt; HoughLine.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; HoughLine[i].k &lt;&lt; " " &lt;&lt; HoughLine[i].b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> blue[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span> &#125;;</span><br><span class="line">  CImg&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; pic = img;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; HoughPoint.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; HoughPoint[i].x &lt;&lt; <span class="string">" "</span> &lt;&lt; HoughPoint[i].y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    pic.draw_circle(HoughPoint[i].x, HoughPoint[i].y, <span class="number">50</span>, blue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>*<em>整合到一起： *</em></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Hough::LineDetect_Image(<span class="built_in">string</span> name, <span class="keyword">int</span> scale, <span class="keyword">double</span> sigma, <span class="keyword">int</span> thresh_low, <span class="keyword">int</span> thresh_high, <span class="keyword">int</span> lineNum, <span class="keyword">int</span> linedisturb, <span class="keyword">int</span> distance) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *names = name.c_str();</span><br><span class="line">  img.load_bmp(names);</span><br><span class="line">  toGrayScale();</span><br><span class="line">  useFilter(scale, sigma);</span><br><span class="line">  sobel();</span><br><span class="line">  nonMaxSupp();</span><br><span class="line">  threshold(thresh_low, thresh_high);</span><br><span class="line">  Polar_Line();</span><br><span class="line">  CImg&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; pic = LineDetect(lineNum, linedisturb, distance);</span><br><span class="line">  CImg&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; pic1 = drawPoint();</span><br><span class="line">  <span class="built_in">string</span> path = <span class="string">"result1/"</span> + name.substr(<span class="number">9</span>,<span class="number">1</span>) + <span class="string">"_a.bmp"</span>;</span><br><span class="line">  <span class="built_in">string</span> path1 = <span class="string">"result1/"</span> + name.substr(<span class="number">9</span>,<span class="number">1</span>) + <span class="string">"_b.bmp"</span>;</span><br><span class="line">  pic.save(path.c_str());</span><br><span class="line">  pic1.save(path1.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检测效果："><a href="#检测效果：" class="headerlink" title="检测效果："></a>检测效果：</h3><p><img src="https://img-blog.csdnimg.cn/20181030180017544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2018103018025198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181030180326928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="圆："><a href="#圆：" class="headerlink" title="圆："></a>圆：</h2><p><strong>用到的类成员：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; HoughImg_Circle; <span class="comment">//霍夫空间圆图像</span></span><br><span class="line">CImg&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; CircleImg; <span class="comment">//在霍夫圆图像上生成的像素点</span></span><br><span class="line">CImg&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; thres_img; <span class="comment">//边缘检测图像的圆检测图</span></span><br></pre></td></tr></table></figure><p><strong>用到的类成员函数：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//霍夫圆检测</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleDetect</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//查找圆对应的像素点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findpixelCircle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//圆检测操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleDetect_Image</span><span class="params">(<span class="built_in">string</span>, <span class="keyword">int</span>, <span class="keyword">double</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>将半径分梯度映射到极坐标并投票筛选出图中存在的半径值并进一步以该值映射到极坐标确定圆心：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Hough::CircleDetect(<span class="keyword">int</span> Nums, <span class="keyword">int</span> min_r, <span class="keyword">int</span> max_r) &#123;</span><br><span class="line">  thres_img = thres;</span><br><span class="line">  thres_img.resize(thres.width(), thres.height(), <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="comment">//thres_img.display();</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortCircleWeight;</span><br><span class="line">  <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; Circle;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Circleweight;</span><br><span class="line">  <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; center;</span><br><span class="line">  <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> width = thres_img.width();</span><br><span class="line">  <span class="keyword">int</span> height = thres_img.height();</span><br><span class="line">  CImg&lt;<span class="keyword">int</span>&gt; pic = thres;</span><br><span class="line">  <span class="comment">//pic.display();</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; vote;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = min_r; r &lt; max_r; r+=<span class="number">5</span>) &#123;</span><br><span class="line">    HoughImg_Circle.resize(width, height, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    HoughImg_Circle.fill(<span class="number">0</span>);</span><br><span class="line">    max = <span class="number">0</span>;</span><br><span class="line">    cimg_forXY(pic,x,y) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pic(x,y) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">360</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">int</span> x0 = x - r*<span class="built_in">cos</span>(i*M_PI/<span class="number">180</span>);</span><br><span class="line">          <span class="keyword">int</span> y0 = y - r*<span class="built_in">sin</span>(i*M_PI/<span class="number">180</span>);</span><br><span class="line">          <span class="keyword">if</span> (x0 &gt; <span class="number">0</span> &amp;&amp; x0 &lt; width &amp;&amp; y0 &gt; <span class="number">0</span> &amp;&amp; y0 &lt; height)</span><br><span class="line">            HoughImg_Circle(x0,y0)++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cimg_forXY(HoughImg_Circle,x,y) &#123;</span><br><span class="line">      <span class="keyword">if</span> (HoughImg_Circle(x,y) &gt; max) &#123;</span><br><span class="line">        max = HoughImg_Circle(x,y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vote.push_back(make_pair(max, r));</span><br><span class="line">  &#125;</span><br><span class="line">  sort(vote.begin(), vote.end(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; x, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> x.first &gt; y.first; &#125;);</span><br><span class="line">  <span class="comment">//int Nums = 1;</span></span><br><span class="line">  <span class="keyword">int</span> knums = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt; Nums; num++) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    HoughImg_Circle.resize(width, height, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    HoughImg_Circle.fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> r = vote[num].second;</span><br><span class="line">    cimg_forXY(pic,x,y) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pic(x,y) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">360</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">int</span> x0 = x - r*<span class="built_in">cos</span>(i*M_PI/<span class="number">180</span>);</span><br><span class="line">          <span class="keyword">int</span> y0 = y - r*<span class="built_in">sin</span>(i*M_PI/<span class="number">180</span>);</span><br><span class="line">          <span class="keyword">if</span> (x0 &gt; <span class="number">0</span> &amp;&amp; x0 &lt; width &amp;&amp; y0 &gt; <span class="number">0</span> &amp;&amp; y0 &lt; height)</span><br><span class="line">            HoughImg_Circle(x0,y0)++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Circle.clear();</span><br><span class="line">    Circleweight.clear();</span><br><span class="line">    cimg_forXY(HoughImg_Circle,x,y) &#123;</span><br><span class="line">      <span class="keyword">if</span> (HoughImg_Circle(x,y) != <span class="number">0</span>) &#123;</span><br><span class="line">        Circle.push_back(make_pair(x,y));</span><br><span class="line">        Circleweight.push_back(HoughImg_Circle(x,y));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> blue[<span class="number">3</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span> &#125;;</span><br><span class="line">    sortCircleWeight = Circleweight;</span><br><span class="line">    sort(sortCircleWeight.begin(), sortCircleWeight.end(), greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 将累加矩阵从大到小进行排序</span></span><br><span class="line">    <span class="comment">//同个半径圆的检测</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> weight = sortCircleWeight[count], index;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = find(Circleweight.begin(), Circleweight.end(), weight);</span><br><span class="line">        index = iter - Circleweight.begin();</span><br><span class="line">        <span class="keyword">int</span> a = Circle[index].first, b = Circle[index].second;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ii;</span><br><span class="line">        <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; center.size(); ii++) &#123;</span><br><span class="line">          <span class="comment">// 判断检测出来的圆心坐标是否跟已检测的圆心坐标的距离，如果距离过小，默认是同个圆</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sqrt</span>(<span class="built_in">pow</span>((center[ii].first - a), <span class="number">2</span>) + <span class="built_in">pow</span>((center[ii].second - b), <span class="number">2</span>)) &lt; minRadius) &#123;</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ii == center.size()) &#123;</span><br><span class="line">            center.push_back(make_pair(a, b));</span><br><span class="line">            thres_img.draw_circle(a, b, r, blue, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            knums++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"the number of the coins is: "</span> &lt;&lt; knums &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>寻找检测出的圆在原图中对应的像素点：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Hough::findpixelCircle() &#123;</span><br><span class="line">  CircleImg = img;</span><br><span class="line">  CircleImg.resize(thres.width(), thres.height());</span><br><span class="line">  cimg_forXY(CircleImg, x, y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (thres_img(x,y,<span class="number">0</span>) == <span class="number">0</span> &amp;&amp; thres_img(x,y,<span class="number">1</span>) == <span class="number">0</span> &amp;&amp; thres_img(x,y,<span class="number">2</span>) == <span class="number">255</span> &amp;&amp; thres(x,y) == <span class="number">0</span>) &#123;</span><br><span class="line">      CircleImg(x,y,<span class="number">0</span>) = <span class="number">255</span>;</span><br><span class="line">      CircleImg(x,y,<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">      CircleImg(x,y,<span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//CircleImg.display();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>整合到一起：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Hough::CircleDetect_Image(<span class="built_in">string</span> name, <span class="keyword">int</span> scale, <span class="keyword">double</span> sigma, <span class="keyword">int</span> thresh_low, <span class="keyword">int</span> thresh_high, <span class="keyword">int</span> Nums, <span class="keyword">int</span> min_r, <span class="keyword">int</span> max_r) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *names = name.c_str();</span><br><span class="line">  img.load_bmp(names);</span><br><span class="line">  toGrayScale();</span><br><span class="line">  useFilter(scale, sigma);</span><br><span class="line">  sobel();</span><br><span class="line">  nonMaxSupp();</span><br><span class="line">  threshold(thresh_low, thresh_high);</span><br><span class="line">  CircleDetect(Nums, min_r, max_r);</span><br><span class="line">  findpixelCircle();</span><br><span class="line">  <span class="built_in">string</span> path = <span class="string">"result2/"</span> + name.substr(<span class="number">9</span>,<span class="number">1</span>) + <span class="string">"_a.bmp"</span>;</span><br><span class="line">  <span class="built_in">string</span> path1 = <span class="string">"result2/"</span> + name.substr(<span class="number">9</span>,<span class="number">1</span>) + <span class="string">"_b.bmp"</span>;</span><br><span class="line">  thres_img.save(path.c_str());</span><br><span class="line">  CircleImg.save(path1.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检测效果：-1"><a href="#检测效果：-1" class="headerlink" title="检测效果："></a>检测效果：</h3><p><img src="https://img-blog.csdnimg.cn/20181030180456648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20181030180514774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181030180547421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>完整代码参见</strong><br><a href="https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp3" target="_blank" rel="noopener">https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;原理：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;直线&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一条直线在图像中是一系列离散点的集合，通过一个直线
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>PoW共识机制</title>
    <link href="http://yoursite.com/2019/07/06/PoW%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/07/06/PoW共识机制/</id>
    <published>2019-07-06T12:09:27.000Z</published>
    <updated>2019-07-06T12:10:24.980Z</updated>
    
    <content type="html"><![CDATA[<p>注：本文章通过阅读讨论工作量共识在垃圾邮件的使用的 Proof-of-Work-Proves-Not-to-Work-version-0.2 文章以及博客知乎上关于 PoW 机制的讨论完成。 </p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>首先 PoW 是一种共识机制，处于区块链架构的共识层中。上次作业的学习中有了解到区块链的核心优势之一就是能够在决策权高度分散的去中心化系统中使得各节点高效地针对区块数据的有效性达成共识。而要达成共识就要采用我们通常所说的共识机制，其中 PoW 就是一种最常见的共识机制（比特币中的挖矿）。在比特币挖矿中各节点贡献自己的计算资源来竞争解决一个难度可动态调整的数学问题, 成功解决该数学问题的矿工将获得区块的记账权, 并将当前时间段的所有比特币交易打包记入一个新的区块、按照时间顺序链接到比特币主链上. 比特币系统同时会发行一定数量的比特币以奖励该矿工, 并激励其他矿工继续贡献算力。 </p><p>所以其核心思想是通过引入分布式节点的算力竞争来保证数据一致性和共识的安全性。比特币系统中, 各节点 (即矿工) 基于各自的计算机算力相互竞争来共同解决一个求解复杂但验证容易的 SHA256 数学难题 (即挖矿), 最快解决该难题的节点将获得区块记账权和系统自动生成的比特币奖励. 该数学难题可表述为: 根据当前难度值, 通过搜索求解一个合适的随机数 (Nonce) 使得区块各元数据的双 SHA256 哈希值小于或等于目标哈希值。一般说来, PoW 共识在区块链系统中实现过程如下： </p><ul><li>先定义一个固定的 256 位长度初始数，比如：长度为 256 位字符 0000…0001 （32 字节，64 字符） </li><li>设置难度系数值，比如：如果难度系数定义为前面 4 个 0，即 16 位长度（0000 0000 0000 0001 = 4 个字符 = 2 个字节）。 </li><li>按照难度系数值进行移位操作，将 Hash 工作量值扩大，向左移（256-难度系数 N 位）比如：将初始数 0000…..0001 向左移（256-16 位）得到：0000 0000 0000 0001 0000 …0000。 </li><li>将随机数 Nonce 递增加 1 再加上区块头（Block Header）Hash 值拼接，然后进行 SHA256 Hash 运算。 </li><li>将计算结果值与当前难度系数目标值作对比，如果当前计算值大于难度系数条件 值，即继续递增 Nonce 值再进行下一次的 SHA256 Hash 运算，直到计算出的结果 Hash 值少于目标值，则才认为解题成功，此次的工作量证明完成并获得记账权，然后进行对 交易区块进行打包确认并广播给全节点，并从 Coinbase 中获得 gas 奖励。 </li></ul><p><strong>Ps:</strong> 如果要求 Hash 值前面的 N 位 0 越大，即它的计算难度就越大，每增加一位 0，它 的计算次数就变得高出很多倍，当要求计算难度值前 N 位要求为 7 位是 0 的时候，它 的计算次数就达到 5.6 亿次，所以工作量非常大，如果作弊那是几乎不可能。 </p><h2 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h2><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>1）算法简洁，很容易实现。<br>2）答案唯一且容易验证，节点间无需交换额外信息，容易达成共识。<br>3）公平性好，将记账权公平的分派到其他节点。矿工能够获得的币的数量，取决于挖矿贡献的有效工作。<br>4）安全性高，破坏系统需要投入极大的成本，如果想作弊，要有压倒大多数人的算力（51%攻击）。因为作弊要付出一定成本，作弊者就会谨慎对待了。在比特币 PoW 机制中，由于获得计算结果的概率趋近于所占算力比例，因此在不掌握51%以上算力的前提下，矿工欺诈的成本要显著高于诚实挖矿，甚至不可能完成欺诈(由于概率过低)。 </p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>1）挖矿造成大量的资源浪费，目前 bitcoin 已经吸引全球大部分的算力，其它再用 Pow 共识机制的区块链应用很难获得相同的算力来保障自身的安全。这让依据算力公平分配奖励的机制，演变为了对矿机算力的大举投入。<br>2）网络性能太低，需要等待多个确认，容易产生分叉，区块的确认共识达成的周期较长（10 分钟），现在每秒交易量上限是 7 笔（ visa 的平均每秒交易量上万，支付宝峰值接近 9 万），不适合商业应用。<br>3）PoW 共识算法算力过于集中化，慢慢的偏离了原来的去中心化轨道。从比特币扩容之争可以看到，算力高的大型矿池是主人，而持币的人没有参与决定的权利，比特币分叉出很多子叉，即将失去“去中心化”的标签。 </p><h2 id="对存在的问题的解决："><a href="#对存在的问题的解决：" class="headerlink" title="对存在的问题的解决："></a>对存在的问题的解决：</h2><p>由于 PoW 存在着很多需要改进的缺点，感觉很重要一点就是资源消耗量过大。于是针对此问题提出 PoS 共识， PoS 共识本质上是采用权益证明来代替 PoW 中的基于哈希算力的工作量证明, 是由系统中具有最高权益而非最高算力的节点获得区块记账权. 权益体现为节点对特定数量货币的所有权, 也就是币龄. 币龄是特定数量的币与其最后一次交易的时间长度的乘积, 每次交易都将会消耗掉特定数量的币龄。采用 PoS 共识机制的系统在特定时间点上的币龄总数是有限的, 长期持币者更倾向于拥有更多币龄, 因此币龄可视为其 PoS 系统中的权益. 此外, PoW 共识过程中各节点挖矿难度相同, 而 PoS 共识过程中的难度与交易输入的币龄成反比, 消耗币龄越多则挖矿难度越低. 节点判断主链的标准也由 PoW 共识的最高累计难度转变为最高消耗币龄, 每个区块的交易都会将其消耗的币龄提交给该区块, 累计消耗币龄最高的区块将被链接到主链. 由此可见, PoS 共识过程仅依靠内部币龄和权益而不需要消耗外部算力和资源, 从根本上解决了 PoW 共识算力浪费的问题, 并且能够在一定程度上缩短达成共识的时间, 因而比特币之后的许多竞争币均采用 PoS 共识机制。 </p><p>以上摘抄自区块链论文中 PoS 的介绍，从中可以看出采用 PoW 机制的数字货币不是理想状态的数字货币，因为它们的安全性不直接与使用者相关，而是要通过矿工这个媒介。在这种情况下，PoW 机制对于 51%攻击有潜在隐患，攻击者并不需要拥有比特币，如果要做 51%攻击，所需要的花费跟挖矿难度相关而不是直接跟比特币价格相关。而在 PoS 机制下，进行 51%攻击的代价更高，因为想要进行51%攻击的话，你得拥有 51%的货币——这东西越值钱，攻击的成本就越高。但这也就意味着存在另一个问题，也就是常说的无利益攻击问题：<strong>对于 PoS 共识机制的货币，你越有钱，作恶付出的代价就越大；然而对于没有钱的人，作恶代价很小，所以一些作恶行为对他们而言是有益的。</strong> </p><p>针对以上问题又出现了 Casper Pos 共识，Casper PoS 是一种基于保证金的经济激励共识协议。协议中的节点，作为“锁定保证金的验证人”，必须先缴纳保证金(这一步叫做锁定保证金)才可以参与出块和共识形成。Casper 共识协议通过对这些保证金的直接控制来约束验证人的行为。具体来说就是，如果一个验证人作出了任何 Casper 认为“非法”的事情，他的保证金将被罚没，出块和参与共识的权利也会被取消。保证金的引入解决了无利益攻击。也就是经典 PoS 协议中做坏事的代价很低的问题，现在有了代价，而且被客观证明做错事的验证人将会付出这个代价。 </p><p>针对背离去中心化思想的解决方案，以太坊选用的 PoW 算法是线性内存困难的。该算法被设计成算出一个 nonce 值需要大量的内存和带宽。即使是超高速计算机，也无法在需要大量的内存和带宽的条件下同时计算出多个 nonce 值。这减少了中心化的风险，为节点创建一个公平竞争的环境。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注：本文章通过阅读讨论工作量共识在垃圾邮件的使用的 Proof-of-Work-Proves-Not-to-Work-version-0.2 文章以及博客知乎上关于 PoW 机制的讨论完成。 &lt;/p&gt;
&lt;h2 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;h
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Canny算子实现边缘分割并做连线处理</title>
    <link href="http://yoursite.com/2019/07/06/Canny%E7%AE%97%E5%AD%90%E5%AE%9E%E7%8E%B0%E8%BE%B9%E7%BC%98%E5%88%86%E5%89%B2%E5%B9%B6%E5%81%9A%E8%BF%9E%E7%BA%BF%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/07/06/Canny算子实现边缘分割并做连线处理/</id>
    <published>2019-07-05T16:37:29.000Z</published>
    <updated>2019-07-05T16:38:07.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ex2：用-CImg-重写、封装给定的-Canny-代码，并测试"><a href="#Ex2：用-CImg-重写、封装给定的-Canny-代码，并测试" class="headerlink" title="Ex2：用 CImg 重写、封装给定的 Canny 代码，并测试"></a>Ex2：用 CImg 重写、封装给定的 Canny 代码，并测试</h2><h3 id="C-封装要求："><a href="#C-封装要求：" class="headerlink" title="C++封装要求："></a><strong>C++封装要求：</strong></h3><p>(1)所有的图像读写、数据处理只能用 CImg 库(整个工程文件不允许<br>使用 Opencv 之类的第三方库)； (2)代码封装要求函数接口简洁清晰，可参考<br>Code2 的方式封装。<br>在原来的代码基础上, 增加一个函数：首先把相邻的边缘连成长的线条，并删除<br>长度小于 20 的 Edge。<br>对算法的若干组参数，对所有测试图像进行测试，并分析各参数对结果的影响。</p><h3 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a><strong>实现过程：</strong></h3><p><strong>原理：</strong><br>实现 canny 边缘检测的原理通俗来说就是用离散化的梯度逼近函数根据二维灰度矩阵梯度向量来寻找图像灰度矩阵的灰度跃变位置，然后再图像中将这些点连起来就形成了图像的边缘。<br><strong>处理过程：</strong><br>一般对图像进行 canny 边缘检测要经过以下几步： </p><ol><li><p>对图像进行灰度化处理：<br><strong>公式：</strong> Gimg = 0.299R+0.587G+0.114B </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RGBtoGray</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>对图像进行高斯滤波(出去图片中噪声对边缘检测的影响) </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gaussian_smooth</span><span class="params">(<span class="keyword">float</span> sigma)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><p>用到辅助函数：<br><code>void make_gaussian_kernel(float sigma, float **kernel, int *windowsize);</code> </p><ol start="3"><li>用一阶偏导的有限差分来计算梯度的幅值和方向 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算x,y方向的一阶导数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">derrivative_x_y</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ol><p>用到辅助函数：<br><code>double angle_radians(double x, double y);</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算梯度向上的方向，以正x轴为逆时针方向指定的弧度 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radian_direction</span><span class="params">(<span class="keyword">int</span> xdirtag, <span class="keyword">int</span> ydirtag)</span></span>; </span><br><span class="line"><span class="comment">//计算梯度的幅值 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">magnitude_x_y</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>对梯度幅值进行非极大值抑制 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">non_max_supp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>双阈值检测和连接边缘 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply_hysteresis</span><span class="params">(<span class="keyword">float</span> tlow, <span class="keyword">float</span> thigh)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><p>用到辅助函数:<br><code>void follow_edges(int *edgemapptr, int *edgemagptr, int lowval, int cols);</code> </p><ol start="6"><li>之后再对将相邻边缘连成线条： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">int</span>&gt; canny_line(CImg&lt;<span class="keyword">int</span>&gt; picture, <span class="keyword">int</span> distance);</span><br></pre></td></tr></table></figure></li></ol><p>用到辅助函数：<br><code>CImg&lt;int&gt; Draw_line(CImg&lt;int&gt; tmp, int x, int y, int x1, int y1);</code> </p><ol start="7"><li>删除长度小于20的线条： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">int</span>&gt; delete_line(CImg&lt;<span class="keyword">int</span>&gt; picture); CImg&lt;<span class="keyword">int</span>&gt; delete_line(CImg&lt;<span class="keyword">int</span>&gt; picture);</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><strong>代码：</strong></h2><p><strong>Canny.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*实现canny边缘检测的原理通俗来说就是用离散化的梯度逼近函数根据二维灰度矩阵梯度向量来寻找图像灰度矩阵</span></span><br><span class="line"><span class="comment">的灰度跃变位置，然后再图像中将这些点连起来就形成了图像的边缘</span></span><br><span class="line"><span class="comment">一般对图像进行canny边缘检测要经过以下几步：</span></span><br><span class="line"><span class="comment">1.对图像进行灰度化处理：Gimg = 0.299R+0.587G+0.114B</span></span><br><span class="line"><span class="comment">2.对图像进行高斯滤波(出去图片中噪声对边缘检测的影响)</span></span><br><span class="line"><span class="comment">3.用一阶偏导的有限差分来计算梯度的幅值和方向</span></span><br><span class="line"><span class="comment">4.对梯度幅值进行非极大值抑制</span></span><br><span class="line"><span class="comment">5.双阈值检测和连接边缘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CANNY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CANNY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CImg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cimg_library;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Canny</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; img;</span><br><span class="line"><span class="keyword">int</span> rows;</span><br><span class="line"><span class="keyword">int</span> cols;</span><br><span class="line"><span class="keyword">int</span> *smoothedim;</span><br><span class="line"><span class="keyword">int</span> *delta_x;  <span class="comment">//x方向的一阶导数</span></span><br><span class="line"><span class="keyword">int</span> *delta_y;  <span class="comment">//y方向的一阶导数</span></span><br><span class="line"><span class="keyword">float</span> *dirim;  <span class="comment">//梯度的方向</span></span><br><span class="line"><span class="keyword">int</span> *magnitude; <span class="comment">//梯度的幅值</span></span><br><span class="line"><span class="keyword">int</span> *nms;   <span class="comment">//非极大值抑制后得到矩阵</span></span><br><span class="line"><span class="keyword">int</span> *edge;  <span class="comment">//边缘数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Canny();</span><br><span class="line">Canny(<span class="built_in">string</span> name,<span class="built_in">string</span> format);</span><br><span class="line">~Canny();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RGBtoGray</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gaussian_smooth</span><span class="params">(<span class="keyword">float</span> sigma)</span></span>;</span><br><span class="line"><span class="comment">//计算x,y方向的一阶导数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">derrivative_x_y</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//计算梯度向上的方向，以正x轴为逆时针方向指定的弧度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radian_direction</span><span class="params">(<span class="keyword">int</span> xdirtag, <span class="keyword">int</span> ydirtag)</span></span>;</span><br><span class="line"><span class="comment">//计算梯度的幅值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">magnitude_x_y</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//进行非极大值抑制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">non_max_supp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//双阈值检测</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply_hysteresis</span><span class="params">(<span class="keyword">float</span> tlow, <span class="keyword">float</span> thigh)</span></span>;</span><br><span class="line"><span class="comment">//默认参数设置高斯滤波标准差为2.0，低阈值为0.25，高阈值为0.75</span></span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; canny_image();</span><br><span class="line"><span class="comment">//整合所有获取最后的边缘图,sigma表示高斯滤波的参数，tlow和thigh为两个阈值</span></span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; canny_image(<span class="keyword">int</span> sigma, <span class="keyword">float</span> tlow, <span class="keyword">float</span> thigh);</span><br><span class="line"><span class="comment">//选出两个边缘点较近的距离连线</span></span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; canny_line(CImg&lt;<span class="keyword">int</span>&gt; picture, <span class="keyword">int</span> distance);</span><br><span class="line"><span class="comment">//删掉长度小于20的边缘线</span></span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; delete_line(CImg&lt;<span class="keyword">int</span>&gt; picture);</span><br><span class="line"><span class="comment">//显示图像</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//编写类过程的测试，无实际用处</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>Canny.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Canny.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CImg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PI 3.14159265358979323846</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOSTBLURFACTOR 90.0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOEDGE 255</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POSSIBLE_EDGE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDGE 0</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cimg_library;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_gaussian_kernel</span><span class="params">(<span class="keyword">float</span> sigma, <span class="keyword">float</span> **kernel, <span class="keyword">int</span> *windowsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">angle_radians</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">follow_edges</span><span class="params">(<span class="keyword">int</span> *edgemapptr, <span class="keyword">int</span> *edgemagptr, <span class="keyword">int</span> lowval, <span class="keyword">int</span> cols)</span></span>;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; Draw_line(CImg&lt;<span class="keyword">int</span>&gt; tmp, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1);</span><br><span class="line"></span><br><span class="line">Canny::Canny() &#123;</span><br><span class="line">rows = <span class="number">0</span>;</span><br><span class="line">cols = <span class="number">0</span>;</span><br><span class="line">smoothedim = <span class="literal">NULL</span>;</span><br><span class="line">delta_x = <span class="literal">NULL</span>;  <span class="comment">//x方向的一阶导数</span></span><br><span class="line">delta_y = <span class="literal">NULL</span>;  <span class="comment">//y方向的一阶导数</span></span><br><span class="line">dirim = <span class="literal">NULL</span>;  <span class="comment">//梯度的方向</span></span><br><span class="line">magnitude = <span class="literal">NULL</span>; <span class="comment">//梯度的幅值</span></span><br><span class="line">nms = <span class="literal">NULL</span>;   <span class="comment">//非极大值抑制后得到矩阵</span></span><br><span class="line">edge = <span class="literal">NULL</span>; <span class="comment">//边缘数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Canny::Canny(<span class="built_in">string</span> name, <span class="built_in">string</span> format) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *a = name.c_str();</span><br><span class="line"><span class="built_in">string</span> jpg = <span class="string">"jpg"</span>;</span><br><span class="line"><span class="built_in">string</span> png = <span class="string">"png"</span>;</span><br><span class="line"><span class="built_in">string</span> tiff = <span class="string">"tiff"</span>;</span><br><span class="line"><span class="built_in">string</span> bmp = <span class="string">"bmp"</span>;</span><br><span class="line"><span class="keyword">if</span> (format.compare(jpg) == <span class="number">0</span>)</span><br><span class="line">img.load_jpeg(a);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (format.compare(png) == <span class="number">0</span>)</span><br><span class="line">img.load_png(a);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (format.compare(tiff) == <span class="number">0</span>)</span><br><span class="line">img.load_tiff(a);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (format.compare(bmp) == <span class="number">0</span>)</span><br><span class="line">img.load_bmp(a);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//img.load_jpeg("lena.jpg");</span></span><br><span class="line">rows = img.width();</span><br><span class="line">cols = img.height();</span><br><span class="line">delta_x = <span class="keyword">new</span> <span class="keyword">int</span>[rows*cols]; <span class="built_in">memset</span>(delta_x, <span class="number">0x0</span>, rows*cols*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">delta_y = <span class="keyword">new</span> <span class="keyword">int</span>[rows*cols]; <span class="built_in">memset</span>(delta_y, <span class="number">0x0</span>, rows*cols * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">dirim = <span class="keyword">new</span> <span class="keyword">float</span>[rows*cols]; <span class="built_in">memset</span>(dirim, <span class="number">0x0</span>, rows*cols * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">magnitude = <span class="keyword">new</span> <span class="keyword">int</span>[rows*cols]; <span class="built_in">memset</span>(magnitude, <span class="number">0x0</span>, rows*cols * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">nms = <span class="keyword">new</span> <span class="keyword">int</span>[rows*cols]; <span class="built_in">memset</span>(nms, <span class="number">0x0</span>, rows*cols * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">edge = <span class="keyword">new</span> <span class="keyword">int</span>[rows*cols]; <span class="built_in">memset</span>(edge, <span class="number">0x0</span>, rows*cols * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">smoothedim = <span class="keyword">new</span> <span class="keyword">int</span>[rows*cols];  <span class="built_in">memset</span>(smoothedim, <span class="number">0x0</span>, rows*cols * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Canny::~Canny() &#123;</span><br><span class="line"><span class="keyword">delete</span>[] delta_x;</span><br><span class="line"><span class="keyword">delete</span>[] delta_y;</span><br><span class="line"><span class="keyword">delete</span>[] dirim;</span><br><span class="line"><span class="keyword">delete</span>[] magnitude;</span><br><span class="line"><span class="keyword">delete</span>[] nms;</span><br><span class="line"><span class="keyword">delete</span>[] edge;</span><br><span class="line"><span class="keyword">delete</span>[] smoothedim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Canny::display() &#123;</span><br><span class="line">img.display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Canny::RGBtoGray() &#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>, g = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">cimg_forXY(img, x, y) &#123;</span><br><span class="line">r = img(x, y, <span class="number">0</span>);</span><br><span class="line">g = img(x, y, <span class="number">1</span>);</span><br><span class="line">b = img(x, y, <span class="number">2</span>);</span><br><span class="line">img(x, y, <span class="number">0</span>) = img(x, y, <span class="number">1</span>) = img(x, y, <span class="number">2</span>) = (r*<span class="number">0.2126</span> + g * <span class="number">0.7152</span> + b * <span class="number">0.0722</span>);</span><br><span class="line">&#125;</span><br><span class="line">img.resize(rows, cols, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Canny::gaussian_smooth(<span class="keyword">float</span> sigma)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> *tempim = <span class="keyword">new</span> <span class="keyword">int</span>[rows*cols];</span><br><span class="line"><span class="keyword">int</span> r, c,rr,cc,</span><br><span class="line">windowsize,  <span class="comment">//高斯核维度</span></span><br><span class="line">center;      <span class="comment">//核中心</span></span><br><span class="line"><span class="keyword">float</span> *kernel,</span><br><span class="line">dot,</span><br><span class="line">sum;</span><br><span class="line">make_gaussian_kernel(sigma, &amp;kernel, &amp;windowsize);</span><br><span class="line">center = windowsize / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">dot = <span class="number">0.0</span>;</span><br><span class="line">sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (cc = (-center); cc &lt;= center; cc++) &#123;</span><br><span class="line"><span class="keyword">if</span> (((c + cc) &gt;= <span class="number">0</span>) &amp;&amp; ((c + cc) &lt; cols)) &#123;</span><br><span class="line">dot += (<span class="keyword">float</span>)img(r,c+cc) * kernel[center + cc];</span><br><span class="line">sum += kernel[center + cc];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tempim[r*cols + c] = dot / sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line">sum = <span class="number">0.0</span>;</span><br><span class="line">dot = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (rr = (-center); rr &lt;= center; rr++) &#123;</span><br><span class="line"><span class="keyword">if</span> (((r + rr) &gt;= <span class="number">0</span>) &amp;&amp; ((r + rr) &lt; rows)) &#123;</span><br><span class="line">dot += tempim[(r + rr)*cols + c] * kernel[center + rr];</span><br><span class="line">sum += kernel[center + rr];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">smoothedim[r*cols + c] = (<span class="keyword">short</span> <span class="keyword">int</span>)(dot*BOOSTBLURFACTOR / sum + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Canny::derrivative_x_y() &#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//计算x方向的一阶导数，判断边界避免遗失边界像素点</span></span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line">pos = r * cols;</span><br><span class="line">delta_x[pos] = smoothedim[pos + <span class="number">1</span>] - smoothedim[pos];</span><br><span class="line">pos++;</span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">1</span>; c &lt; (cols - <span class="number">1</span>); c++, pos++) &#123;</span><br><span class="line">delta_x[pos] = smoothedim[pos + <span class="number">1</span>] - smoothedim[pos - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">delta_x[pos] = smoothedim[pos] - smoothedim[pos - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算y方向的一阶导数，判断边界避免遗失边界像素点</span></span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">pos = c;</span><br><span class="line">delta_y[pos] = smoothedim[pos + cols] - smoothedim[pos];</span><br><span class="line">pos += cols;</span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">1</span>; r &lt; (rows - <span class="number">1</span>); r++, pos += cols) &#123;</span><br><span class="line">delta_y[pos] = smoothedim[pos + cols] - smoothedim[pos - cols];</span><br><span class="line">&#125;</span><br><span class="line">delta_y[pos] = smoothedim[pos] - smoothedim[pos - cols];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Canny::radian_direction(<span class="keyword">int</span> xdirtag, <span class="keyword">int</span> ydirtag) &#123;</span><br><span class="line"><span class="keyword">double</span> dx = <span class="number">0.0</span>, dy = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">0</span>, pos = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; cols; c++, pos++) &#123;</span><br><span class="line">dx = (<span class="keyword">double</span>)delta_x[pos];</span><br><span class="line">dy = (<span class="keyword">double</span>)delta_y[pos];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (xdirtag == <span class="number">1</span>) dx = -dx;</span><br><span class="line"><span class="keyword">if</span> (ydirtag == <span class="number">-1</span>) dy = -dy;</span><br><span class="line"></span><br><span class="line">dirim[pos] = (<span class="keyword">float</span>)angle_radians(dx, dy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Canny::magnitude_x_y() &#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>, pos = <span class="number">0</span>, sq1 = <span class="number">0</span>, sq2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">0</span>, pos = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; cols; c++, pos++) &#123;</span><br><span class="line">sq1 = (<span class="keyword">int</span>)delta_x[pos] * (<span class="keyword">int</span>)delta_x[pos];</span><br><span class="line">sq2 = (<span class="keyword">int</span>)delta_y[pos] * (<span class="keyword">int</span>)delta_y[pos];</span><br><span class="line">magnitude[pos] = (<span class="keyword">short</span>)(<span class="number">0.5</span> + <span class="built_in">sqrt</span>((<span class="keyword">float</span>)sq1 + (<span class="keyword">float</span>)sq2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Canny::non_max_supp() &#123;</span><br><span class="line"><span class="keyword">int</span> rowcount = <span class="number">0</span>, colcount = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *magrowptr, *magptr;</span><br><span class="line"><span class="keyword">int</span> *gxrowptr, *gxptr;</span><br><span class="line"><span class="keyword">int</span> *gyrowptr, *gyptr, z1 = <span class="number">0</span>, z2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> m00, gx = <span class="number">0</span>, gy = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> mag1 = <span class="number">0.0</span>, mag2 = <span class="number">0.0</span>, xperp = <span class="number">0.0</span>, yperp = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">int</span> *resultrowptr, *resultptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>, resultrowptr = nms, resultptr = nms + cols * (rows - <span class="number">1</span>);</span><br><span class="line">count &lt; cols; resultptr++, resultrowptr++, count++) &#123;</span><br><span class="line">*resultrowptr = *resultptr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>, resultptr = nms, resultrowptr = nms + cols - <span class="number">1</span>;</span><br><span class="line">count &lt; rows; count++, resultptr += cols, resultrowptr += cols) &#123;</span><br><span class="line">*resultptr = *resultrowptr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (rowcount = <span class="number">1</span>, magrowptr = magnitude + cols + <span class="number">1</span>, gxrowptr = delta_x + cols + <span class="number">1</span>,</span><br><span class="line">gyrowptr = delta_y + cols + <span class="number">1</span>, resultrowptr = nms + cols + <span class="number">1</span>;</span><br><span class="line">rowcount &lt; rows - <span class="number">2</span>;</span><br><span class="line">rowcount++, magrowptr += cols, gyrowptr += cols, gxrowptr += cols,</span><br><span class="line">resultrowptr += cols) &#123;</span><br><span class="line"><span class="keyword">for</span> (colcount = <span class="number">1</span>, magptr = magrowptr, gxptr = gxrowptr, gyptr = gyrowptr,</span><br><span class="line">resultptr = resultrowptr; colcount &lt; cols - <span class="number">2</span>;</span><br><span class="line">colcount++, magptr++, gxptr++, gyptr++, resultptr++) &#123;</span><br><span class="line">m00 = *magptr;</span><br><span class="line"><span class="keyword">if</span> (m00 == <span class="number">0</span>) &#123;</span><br><span class="line">*resultptr = NOEDGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">xperp = -(gx = *gxptr) / ((<span class="keyword">float</span>)m00);</span><br><span class="line">yperp = (gy = *gyptr) / ((<span class="keyword">float</span>)m00);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (gx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (gy &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (gx &gt;= gy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 111 */</span></span><br><span class="line"><span class="comment">/* Left point */</span></span><br><span class="line">z1 = *(magptr - <span class="number">1</span>);</span><br><span class="line">z2 = *(magptr - cols - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag1 = (m00 - z1)*xperp + (z2 - z1)*yperp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Right point */</span></span><br><span class="line">z1 = *(magptr + <span class="number">1</span>);</span><br><span class="line">z2 = *(magptr + cols + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag2 = (m00 - z1)*xperp + (z2 - z1)*yperp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 110 */</span></span><br><span class="line"><span class="comment">/* Left point */</span></span><br><span class="line">z1 = *(magptr - cols);</span><br><span class="line">z2 = *(magptr - cols - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag1 = (z1 - z2)*xperp + (z1 - m00)*yperp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Right point */</span></span><br><span class="line">z1 = *(magptr + cols);</span><br><span class="line">z2 = *(magptr + cols + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag2 = (z1 - z2)*xperp + (z1 - m00)*yperp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (gx &gt;= -gy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 101 */</span></span><br><span class="line"><span class="comment">/* Left point */</span></span><br><span class="line">z1 = *(magptr - <span class="number">1</span>);</span><br><span class="line">z2 = *(magptr + cols - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag1 = (m00 - z1)*xperp + (z1 - z2)*yperp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Right point */</span></span><br><span class="line">z1 = *(magptr + <span class="number">1</span>);</span><br><span class="line">z2 = *(magptr - cols + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag2 = (m00 - z1)*xperp + (z1 - z2)*yperp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 100 */</span></span><br><span class="line"><span class="comment">/* Left point */</span></span><br><span class="line">z1 = *(magptr + cols);</span><br><span class="line">z2 = *(magptr + cols - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag1 = (z1 - z2)*xperp + (m00 - z1)*yperp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Right point */</span></span><br><span class="line">z1 = *(magptr - cols);</span><br><span class="line">z2 = *(magptr - cols + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag2 = (z1 - z2)*xperp + (m00 - z1)*yperp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((gy = *gyptr) &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (-gx &gt;= gy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 011 */</span></span><br><span class="line"><span class="comment">/* Left point */</span></span><br><span class="line">z1 = *(magptr + <span class="number">1</span>);</span><br><span class="line">z2 = *(magptr - cols + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag1 = (z1 - m00)*xperp + (z2 - z1)*yperp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Right point */</span></span><br><span class="line">z1 = *(magptr - <span class="number">1</span>);</span><br><span class="line">z2 = *(magptr + cols - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag2 = (z1 - m00)*xperp + (z2 - z1)*yperp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 010 */</span></span><br><span class="line"><span class="comment">/* Left point */</span></span><br><span class="line">z1 = *(magptr - cols);</span><br><span class="line">z2 = *(magptr - cols + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag1 = (z2 - z1)*xperp + (z1 - m00)*yperp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Right point */</span></span><br><span class="line">z1 = *(magptr + cols);</span><br><span class="line">z2 = *(magptr + cols - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag2 = (z2 - z1)*xperp + (z1 - m00)*yperp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (-gx &gt; -gy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 001 */</span></span><br><span class="line"><span class="comment">/* Left point */</span></span><br><span class="line">z1 = *(magptr + <span class="number">1</span>);</span><br><span class="line">z2 = *(magptr + cols + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag1 = (z1 - m00)*xperp + (z1 - z2)*yperp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Right point */</span></span><br><span class="line">z1 = *(magptr - <span class="number">1</span>);</span><br><span class="line">z2 = *(magptr - cols - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag2 = (z1 - m00)*xperp + (z1 - z2)*yperp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 000 */</span></span><br><span class="line"><span class="comment">/* Left point */</span></span><br><span class="line">z1 = *(magptr + cols);</span><br><span class="line">z2 = *(magptr + cols + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag1 = (z2 - z1)*xperp + (m00 - z1)*yperp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Right point */</span></span><br><span class="line">z1 = *(magptr - cols);</span><br><span class="line">z2 = *(magptr - cols - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mag2 = (z2 - z1)*xperp + (m00 - z1)*yperp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now determine if the current point is a maximum point */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((mag1 &gt; <span class="number">0.0</span>) || (mag2 &gt; <span class="number">0.0</span>))</span><br><span class="line">&#123;</span><br><span class="line">*resultptr = NOEDGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mag2 == <span class="number">0.0</span>)</span><br><span class="line">*resultptr = NOEDGE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">*resultptr = POSSIBLE_EDGE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Canny::apply_hysteresis(<span class="keyword">float</span> tlow, <span class="keyword">float</span> thigh) &#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>, pos = <span class="number">0</span>, numedges = <span class="number">0</span>, lowcount = <span class="number">0</span>, highcount = <span class="number">0</span>, lowthreshold = <span class="number">0</span>, highthreshold = <span class="number">0</span>,</span><br><span class="line">i = <span class="number">0</span>, *hist, rr = <span class="number">0</span>, cc = <span class="number">0</span>;</span><br><span class="line">hist = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32768</span>];</span><br><span class="line"><span class="keyword">int</span> maximum_mag = <span class="number">0</span>, sumpix = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">0</span>, pos = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; cols; c++, pos++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nms[pos] == POSSIBLE_EDGE) edge[pos] = POSSIBLE_EDGE;</span><br><span class="line"><span class="keyword">else</span> edge[pos] = NOEDGE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">0</span>, pos = <span class="number">0</span>; r &lt; rows; r++, pos += cols) &#123;</span><br><span class="line">edge[pos] = NOEDGE;</span><br><span class="line">edge[pos + cols - <span class="number">1</span>] = NOEDGE;</span><br><span class="line">&#125;</span><br><span class="line">pos = (rows - <span class="number">1</span>) * cols;</span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; cols; c++, pos++) &#123;</span><br><span class="line">edge[c] = NOEDGE;</span><br><span class="line">edge[pos] = NOEDGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; <span class="number">32768</span>; r++) hist[r] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">0</span>, pos = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; cols; c++, pos++) &#123;</span><br><span class="line"><span class="keyword">if</span> (edge[pos] == POSSIBLE_EDGE) hist[magnitude[pos]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">1</span>, numedges = <span class="number">0</span>; r &lt; <span class="number">32768</span>; r++) &#123;</span><br><span class="line"><span class="keyword">if</span> (hist[r] != <span class="number">0</span>) maximum_mag = r;</span><br><span class="line">numedges += hist[r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">highcount = (<span class="keyword">int</span>)(numedges * thigh + <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">r = <span class="number">1</span>;</span><br><span class="line">numedges = hist[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> ((r &lt; (maximum_mag - <span class="number">1</span>)) &amp;&amp; (numedges &lt; highcount)) &#123;</span><br><span class="line">r++;</span><br><span class="line">numedges += hist[r];</span><br><span class="line">&#125;</span><br><span class="line">highthreshold = r;</span><br><span class="line">lowthreshold = (<span class="keyword">int</span>)(highthreshold * tlow + <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">0</span>, pos = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; cols; c++, pos++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((edge[pos] == POSSIBLE_EDGE) &amp;&amp; (magnitude[pos] &gt;= highthreshold)) &#123;</span><br><span class="line">edge[pos] = EDGE;</span><br><span class="line">follow_edges((edge + pos), (magnitude + pos), lowthreshold, cols);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">0</span>, pos = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; c &lt; cols; c++, pos++) <span class="keyword">if</span> (edge[pos] != EDGE) edge[pos] = NOEDGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] hist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_gaussian_kernel</span><span class="params">(<span class="keyword">float</span> sigma, <span class="keyword">float</span> **kernel, <span class="keyword">int</span> *windowsize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, center = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> x, fx, sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="comment">//根据高斯滤波核的方差计算高斯核的宽高</span></span><br><span class="line">*windowsize = <span class="number">1</span> + <span class="number">2</span> * <span class="built_in">ceil</span>(<span class="number">2.5</span> * sigma);</span><br><span class="line"><span class="comment">//*kernel = (float*)calloc((*windowsize), sizeof(float));</span></span><br><span class="line">center = (*windowsize) / <span class="number">2</span>;</span><br><span class="line">*kernel = <span class="keyword">new</span> <span class="keyword">float</span>[*windowsize];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (*windowsize); i++) &#123;</span><br><span class="line">x = (<span class="keyword">float</span>)(i - center);</span><br><span class="line">fx = <span class="built_in">pow</span>(<span class="number">2.71828</span>, <span class="number">-0.5</span>*x*x / (sigma*sigma)) / (sigma * <span class="built_in">sqrt</span>(<span class="number">6.2831853</span>));</span><br><span class="line">(*kernel)[i] = fx;</span><br><span class="line">sum += fx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (*windowsize); i++) &#123;</span><br><span class="line">(*kernel)[i] /= sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">angle_radians</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> xu = <span class="number">0.0</span>, yu = <span class="number">0.0</span>, ang = <span class="number">0.0</span>;</span><br><span class="line">xu = <span class="built_in">fabs</span>(x);</span><br><span class="line">yu = <span class="built_in">fabs</span>(y);</span><br><span class="line"><span class="keyword">if</span> ((xu == <span class="number">0</span>) &amp;&amp; (yu == <span class="number">0</span>)) <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">ang = <span class="built_in">atan</span>(yu / xu);</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (y &gt;= <span class="number">0</span>) <span class="keyword">return</span> (ang);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>(<span class="number">2</span> * M_PI - ang);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (y &gt;= <span class="number">0</span>) <span class="keyword">return</span> (M_PI - ang);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>(M_PI + ang);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">follow_edges</span><span class="params">(<span class="keyword">int</span> *edgemapptr, <span class="keyword">int</span> *edgemagptr, <span class="keyword">int</span> lowval, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *tempmagptr;</span><br><span class="line"><span class="keyword">int</span> *tempmapptr;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">float</span> thethresh;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">8</span>] = &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span> &#125;,</span><br><span class="line">y[<span class="number">8</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">tempmapptr = edgemapptr - y[i] * cols + x[i];</span><br><span class="line">tempmagptr = edgemagptr - y[i] * cols + x[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((*tempmapptr == POSSIBLE_EDGE) &amp;&amp; (*tempmagptr &gt; lowval)) &#123;</span><br><span class="line">*tempmapptr = EDGE;</span><br><span class="line">follow_edges(tempmapptr, tempmagptr, lowval, cols);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; Canny::canny_image() &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic = canny_image(<span class="number">2.0</span>, <span class="number">0.25</span>, <span class="number">0.75</span>);</span><br><span class="line"><span class="keyword">return</span> pic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; Canny::canny_image(<span class="keyword">int</span> sigma, <span class="keyword">float</span> tlow, <span class="keyword">float</span> thigh) &#123;</span><br><span class="line">RGBtoGray();</span><br><span class="line">gaussian_smooth(sigma);</span><br><span class="line">derrivative_x_y();</span><br><span class="line">radian_direction(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">magnitude_x_y();</span><br><span class="line">non_max_supp();</span><br><span class="line">apply_hysteresis(tlow, thigh);</span><br><span class="line"><span class="comment">//img.test();</span></span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic(rows, cols, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">pic.fill(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (edge[i*cols + j] &lt; <span class="number">0</span>)</span><br><span class="line">pic(i, j) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (edge[i*cols + j] &gt; <span class="number">255</span>)</span><br><span class="line">pic(i, j) = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pic(i, j) = edge[i*cols + j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; Canny::canny_line(CImg&lt;<span class="keyword">int</span>&gt; picture, <span class="keyword">int</span> distance) &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic = picture;</span><br><span class="line"><span class="comment">//用于计算某一个像素点是否为边缘点</span></span><br><span class="line"><span class="comment">//判断方法为查看以这个点为中心的八邻域，如果附近只有1个像素点为0, 其他7个为255则是边缘点</span></span><br><span class="line"><span class="keyword">bool</span> isEdge[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line">isEdge[x][y] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (x != rows - <span class="number">1</span> &amp;&amp; x != <span class="number">0</span> &amp;&amp; y != cols - <span class="number">1</span> &amp;&amp; y != <span class="number">0</span> &amp;&amp; pic(x, y) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> linyu[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(i == x &amp;&amp; j == y)) &#123;</span><br><span class="line">linyu[m] = pic(i, j);</span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(linyu, linyu + <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span> (linyu[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; linyu[<span class="number">1</span>] == <span class="number">255</span>)</span><br><span class="line">isEdge[x][y] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= distance &amp;&amp; x &lt;= rows - <span class="number">1</span> - distance &amp;&amp; y &gt;= distance &amp;&amp; y &lt;= cols - <span class="number">1</span> - distance &amp;&amp; isEdge[x][y] == <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x - distance; i &lt;= x + distance; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y - distance; j &lt;= y + distance; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isEdge[i][j] == <span class="literal">true</span>) &#123;</span><br><span class="line">pic = Draw_line(pic, x, y, i, j);</span><br><span class="line">isEdge[i][j] = <span class="literal">false</span>;</span><br><span class="line">isEdge[x][y] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; Canny::delete_line(CImg&lt;<span class="keyword">int</span>&gt; picture) &#123;</span><br><span class="line"><span class="comment">//用于计算某一个像素点是否为边缘点</span></span><br><span class="line"><span class="comment">//判断方法为查看以这个点为中心的八邻域，如果附近只有1个像素点为0, 其他7个为255则是边缘点</span></span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic = picture;</span><br><span class="line"><span class="keyword">bool</span> isEdge[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line">isEdge[x][y] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (x != rows - <span class="number">1</span> &amp;&amp; x != <span class="number">0</span> &amp;&amp; y != cols - <span class="number">1</span> &amp;&amp; y != <span class="number">0</span> &amp;&amp; pic(x, y) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> linyu[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(i == x &amp;&amp; j == y)) &#123;</span><br><span class="line">linyu[m] = pic(i, j);</span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(linyu, linyu + <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span> (linyu[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; linyu[<span class="number">1</span>] == <span class="number">255</span>)</span><br><span class="line">isEdge[x][y] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//删除单个孤立的点</span></span><br><span class="line"><span class="keyword">if</span> (linyu[<span class="number">0</span>] == <span class="number">255</span>)</span><br><span class="line">pic(x, y) = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除长度少于20的连线</span></span><br><span class="line"><span class="comment">//判断如果两个边界点的距离小于20，就删除这两个边界点组成的矩阵内所有黑点，这样的话即使两个边界点分别是两条直线的话也无所谓</span></span><br><span class="line"><span class="comment">//反正是这样的话这两边界点之间都是白色区域，删除也无所谓</span></span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line"><span class="keyword">int</span> distance = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (isEdge[x][y] == <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> begin_x = x - distance &gt; <span class="number">0</span> ? x - distance : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> begin_y = y - distance &gt; <span class="number">0</span> ? y - distance : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end_x = x + distance &lt; rows - <span class="number">1</span> ? x + distance : rows - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> end_y = y + distance &lt; cols - <span class="number">1</span> ? y + distance : cols - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = begin_x; i &lt;= end_x; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = begin_y; j &lt;= end_y; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isEdge[i][j] == <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> max_x = x &gt;= i ? x : i;</span><br><span class="line"><span class="keyword">int</span> max_y = y &gt;= j ? y : j;</span><br><span class="line"><span class="keyword">int</span> min_x = max_x == x ? i : x;</span><br><span class="line"><span class="keyword">int</span> min_y = max_y == y ? j : y;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii = min_x; ii &lt;= max_x; ii++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> jj = min_y; jj &lt;= max_y; jj++) &#123;</span><br><span class="line">pic(ii, jj) = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">isEdge[i][j] = <span class="literal">false</span>;</span><br><span class="line">isEdge[x][y] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除经过上一步处理完可能存在的单个孤立的噪声点</span></span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line"><span class="keyword">if</span> (x != rows - <span class="number">1</span> &amp;&amp; x != <span class="number">0</span> &amp;&amp; y != cols - <span class="number">1</span> &amp;&amp; y != <span class="number">0</span> &amp;&amp; pic(x, y) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> linyu[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(i == x &amp;&amp; j == y)) &#123;</span><br><span class="line">linyu[m] = pic(i, j);</span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(linyu, linyu + <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span> (linyu[<span class="number">0</span>] == <span class="number">255</span>)</span><br><span class="line">pic(x, y) = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; Draw_line(CImg&lt;<span class="keyword">int</span>&gt; tmp, <span class="keyword">int</span> x ,<span class="keyword">int</span> y, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1) &#123;</span><br><span class="line"></span><br><span class="line">CImg &lt;<span class="keyword">int</span>&gt; TempImg = tmp;</span><br><span class="line"><span class="keyword">int</span> black[] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">TempImg.draw_line(x, y, x1, y1, black);</span><br><span class="line"><span class="keyword">return</span> TempImg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Canny::test() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows*cols; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; edge[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>详细测试结果看测试报告：</strong><br><a href="https://download.csdn.net/download/perry0528/10732970" target="_blank" rel="noopener">https://download.csdn.net/download/perry0528/10732970</a><br><strong>完整代码参见：</strong><br><a href="https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp2" target="_blank" rel="noopener">https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Ex2：用-CImg-重写、封装给定的-Canny-代码，并测试&quot;&gt;&lt;a href=&quot;#Ex2：用-CImg-重写、封装给定的-Canny-代码，并测试&quot; class=&quot;headerlink&quot; title=&quot;Ex2：用 CImg 重写、封装给定的 Canny 代码
      
    
    </summary>
    
      <category term="计算机图形学" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="计算机图形学" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>用中位切割算法实现图像减色</title>
    <link href="http://yoursite.com/2019/07/06/%E7%94%A8%E4%B8%AD%E4%BD%8D%E5%88%87%E5%89%B2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E5%87%8F%E8%89%B2/"/>
    <id>http://yoursite.com/2019/07/06/用中位切割算法实现图像减色/</id>
    <published>2019-07-05T16:34:35.000Z</published>
    <updated>2019-07-05T16:35:22.260Z</updated>
    
    <content type="html"><![CDATA[<ul><li>实现环境：<strong>python</strong><br>处理一张红苹果图：<br><img src="https://img-blog.csdn.net/20181014163625887?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><strong>先描述一下中位切割算法吧：</strong> </li></ul><ol><li>将图片内的所有像素加入到同一个区域 </li><li>对于所有的区域做以下的事： </li><li>计算此区域内所有像素的 RGB 三元素最大值与最小值的差。 </li><li>选出相差最大的那个颜色（R 或 G 或 B） </li><li>根据那个颜色去排序此区域内所有像素 </li><li>分割前一半与后一半的像素到二个不同的区域（这里就是“中位切<br>割”名字的由来） </li><li>重复第二步直到你有 256 个区域 </li><li>将每个区域内的像素平均起来，于是你就得到了 256 色 </li></ol><p><strong>于是根据维基百科的算法描述先是实现了一个 cube 的类用于进行区域的筛选，</strong><br><strong>cube.py:</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> statistics <span class="keyword">import</span> mean</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cube</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, colors)</span>:</span></span><br><span class="line">        self.colors = colors <span class="keyword">or</span> []</span><br><span class="line">        self.red = [r[<span class="number">0</span>] <span class="keyword">for</span> r <span class="keyword">in</span> colors]</span><br><span class="line">        self.green = [g[<span class="number">1</span>] <span class="keyword">for</span> g <span class="keyword">in</span> colors]</span><br><span class="line">        self.blue = [b[<span class="number">2</span>] <span class="keyword">for</span> b <span class="keyword">in</span> colors]</span><br><span class="line">        self.size = (max(self.red) - min(self.red),</span><br><span class="line">                     max(self.green) - min(self.green),</span><br><span class="line">                     max(self.blue) - min(self.blue))</span><br><span class="line">        self.range = max(self.size)</span><br><span class="line">        self.channel = self.size.index(self.range)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.range &lt; other.range</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">average</span><span class="params">(self)</span>:</span></span><br><span class="line">        r = int(mean(self.red))</span><br><span class="line">        g = int(mean(self.green))</span><br><span class="line">        b = int(mean(self.blue))</span><br><span class="line">        <span class="keyword">return</span> r, g, b</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(self)</span>:</span></span><br><span class="line">        middle = int(len(self.colors) / <span class="number">2</span>)</span><br><span class="line">        colors = sorted(self.colors, key=<span class="keyword">lambda</span> c: c[self.channel])</span><br><span class="line">        <span class="keyword">return</span> Cube(colors[:middle]), Cube(colors[middle:])</span><br></pre></td></tr></table></figure><p><strong>main 函数借助 Cube 类实现了对图像中像素 rgb 值对应 LUT 的匹配：</strong><br><strong>main.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> cube <span class="keyword">import</span> Cube</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median_cut</span><span class="params">(img, num)</span>:</span></span><br><span class="line">    colors = []</span><br><span class="line">    <span class="keyword">for</span> count, color <span class="keyword">in</span> img.getcolors(img.width * img.height):</span><br><span class="line">        colors += [color]</span><br><span class="line">    cubes = [Cube(colors)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(cubes) &lt; num:</span><br><span class="line">        cubes.sort()</span><br><span class="line">        cubes += cubes.pop().split()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    LUT = &#123;&#125;</span><br><span class="line">    index = ()</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> cubes:</span><br><span class="line">        average = c.average()</span><br><span class="line">        <span class="keyword">for</span> color <span class="keyword">in</span> c.colors:</span><br><span class="line">            LUT[color] = average                </span><br><span class="line">    <span class="keyword">return</span> LUT</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> :</span></span><br><span class="line">    image = Image.open(<span class="string">'E://Desktop//duomeiti//redapple.jpg'</span>)</span><br><span class="line">    LUT = median_cut(image, <span class="number">256</span>)</span><br><span class="line">    img = np.array(image)</span><br><span class="line">    rows,cols,channel=img.shape</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">            index = (img[i,j,<span class="number">0</span>],img[i,j,<span class="number">1</span>],img[i,j,<span class="number">2</span>])</span><br><span class="line">            color = LUT[index]</span><br><span class="line">            img[i,j] = color</span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.savefig(<span class="string">'result3.jpg'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>结果示例：</strong><br><img src="https://img-blog.csdn.net/20181014163124977?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><p><strong>如果将颜色表提取出来效果如下：</strong><br>（因256色带是在太大csdn无法显示，故只截取了一部分）<br><img src="https://img-blog.csdn.net/20181014163300275?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20181014163346307?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20181014163422947?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;实现环境：&lt;strong&gt;python&lt;/strong&gt;&lt;br&gt;处理一张红苹果图：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181014163625887?watermark/2/text/aHR0cHM6Ly9ibG9
      
    
    </summary>
    
      <category term="多媒体技术" scheme="http://yoursite.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="多媒体技术" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>实现两帧的图像动态图像切换并存为gif</title>
    <link href="http://yoursite.com/2019/07/06/%E5%AE%9E%E7%8E%B0%E4%B8%A4%E5%B8%A7%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8A%A8%E6%80%81%E5%9B%BE%E5%83%8F%E5%88%87%E6%8D%A2%E5%B9%B6%E5%AD%98%E4%B8%BAgif/"/>
    <id>http://yoursite.com/2019/07/06/实现两帧的图像动态图像切换并存为gif/</id>
    <published>2019-07-05T16:31:26.000Z</published>
    <updated>2019-07-05T16:32:25.561Z</updated>
    
    <content type="html"><![CDATA[<p><strong>实现代码：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">imageChange</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"><span class="title">s</span> = <span class="title">char</span>(<span class="params"><span class="string">'E:\Desktop\多媒体技术\诺贝尔.jpg'</span>,<span class="string">'E:\Desktop\多媒体技术\lena.jpg'</span></span>);</span></span><br><span class="line"><span class="function"><span class="title">image</span> = <span class="title">cellstr</span>(<span class="params">s</span>);</span></span><br><span class="line"><span class="function"><span class="title">I1</span> = <span class="title">imread</span>(<span class="params">image&#123;<span class="number">1</span>&#125;</span>);</span></span><br><span class="line"><span class="function"><span class="title">I2</span> = <span class="title">imread</span>(<span class="params">image&#123;<span class="number">2</span>&#125;</span>);</span></span><br><span class="line"><span class="function"><span class="title">I1</span>=<span class="title">im2double</span>(<span class="params">I1</span>);</span></span><br><span class="line"><span class="function"><span class="title">I2</span>=<span class="title">im2double</span>(<span class="params">I2</span>);</span></span><br><span class="line">img = I1(:,:,2); %将诺贝尔图片转换为单通道灰度图，这里保留绿色通道</span><br><span class="line">img2 = I2(:,:,<span class="number">1</span>); %将lena图片只保留红色通道</span><br><span class="line">[width,height] = size(img);</span><br><span class="line">%设置窗口属性：禁用菜单栏，标题不显示编号，设置position</span><br><span class="line">F = figure(<span class="string">'menubar'</span>,<span class="string">'none'</span>,<span class="string">'NumberTitle'</span>,<span class="string">'off'</span>,<span class="string">'position'</span>,[<span class="number">1000</span> <span class="number">1000</span> width height],<span class="string">'name'</span>,<span class="string">'视频切换效果'</span>);</span><br><span class="line">movegui(F,<span class="string">'center'</span>);%居中</span><br><span class="line">%关闭坐标线</span><br><span class="line">axes(<span class="string">'Visible'</span>,<span class="string">'off'</span>,<span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'position'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>]);</span><br><span class="line">%设置最大的半径值</span><br><span class="line">R_max = sqrt((width/<span class="number">2</span>)^<span class="number">2</span>+(height/<span class="number">2</span>)^<span class="number">2</span>);</span><br><span class="line">step = <span class="number">30</span>; %设置步长，即<span class="number">30</span>帧</span><br><span class="line">x0 = width/<span class="number">2</span>; y0 = height/<span class="number">2</span>;</span><br><span class="line">pic_num = <span class="number">1</span>;</span><br><span class="line">hIm = imshow(img);</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>:<span class="number">1</span>:step</span><br><span class="line">%%圆的判断</span><br><span class="line">    <span class="keyword">for</span> x = <span class="number">1</span>:width</span><br><span class="line">        <span class="keyword">for</span> y = <span class="number">1</span>:height</span><br><span class="line">            <span class="keyword">if</span>(sqrt((x-x0)^<span class="number">2</span>+(y-y0)^<span class="number">2</span>) &lt;= i/step*R_max)</span><br><span class="line">               img(x,y) = img2(x,y);</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    <span class="keyword">set</span>(hIm,'CData',img);%设置image对象CData属性为Im</span><br><span class="line">    drawnow ;</span><br><span class="line">    %接下来是matlab根据每帧窗口生成gif的模板，可套用</span><br><span class="line">    F1=getframe(gcf);</span><br><span class="line">    I=frame2im(F1);</span><br><span class="line">    [I,map]=rgb2ind(I,256);</span><br><span class="line">    if pic_num == 1</span><br><span class="line">        imwrite(I,map,'E:\Desktop\多媒体技术\test.gif','gif', 'Loopcount',inf,'DelayTime',0.2);</span><br><span class="line">    else</span><br><span class="line">        imwrite(I,map,'E:\Desktop\多媒体技术\test.gif','gif','WriteMode','append','DelayTime',0.2);</span><br><span class="line">    end</span><br><span class="line">    pic_num = pic_num + 1;</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>用于测试的原图：</strong><br><img src="https://img-blog.csdn.net/20180930195805938?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20180930195818225?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><strong>实现效果：</strong><br><img src="https://img-blog.csdn.net/20180930195643900?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;实现代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="数字媒体技术" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%97%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="matlab" scheme="http://yoursite.com/tags/matlab/"/>
    
      <category term="多媒体技术" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>c++拉普拉斯算子锐化滤波以及标定差度方法</title>
    <link href="http://yoursite.com/2019/07/06/c-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90%E9%94%90%E5%8C%96%E6%BB%A4%E6%B3%A2%E4%BB%A5%E5%8F%8A%E6%A0%87%E5%AE%9A%E5%B7%AE%E5%BA%A6%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/07/06/c-拉普拉斯算子锐化滤波以及标定差度方法/</id>
    <published>2019-07-05T16:28:13.000Z</published>
    <updated>2019-07-05T16:29:08.640Z</updated>
    
    <content type="html"><![CDATA[<ul><li>c++ <strong>CImg</strong>库</li><li>采用标定和为标定两种实现算法</li></ul><p><strong>未标定：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">int</span>&gt; laplace_filter(CImg&lt;<span class="keyword">int</span>&gt; img) &#123;</span><br><span class="line"><span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>;x &lt; <span class="number">3</span>; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">3</span>; y++) &#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>) &#123;</span><br><span class="line">m(x, y) = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">m(x, y) = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> w = img.width(), h = img.height();</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic(w, h, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">pic = img;</span><br><span class="line">pic.resize(w + <span class="number">2</span> , h + <span class="number">2</span> , <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic1 = pic;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; temp(w,h,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; x &lt;= w  &amp;&amp; y &lt;= h ) &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; t(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">t(i, j) = pic1(x<span class="number">-1</span>+i, y<span class="number">-1</span>+j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">cimg_forXY(t, i1, j1) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt; <span class="number">3</span>; i2++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt; <span class="number">3</span>; j2++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i1 + i2 == <span class="number">2</span> &amp;&amp; j1 + j2 == <span class="number">2</span>) &#123;</span><br><span class="line">sum += t(i1, j1)*m(i2, j2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &lt; <span class="number">0</span>)sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">255</span>) sum = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">else</span> sum = sum;</span><br><span class="line">pic(x, y) = sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>标定：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">int</span>&gt; laplace_filterbiaoding(CImg&lt;<span class="keyword">int</span>&gt; img) &#123;</span><br><span class="line"><span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">3</span>; y++) &#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>) &#123;</span><br><span class="line">m(x, y) = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">m(x, y) = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> w = img.width(), h = img.height();</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic(w, h, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">pic = img;</span><br><span class="line">pic.resize(w + <span class="number">2</span>, h + <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic1 = pic;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; temp(w, h, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> min = <span class="number">100000</span>;</span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; x &lt;= w &amp;&amp; y &lt;= h) &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; t(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">t(i, j) = pic1(x - <span class="number">1</span> + i, y - <span class="number">1</span> + j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">cimg_forXY(t, i1, j1) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt; <span class="number">3</span>; i2++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt; <span class="number">3</span>; j2++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i1 + i2 == <span class="number">2</span> &amp;&amp; j1 + j2 == <span class="number">2</span>) &#123;</span><br><span class="line">sum += t(i1, j1)*m(i2, j2);</span><br><span class="line"><span class="keyword">if</span> (sum &lt; min) min = sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pic(x, y) = sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; pic(x, y) &lt;&lt;" ";</span></span><br><span class="line">pic(x, y) -= min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line"><span class="keyword">if</span> (pic(x, y) &gt; max)</span><br><span class="line">max = pic(x, y);</span><br><span class="line">&#125;</span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line">pic(x, y) = pic(x, y) * <span class="number">255</span> / max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里顺便说一下常用的标定方法有两种：</strong></p><ul><li><p>方法一：<br>对每一个像素值再加上255，然后除以2。该方法无法保证像素的取值可以覆盖0到255的全部8比特范围，但是所有的像素一定在这一范围。另外，在除以2过程中固有的截尾误差通常将导致精确度的损失。虽然有很多的不足，但是该非常的简单方便。</p></li><li><p>方法二：<br>该方法弥补的方法一的缺点，它可以得到更高的精确度并使像素取值覆盖整个8比特的范围。我们首先提取最小值，并把它的负值加到所有的差值图像的像素中（如果最小值是-a(a&gt;0)，则加上a；如果最小值是a，则减去a；通过该操作后，差值图像中最小的值就为0了）。之后，每一个像素乘以255/Max，其中Max为上一步操作之后图像的中最大像素值，这样就将所有的像素标定到0到255的范围内。</p></li></ul><p><strong>运行结果：</strong></p><p><img src="https://img-blog.csdn.net/2018092911252817?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="未标定"></p><p><img src="https://img-blog.csdn.net/20180929112622526?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><strong>原图：</strong><br><img src="https://img-blog.csdn.net/20180929114017796?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><strong>与原图加到一起后处理的效果：</strong><br><img src="https://img-blog.csdn.net/20180929113951368?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><p><strong>效果是不是特别棒棒！！！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;c++ &lt;strong&gt;CImg&lt;/strong&gt;库&lt;/li&gt;
&lt;li&gt;采用标定和为标定两种实现算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;未标定：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="数字图像处理" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="数字图像处理" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>c++实现平滑空间滤波</title>
    <link href="http://yoursite.com/2019/07/06/c-%E5%AE%9E%E7%8E%B0%E5%B9%B3%E6%BB%91%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/"/>
    <id>http://yoursite.com/2019/07/06/c-实现平滑空间滤波/</id>
    <published>2019-07-05T16:26:45.000Z</published>
    <updated>2019-07-05T16:27:27.101Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-平滑线性滤波器："><a href="#1-平滑线性滤波器：" class="headerlink" title="1.平滑线性滤波器："></a>1.平滑线性滤波器：</h3><p><strong>自己实现了用于空间平滑滤波的函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">int</span>&gt; Smooth_filter(CImg&lt;<span class="keyword">int</span>&gt; img, <span class="keyword">int</span> num) &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; m(num, num);</span><br><span class="line">cimg_forXY(m, x, y) &#123;</span><br><span class="line">m(x, y) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> w = img.width(), h = img.height();</span><br><span class="line"><span class="keyword">int</span> k = (num - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic(w, h, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">pic = img;</span><br><span class="line">pic.resize(w + <span class="number">2</span> * k, h + <span class="number">2</span> * k, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic1 = pic;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"不合法"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; temp(w,h,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= k &amp;&amp; y &gt;= k &amp;&amp; x &lt;= w + k - <span class="number">1</span> &amp;&amp; y &lt;= h + k - <span class="number">1</span>) &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; t(num, num);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">t(i, j) = pic1(x-k+i, y-k+j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">cimg_forXY(t, i1, j1) &#123;</span><br><span class="line">cimg_forXY(m, i2, j2) &#123;</span><br><span class="line"><span class="keyword">if</span> (i1 + i2 - k == <span class="number">1</span> &amp;&amp; j1 + j2 - k == <span class="number">1</span>) &#123;</span><br><span class="line">sum += (<span class="keyword">double</span>)t(i1, j1)*m(i2, j2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pic(x, y) = sum / num / num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用3*3的矩阵进行平滑滤波后的效果：</strong></p><p><img src="https://img-blog.csdn.net/20180928105513507?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20180928105545944?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><h3 id="2-中值滤波器："><a href="#2-中值滤波器：" class="headerlink" title="2.中值滤波器："></a>2.中值滤波器：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">int</span>&gt; median_filter(CImg&lt;<span class="keyword">int</span>&gt; img, <span class="keyword">int</span> num) &#123;</span><br><span class="line"><span class="keyword">int</span> w = img.width(), h = img.height();</span><br><span class="line"><span class="keyword">int</span> k = (num - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic(w, h, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">pic = img;</span><br><span class="line">pic.resize(w + <span class="number">2</span> * k, h + <span class="number">2</span> * k, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic1 = pic;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"不合法"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; temp(w, h, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= k &amp;&amp; y &gt;= k &amp;&amp; x &lt;= w + k - <span class="number">1</span> &amp;&amp; y &lt;= h + k - <span class="number">1</span>) &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; t(num, num);</span><br><span class="line"><span class="keyword">int</span> a = num * num;</span><br><span class="line"><span class="keyword">int</span> *filter;</span><br><span class="line">filter = <span class="keyword">new</span> <span class="keyword">int</span>[a];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">t(i, j) = pic1(x - k + i, y - k + j);</span><br><span class="line">filter[i*num + j] = t(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(filter,filter+a);</span><br><span class="line">pic(x, y) = filter[(a + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用3*3中值滤波器的滤波效果：</strong><br><img src="https://img-blog.csdn.net/2018092811410825?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><p><strong>使用CImg封装的中值滤波器检验一下效果—blur_median</strong><br><img src="https://img-blog.csdn.net/20180928115744805?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-平滑线性滤波器：&quot;&gt;&lt;a href=&quot;#1-平滑线性滤波器：&quot; class=&quot;headerlink&quot; title=&quot;1.平滑线性滤波器：&quot;&gt;&lt;/a&gt;1.平滑线性滤波器：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;自己实现了用于空间平滑滤波的函数：&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="数字图像处理" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="数字图像处理" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>c++对图像进行对数变换、幂律变换、比特面分层以及均衡化处理</title>
    <link href="http://yoursite.com/2019/07/06/c-%E5%AF%B9%E5%9B%BE%E5%83%8F%E8%BF%9B%E8%A1%8C%E5%AF%B9%E6%95%B0%E5%8F%98%E6%8D%A2%E3%80%81%E5%B9%82%E5%BE%8B%E5%8F%98%E6%8D%A2%E3%80%81%E6%AF%94%E7%89%B9%E9%9D%A2%E5%88%86%E5%B1%82%E4%BB%A5%E5%8F%8A%E5%9D%87%E8%A1%A1%E5%8C%96%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/07/06/c-对图像进行对数变换、幂律变换、比特面分层以及均衡化处理/</id>
    <published>2019-07-05T16:25:31.000Z</published>
    <updated>2019-07-05T16:26:18.256Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对数变换："><a href="#对数变换：" class="headerlink" title="对数变换："></a>对数变换：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">int</span>&gt; SrcImg;</span><br><span class="line">SrcImg.load_tiff(<span class="string">"E:/Desktop/picture_process/Lenna/3/Fig0305(a)(DFT_no_log).tif"</span>);</span><br><span class="line">SrcImg.display();</span><br><span class="line">cimg_forXY(SrcImg, x, y) &#123;</span><br><span class="line">SrcImg(x, y) = <span class="keyword">int</span>(<span class="built_in">log</span>(<span class="keyword">double</span>(SrcImg(x, y)) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">SrcImg.display();</span><br></pre></td></tr></table></figure><p><strong>运行效果：</strong><br><img src="https://img-blog.csdn.net/20180927161654391?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdn.net/20180927161826192?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><h3 id="幂律变换"><a href="#幂律变换" class="headerlink" title="幂律变换"></a>幂律变换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">int</span>&gt; SrcImg;</span><br><span class="line">SrcImg.load_tiff(<span class="string">"E:/Desktop/picture_process/Lenna/3/Fig0308(a)(fractured_spine).tif"</span>);</span><br><span class="line">SrcImg.display();</span><br><span class="line"><span class="keyword">double</span> t[<span class="number">3</span>] = &#123; <span class="number">0.6</span>,<span class="number">0.4</span>,<span class="number">0.3</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; img = SrcImg;</span><br><span class="line">cimg_forXY(img, x, y) &#123;</span><br><span class="line">img(x, y) = <span class="keyword">int</span>(<span class="built_in">pow</span>(<span class="keyword">double</span>((img(x, y))), t[i]));</span><br><span class="line">&#125;</span><br><span class="line">img.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br><img src="https://img-blog.csdn.net/20180927162450119?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20180927163016994?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20180927163040245?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20180927163107480?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><h3 id="比特面分层"><a href="#比特面分层" class="headerlink" title="比特面分层"></a>比特面分层</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">int</span>&gt; img;</span><br><span class="line">img.load_tiff(<span class="string">"E:/Desktop/picture_process/Lenna/3/Fig0314(a)(100-dollars).tif"</span>);</span><br><span class="line">img.display(<span class="string">"原图"</span>);</span><br><span class="line"><span class="keyword">int</span> w = img.height();</span><br><span class="line"><span class="keyword">int</span> h = img.width();</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; p1(h,w,<span class="number">1</span>,<span class="number">1</span>), p2(h, w, <span class="number">1</span>, <span class="number">1</span>), p3(h, w, <span class="number">1</span>, <span class="number">1</span>), p4(h, w, <span class="number">1</span>, <span class="number">1</span>), p5(h, w, <span class="number">1</span>, <span class="number">1</span>), p6(h, w, <span class="number">1</span>, <span class="number">1</span>), p7(h, w, <span class="number">1</span>, <span class="number">1</span>), p8(h, w, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cimg_forXY(img, x, y) &#123;</span><br><span class="line"><span class="keyword">int</span> num = img(x, y);</span><br><span class="line"><span class="keyword">int</span> *bit = binary(num);</span><br><span class="line">p1(x, y) = fx(bit[<span class="number">0</span>]); p2(x, y) = fx(bit[<span class="number">1</span>]); p3(x, y) = fx(bit[<span class="number">2</span>]); p4(x, y) = fx(bit[<span class="number">3</span>]);</span><br><span class="line">p5(x, y) = fx(bit[<span class="number">4</span>]); p6(x, y) = fx(bit[<span class="number">5</span>]); p7(x, y) = fx(bit[<span class="number">6</span>]); p8(x, y) = fx(bit[<span class="number">7</span>]);</span><br><span class="line">&#125;</span><br><span class="line">p8.display(<span class="string">"第八层比特图"</span>);</span><br><span class="line">p7.display(<span class="string">"第七层比特图"</span>);</span><br><span class="line">p6.display(<span class="string">"第六层比特图"</span>);</span><br><span class="line">p5.display(<span class="string">"第五层比特图"</span>);</span><br><span class="line">p4.display(<span class="string">"第四层比特图"</span>);</span><br><span class="line">p3.display(<span class="string">"第三层比特图"</span>);</span><br><span class="line">p2.display(<span class="string">"第二层比特图"</span>);</span><br><span class="line">p1.display(<span class="string">"第一层比特图"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于对图片进行黑白的赋值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fx</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于进行二进制转化的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">binary</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *bit;</span><br><span class="line">bit = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">bit[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (num) &#123;</span><br><span class="line">bit[i] = num % <span class="number">2</span>;</span><br><span class="line">num /= <span class="number">2</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br><img src="https://img-blog.csdn.net/20180927201653793?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/2018092720171944?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20180927201752372?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br>在这里插入图片描述<br><img src="https://img-blog.csdn.net/20180927201840114?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20180927201903373?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20180927201918302?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20180927201941618?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20180927201957547?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20180927202017962?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><h3 id="均衡化处理"><a href="#均衡化处理" class="headerlink" title="均衡化处理"></a>均衡化处理</h3><ul><li>CImg有专门显示密度分布直方图的histogram函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">int</span>&gt; hist = img.histogram(<span class="number">256</span>, <span class="number">0</span>, <span class="number">255</span>); <span class="comment">//histogram的第一个参数是共有256个灰度级，第二个参数是灰度的最小值，第三个是灰度最大值</span></span><br><span class="line">hist.display_graph();</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">int</span>&gt; img;</span><br><span class="line">img.load_tiff(<span class="string">"E:/Desktop/picture_process/Lenna/3/Fig0316(4)(bottom_left).tif"</span>);</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; pic = img;</span><br><span class="line">img.display(<span class="string">"处理前图片"</span>);</span><br><span class="line"><span class="keyword">int</span> size = img.size();</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; hist = img.histogram(<span class="number">256</span>, <span class="number">0</span>, <span class="number">255</span>); <span class="comment">//histogram的第一个参数是共有256个灰度级，第二个参数是灰度的最小值，第三个是灰度最大值</span></span><br><span class="line">hist.display_graph(<span class="string">"处理前直方图"</span>);</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">sum += (<span class="keyword">double</span>) hist(i)/size;</span><br><span class="line"><span class="keyword">int</span> Sum = (<span class="keyword">int</span>)(sum * <span class="number">255</span>);</span><br><span class="line">index.insert(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(i, Sum));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map&lt;int, int&gt;::iterator iter = index.begin();</span></span><br><span class="line"><span class="comment">//map&lt;int, int&gt;::iterator end = index.end();</span></span><br><span class="line"><span class="comment">/*for (; iter != end; iter++) &#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; iter-&gt;first&lt;&lt;":"&lt;&lt; iter-&gt;second &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">cimg_forXY(pic, x, y) &#123;</span><br><span class="line">pic(x, y) = index[pic(x, y)];</span><br><span class="line"><span class="comment">//cout &lt;&lt; pic(x, y) &lt;&lt; " ";</span></span><br><span class="line">&#125;</span><br><span class="line">pic.display(<span class="string">"处理后图片"</span>);</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; hist1 = pic.histogram(<span class="number">256</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">hist1.display_graph(<span class="string">"处理后直方图"</span>);</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br><img src="https://img-blog.csdn.net/20180927211300652?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20180927211323238?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20180927211345174?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdn.net/20180927211414866?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对数变换：&quot;&gt;&lt;a href=&quot;#对数变换：&quot; class=&quot;headerlink&quot; title=&quot;对数变换：&quot;&gt;&lt;/a&gt;对数变换：&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="数字图像处理" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="数字图像处理" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>区块链认识与看法</title>
    <link href="http://yoursite.com/2019/07/05/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%AE%A4%E8%AF%86%E4%B8%8E%E7%9C%8B%E6%B3%95/"/>
    <id>http://yoursite.com/2019/07/05/区块链认识与看法/</id>
    <published>2019-07-05T14:44:05.000Z</published>
    <updated>2019-07-05T14:44:36.649Z</updated>
    
    <content type="html"><![CDATA[<ul><li>通过阅读区块链技术发展现状与展望，郑子彬老师的区块链报告，以及知乎贴吧上关于区块链的讨论所写下的个人学习体会以及对区块链的个人看法。</li></ul><h2 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h2><p>从2008年中本聪发表了区块链的奠基性论文《比特币：一种点对点电子现金系统》后，区块链技术近年来呈现出了爆发式的增长态势。其快速发展引起了政府部门，金融机构，科技企业和资本市场的广泛关注。区块链技术也被认为是计算机范式的第五次颠覆性创新，是人类信用进化史上第四个里程碑。是下一代云计算的雏形，有望像互联网一样彻底重塑人类社会活动形态, 并实现从目前的信息互联网向价值互联网的转变。</p><p>其实说了这么多，区块链真正被大家所熟知，还是因为比特币。而比特币受到人们的广泛关注也更多是因为早期买入比特币的人的暴富效应。就像只是单纯地向人们解释区块链有着历史性变革的伟大意义，是一个机遇，会改变未来，人们可能毫无兴趣。但如果讲比特币可以赚钱，能让你一夜暴富，那估计人们的兴趣会因此大的多。也就是在这样一种情况下，比特币如一颗树一般，在生长的过程逐渐开枝散叶，慢慢长大，形成了如今下的区块链行业。</p><p>而区块链到底是什么，简单来说，它的本质就是一个分布式的网络，采取去中心化的信息存储方式，这一定程度上做到了“没有中间商赚差价”。以前我们说马云颠覆了中国的制造业，让工厂可以不通过销售商将产品直销给淘宝用户。然而这中间阿里巴巴这个中间商还是有赚平台差价的，支付宝担保交易。而区块链则是从技术上完全做到了“没有中间商赚差价”这一点。去中心化的另一个好处是，数据都是分散存储的，每一个区块链网络中的结点都存有交易的所有数据，因而不可被恶意篡改，安全性得到了极大的保证。至于这个网络的安全性保证，就要靠我们优秀的程序员们开发出的非对称加密算法了。</p><p>同时区块链系统本身具有自己的Token，Token 在国内有的翻译成“通证”，有的翻译成“代币”，其实最简单的理解就是“虚拟资产凭证”，它可以是我们的股权，也可以是票据，也可以是游戏积分，凡是需要资产记账的地方都可以用 Token 来做。而区块链则可以帮助多个节点达成共识去记录和Token相关的事情。另一方面要求加入区块链网络的人主动去存储数据，让“矿工”们主动的贡献出自己的内存和带宽。区块链世界引入了一个奖励的机制，例如在比特币系统中，这种奖励机制就是以代币（比特币）的方式对贡献算力的人进行奖励。</p><h2 id="区块链的应用"><a href="#区块链的应用" class="headerlink" title="区块链的应用"></a>区块链的应用</h2><p>关于区块链的应用场景，就目前区块链所处的阶段来看，主要是可大致分为两方面，一是数字货币，二是去中心化应用。数字货币我们所熟知的中比特币是先驱和目前市值最高，应用最广泛的代表，而去中心化应用目前也只是处于初级阶段，要想区块链来广泛应用到日常生活的方方面面还尚需一定时间。所以这里重点说一下目前去中心化应用的典型代表—以太坊和运行在以太坊上的智能合约。</p><p>目前运行在以太坊网络上的去中心化应用大约有近千个，主要有以下几大类：</p><ul><li><p><strong>去中心化的虚拟货币交易所</strong>： 用户不通过和交易所进行撮合交易，而是通过智能合约交互进行代币（token）的交易。目前尚处于初级阶段，仅支持在以太坊尚发行的代币，如EOS、TRX等。</p></li><li><p><strong>区块链游戏</strong>：2017年云撸猫横空出世并吸引了全球的关注并引发了一波区块链游戏狂潮，但目前的玩法方面和真正的手游，端游相比仍过于简单。所以不少游戏玩家抱怨：这不算游戏，简直就是资金盘。因而要达到像是王者荣耀，LOL这类全民游戏还尚需一定的发展历程。</p></li><li><p><strong>虚拟物品交易市场</strong>：例如各种区块链游戏中的游戏资产便可以通过智能合约进行交易。但目前也扔处于初级阶段，活跃不高。</p></li><li><p><strong>投票、众筹</strong>：前段时间非洲的塞拉利昂举行了首个以区块链技术为基础的总统投票选举。区块链技术改善了先前数字投票系统的缺点，确保了投票的安全、透明和匿名。</p></li></ul><p>通过智能合约可以做到快速建立信任，数据无法篡改，过程透明，信息完全对称等优点。但现阶段尚未成熟的智能合约也存在着例如无法及时交互，发送指令费用高，开发环境尚不成熟等显著缺点，这些缺点限制了目前去中心化应用的发展，同时也给未来的新的去中心化技术提供了机会和发展方向。</p><h2 id="区块链的挑战"><a href="#区块链的挑战" class="headerlink" title="区块链的挑战"></a>区块链的挑战</h2><p>区块链自产生以来业界就对其褒贬不一，就如曾经的人工智能，克隆一般，每一项新兴技术的发展必然伴随着质疑和不信任。而真正能予以证明的只有历史。但是一门新兴的技术要发展的更高效率和更具先进意义，就要解决现存的很多问题。</p><ul><li><p>首先很现实的一个问题也是区块链本身优点所带来的，就是效率问题，采用分布式的存储分部，每一个节点保存一份完整的数据库，且网络中任何一笔交易都要其他节点认证和记录，这导致区块链系统工作效率十分之低。</p></li><li><p>其次基于其分布式账本策略，这代表着需要很多主体记账且需要他们达到共识，然而目前业界在共识协议层面存在着很大的分期，且一些主流机制也有硬性的缺点。比如主流的Pow，存在着效率低下以及拜占庭容错等问题亟待解决。</p></li><li><p>安全性问题：曾经很多人都觉得51%攻击是一种可能，不太现实。然而就仅2018这一年来，几类加密货币都遭到了所谓51%攻击，Verge、BTG相继成为受害者，这恰恰说明：都说区块链安全，但也不是牢不可破的。</p></li><li><p>犯罪行业：有人认为，基于区块链自治的特点，会淡化监管影响（或监管层面触及不够），所以市场的逐利性和“看不见的手”，会将它应用和引入非法领域，暂时成为某些“黑灰产业”的庇护所。</p></li></ul><p>其实从区块链当下存在的问题来看，它的问题来源也正是其技术的先进方面所带来的。所以每一门新兴的技术都是一把利弊皆在的双刃剑，只有真正利大于弊的技术才能生存并得以持久发展。在未来，第四次工业革命的到来将会使现存的技术水平以及社会制度发生翻天覆地的变化。当下流行的科技前沿也会引领第四次工业革命的发展方向。首先是生物科学技术，其代表性技术基因技术将可能会突破上帝创造生物的规则，从新塑写人类、动植物的身体构造。其次以人工智能，量子计算，区块链，数据挖掘为代表的互联网技术将会日渐渗透到我们日常生活中。再者人类探索宇宙的步伐将会加速，探索外太空所带来的资源利用以及科技进步将会深刻地影响到我们的日常生活。而区块链的发展毕竟推进第四次工业革命的进程，同时革命伴随的其他先进技术的发展也将促进区块链技术更好地走向成熟。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;通过阅读区块链技术发展现状与展望，郑子彬老师的区块链报告，以及知乎贴吧上关于区块链的讨论所写下的个人学习体会以及对区块链的个人看法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是区块链&quot;&gt;&lt;a href=&quot;#什么是区块链&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
</feed>
