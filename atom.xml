<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PerryWang🍎博客</title>
  
  <subtitle>分享软件开发中学到的点滴知识</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-08T07:08:38.573Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>PerryWang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>次优查找树的c++实现</title>
    <link href="http://yoursite.com/2019/07/08/%E6%AC%A1%E4%BC%98%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84c-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/07/08/次优查找树的c-实现/</id>
    <published>2019-07-08T07:07:52.000Z</published>
    <updated>2019-07-08T07:08:38.573Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考严蔚敏老师的数据结构(c语言版)，并用c++加以实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  Search_Optimal</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by peiyu wang on 2019/3/19.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 peiyu wang. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;ElemType;</span><br><span class="line"></span><br><span class="line">ElemType r[N] = &#123;&#123;<span class="string">'A'</span>,<span class="number">1</span>&#125;,&#123;<span class="string">'B'</span>,<span class="number">1</span>&#125;,&#123;<span class="string">'C'</span>,<span class="number">2</span>&#125;,&#123;<span class="string">'D'</span>,<span class="number">5</span>&#125;,&#123;<span class="string">'E'</span>,<span class="number">3</span>&#125;,&#123;<span class="string">'F'</span>,<span class="number">4</span>&#125;,&#123;<span class="string">'G'</span>,<span class="number">4</span>&#125;,&#123;<span class="string">'H'</span>,<span class="number">3</span>&#125;,&#123;<span class="string">'I'</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> sw[N + <span class="number">1</span>]; <span class="comment">// 累计权值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    BiTNode *lchild, *rchild;</span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> BiTree SOSTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Create_Table</span><span class="params">(SSTable &amp;ST, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ST.elem = <span class="keyword">new</span> ElemType [n + <span class="number">1</span>];</span><br><span class="line">    ST.length = n;</span><br><span class="line">    <span class="keyword">if</span> (!ST.elem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ST.elem[i+<span class="number">1</span>] = r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Destory_Table</span><span class="params">(SSTable &amp;ST)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] ST.elem;</span><br><span class="line">    ST.elem = <span class="literal">NULL</span>;</span><br><span class="line">    ST.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于sort函数的排序方式函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cmp</span><span class="params">(<span class="keyword">const</span> ElemType &amp;a, <span class="keyword">const</span> ElemType &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.key &lt; b.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己实现的快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, ElemType a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right;</span><br><span class="line">    <span class="keyword">while</span> (i != j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[j].key &gt;= a[left].key &amp;&amp; j &gt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a[i].key &lt;= a[left].key &amp;&amp; j &gt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != j)</span><br><span class="line">        &#123;</span><br><span class="line">            ElemType temp = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ElemType temp1 = a[i];</span><br><span class="line">    a[i] = a[left];</span><br><span class="line">    a[left] = temp1;</span><br><span class="line">    QuickSort(left, i - <span class="number">1</span> , a);</span><br><span class="line">    QuickSort(i + <span class="number">1</span>, right, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Create_Order_Table</span><span class="params">(SSTable &amp;ST, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    flag = Create_Table(ST, n);</span><br><span class="line">    <span class="keyword">int</span> flag1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(ST.elem + <span class="number">1</span>, ST.elem + N + <span class="number">1</span>, Cmp);</span><br><span class="line">        <span class="comment">//flag1 = QuickSort(1, n, ST.elem);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (flag <span class="keyword">and</span> flag1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Table</span><span class="params">(SSTable ST, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>].key = key;</span><br><span class="line">    <span class="keyword">int</span> i = ST.length;</span><br><span class="line">    <span class="keyword">for</span> (; ST.elem[i].key != key; i--);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    low = <span class="number">1</span>;</span><br><span class="line">    high = ST.length;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (ST.elem[mid].key == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ST.elem[mid].key &gt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Traverse</span><span class="params">(SSTable ST)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ST.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ST.elem[i].key &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SecondOptimal</span><span class="params">(BiTree &amp;T, ElemType R[], <span class="keyword">float</span> sw[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">double</span> min, dw;</span><br><span class="line">    min = <span class="built_in">fabs</span>(sw[high] - sw[low]);</span><br><span class="line">    dw = sw[high] + sw[low - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = low + <span class="number">1</span>; j &lt;= high; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(dw - sw[j] - sw[j<span class="number">-1</span>]) &lt; min)</span><br><span class="line">        &#123;</span><br><span class="line">            i = j;</span><br><span class="line">            min = <span class="built_in">fabs</span>(dw - sw[j] - sw[j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T = <span class="keyword">new</span> BiTNode;</span><br><span class="line">    T-&gt;data = R[i];</span><br><span class="line">    <span class="keyword">if</span> (i == low)</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        SecondOptimal(T-&gt;lchild, R, sw, low, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == high)</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        SecondOptimal(T-&gt;rchild, R, sw, i + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateSOSTree</span><span class="params">(SOSTree &amp;T, SSTable ST)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ST.length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sw[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ST.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sw[i] = sw[i - <span class="number">1</span>] + ST.elem[i].weight;</span><br><span class="line">        &#125;</span><br><span class="line">        SecondOptimal(T, ST.elem, sw, <span class="number">1</span>, ST.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_SOSTree</span><span class="params">(SOSTree &amp;T, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;data.key == key)</span><br><span class="line">            <span class="keyword">return</span> OK;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;data.key &gt; key)</span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    SOSTree T;</span><br><span class="line">    KeyType key;</span><br><span class="line">    Create_Order_Table(ST, N);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; Search_Table(ST, 'C') &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; Search_Bin(ST, 'D') &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//Traverse(ST);</span></span><br><span class="line">    CreateSOSTree(T, ST);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入待查找的字符"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; key;</span><br><span class="line">    <span class="keyword">if</span> (Search_SOSTree(T, key))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; key &lt;&lt; <span class="string">"的权值是"</span> &lt;&lt; T-&gt;data.weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"不存在此字符"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;参考严蔚敏老师的数据结构(c语言版)，并用c++加以实现&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>坐标系统的认识并创建3D旋转小物体</title>
    <link href="http://yoursite.com/2019/07/08/%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%A4%E8%AF%86%E5%B9%B6%E5%88%9B%E5%BB%BA3D%E6%97%8B%E8%BD%AC%E5%B0%8F%E7%89%A9%E4%BD%93/"/>
    <id>http://yoursite.com/2019/07/08/坐标系统的认识并创建3D旋转小物体/</id>
    <published>2019-07-08T07:06:25.000Z</published>
    <updated>2019-07-08T07:07:25.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><p>（coordinate system)</p><h3 id="局部空间（物体空间）"><a href="#局部空间（物体空间）" class="headerlink" title="局部空间（物体空间）"></a>局部空间（物体空间）</h3><p>局部空间是指物体所在的坐标空间，即对象最开始所在的地方。想象你在一个建模软件（比如说Blender，Blender中通过移动浮标来决定新建物体的局部坐标）中创建了一个立方体。你创建的立方体的原点有可能位于(0, 0, 0)，即便它有可能最后在程序中处于完全不同的位置。甚至有可能你创建的所有模型都以(0, 0, 0)为初始位置（译注：然而它们会最终出现在世界的不同位置）。所以，你的模型的所有顶点都是在<strong>局部</strong>空间中：它们相对于你的物体来说都是局部的。</p><p>我们一直使用的那个箱子的顶点是被设定在-0.5到0.5的坐标范围中，(0, 0)是它的原点。这些都是局部坐标。</p><h3 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h3><p>如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点(0, 0, 0)上，而我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由<strong>模型矩阵(Model Matrix)</strong>实现的。</p><p>模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。</p><h3 id="观察空间（视觉空间）"><a href="#观察空间（视觉空间）" class="headerlink" title="观察空间（视觉空间）"></a>观察空间（视觉空间）</h3><p>观察空间经常被人们称之OpenGL的<strong>摄像机(Camera)</strong>（所以有时也称为<strong>摄像机空间</strong>(Camera Space)或<strong>视觉空间</strong>(Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的<strong>位移和旋转</strong>的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个<strong>观察矩阵(View Matrix)</strong>里，它被用来将世界坐标变换到观察空间。</p><h3 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h3><p>在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来。</p><p>因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会<strong>指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系</strong>，就像OpenGL期望的那样。</p><p>为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。</p><blockquote><p>如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。</p></blockquote><p>由投影矩阵创建的<strong>观察箱</strong>(Viewing Box)被称为<strong>平截头体</strong>(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到2D观察空间坐标）被称之为<strong>投影</strong>(Projection)，因为使用投影矩阵能将3D坐标投影(Project)到很容易映射到2D的标准化设备坐标系中。</p><p>一旦所有顶点被变换到裁剪空间，最终的操作——<strong>透视除法</strong>(Perspective Division)将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行。</p><p>在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用<strong>glViewport</strong>中的设定），并被变换成片段。</p><p>将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个<strong>正射投影矩阵</strong>(Orthographic Projection Matrix)或一个<strong>透视投影矩阵</strong>(Perspective Projection Matrix)。</p><h4 id="正射投影"><a href="#正射投影" class="headerlink" title="正射投影"></a>正射投影</h4><p>正射投影矩阵定义了一个类似立方体的<strong>平截头箱</strong>，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的<strong>宽、高和长度</strong>。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体内的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器：</p><p>[外链图片转存中…(img-aHCAFJcX-1562569587032)]</p><p>上面的平截头体定义了可见的坐标，它由由宽、高、近(Near)平面和远(Far)平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的w分量都没有进行改变；如果w分量等于1.0，透视除法则不会改变这个坐标。</p><p>要创建一个正射投影矩阵，我们可以使用GLM的内置函数<code>glm::ortho</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::ortho(<span class="number">0.0f</span>, <span class="number">800.0f</span>, <span class="number">0.0f</span>, <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部。通过这四个参数我们定义了近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离。这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。</p><p>正射投影矩阵直接将坐标映射到2D平面中，即你的屏幕，但实际上一个直接的投影矩阵会产生不真实的结果，因为这个投影没有将透视(Perspective)考虑进去。所以我们需要透视投影矩阵来解决这个问题。</p><h4 id="透视投影："><a href="#透视投影：" class="headerlink" title="透视投影："></a>透视投影：</h4><p>投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点坐标的w值，从而使得<strong>离观察者越远的顶点坐标w分量越大</strong>。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL要求所有可见的坐标都落在-1.0到1.0范围内，作为顶点着色器最后的输出，因此，一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上：<br>$$<br>out = \begin{pmatrix} x /w \ y / w \ z / w \end{pmatrix}<br>$$<br>顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。这是也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影。最后的结果坐标就是处于标准化设备空间中的。</p><p>参考文章：<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html" target="_blank" rel="noopener">http://www.songho.ca/opengl/gl_projectionmatrix.html</a></p><p>在GLM中可以这样创建一个透视投影矩阵：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 proj = glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="keyword">float</span>)width/(<span class="keyword">float</span>)height, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>同样，<code>glm::perspective</code>所做的其实就是创建了一个定义了可视空间的大<strong>平截头体</strong>，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会受到裁剪。一个透视平截头体可以被看作一个不均匀形状的箱子，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视平截头体的图片：</p><p>[外链图片转存中…(img-WSk5GWPY-1562569587033)]</p><p>它的第一个参数定义了fov的值，它表示的是视野(Field of View)，并且设置了观察空间的大小。如果想要一个<strong>真实的观察效果，它的值通常设置为45.0f</strong>，但想要一个<strong>末日风格的结果你可以将其设置一个更大的值</strong>。第二个参数设置了宽高比，由视口的宽除以高所得。第三和第四个参数设置了平截头体的<strong>近</strong>和<strong>远</strong>平面。我们通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染。</p><blockquote><p>当你把透视矩阵的 <em>near</em> 值设置太大时（如10.0f），OpenGL会将靠近摄像机的坐标（在0.0f和10.0f之间）都裁剪掉，这会导致一个你在游戏中很熟悉的视觉效果：在太过靠近一个物体的时候你的视线会直接穿过去。</p></blockquote><h3 id="屏幕空间"><a href="#屏幕空间" class="headerlink" title="屏幕空间"></a>屏幕空间</h3><p>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段</p><h3 id="openGL应用："><a href="#openGL应用：" class="headerlink" title="openGL应用："></a>openGL应用：</h3><p>我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标：<br>$$<br>V_{clip} = M_{projection} \cdot M_{view} \cdot M_{model} \cdot V_{local}<br>$$<br>注意矩阵运算的顺序是相反的（记住我们需要从右往左阅读矩阵的乘法）。最后的顶点应该被赋值到顶点着色器中的gl_Position，OpenGL将会自动进行透视除法和裁剪。</p><blockquote><p>顶点着色器的输出要求所有的顶点都在裁剪空间内，这正是我们刚才使用变换矩阵所做的。OpenGL然后对<strong>裁剪坐标</strong>执行<strong>透视除法</strong>从而将它们变换到<strong>标准化设备坐标</strong>。OpenGL会使用glViewPort内部的参数来将标准化设备坐标映射到<strong>屏幕坐标</strong>，每个坐标都关联了一个屏幕上的点。这个过程称为视口变换。</p></blockquote><p>然后绘制36个顶点并用<code>glDrawArrays</code>绘制出立方体。</p><p>但是如果只是正常绘制出来的话，会出现如下情况：</p><p><img src="https://img-blog.csdnimg.cn/20190315164819796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>立方体的某些本应被遮挡住的面被绘制在了这个立方体其他面之上。之所以这样是因为OpenGL是一个三角形一个三角形地来绘制你的立方体的，所以即便之前那里有东西它也会覆盖之前的像素。因为这个原因，有些三角形会被绘制在其它三角形上面，虽然它们本不应该是被覆盖的。</p><p>OpenGL存储深度信息在一个叫做Z缓冲(Z-buffer)的缓冲中，它允许OpenGL决定何时覆盖一个像素而何时不覆盖。通过使用Z缓冲，我们可以配置OpenGL来进行深度测试。</p><h4 id="Z缓冲"><a href="#Z缓冲" class="headerlink" title="Z缓冲"></a>Z缓冲</h4><p>OpenGL存储它的所有深度信息于一个Z缓冲(Z-buffer)中，也被称为<strong>深度缓冲</strong>(Depth Buffer)。GLFW会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在每个片段里面（作为片段的<strong>z</strong>值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为<strong>深度测试</strong>(Depth Testing)，它是由OpenGL自动完成的。</p><p>然而，如果我们想要确定OpenGL真的执行了深度测试，首先我们要告诉OpenGL我们想要启用深度测试；它默认是关闭的。我们可以通过glEnable函数来开启深度测试。glEnable和glDisable函数允许我们启用或禁用某个OpenGL功能。这个功能会一直保持启用/禁用状态，直到另一个调用来禁用/启用它。现在我们想启用深度测试，需要开启GL_DEPTH_TEST：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure><p>因为我们使用了深度测试，我们也想要在每次渲染迭代之前清除深度缓冲（否则前一帧的深度信息仍然保存在缓冲中）。就像清除颜色缓冲一样，我们可以通过在glClear函数中指定DEPTH_BUFFER_BIT位来清除深度缓冲：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p><strong>运行后效果改为如下：</strong><br><img src="https://img-blog.csdnimg.cn/20190315164837795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="进一步创建更多的立方体："><a href="#进一步创建更多的立方体：" class="headerlink" title="进一步创建更多的立方体："></a>进一步创建更多的立方体：</h3><p>首先，让我们为每个立方体定义一个位移向量来指定它在世界空间的位置。我们将在一个glm::vec3数组中定义10个立方体位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cubePositions[] = &#123;</span><br><span class="line">  glm::vec3( <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>), </span><br><span class="line">  glm::vec3( <span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>), </span><br><span class="line">  glm::vec3(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">  glm::vec3(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),  </span><br><span class="line">  glm::vec3(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>), </span><br><span class="line">  glm::vec3( <span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>), </span><br><span class="line">  glm::vec3(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，在游戏循环中，我们调用glDrawArrays 10次，但这次在我们渲染之前每次传入一个不同的模型矩阵到顶点着色器中。我们将会在游戏循环中创建一个小的循环用不同的模型矩阵渲染我们的物体10次。注意我们也对每个箱子加了一点旋转：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  glm::mat4 model;</span><br><span class="line">  model = glm::translate(model, cubePositions[i]);</span><br><span class="line">  <span class="keyword">float</span> angle = <span class="number">20.0f</span> * i; </span><br><span class="line">  model = glm::rotate(model, glm::radians(angle), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">  ourShader.setMat4(<span class="string">"model"</span>, model);</span><br><span class="line"></span><br><span class="line">  glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将会在每次新立方体绘制出来的时候更新模型矩阵，如此总共重复10次。然后我们应该就能看到一个拥有10个正在奇葩地旋转着的立方体的世界。<br><img src="https://img-blog.csdnimg.cn/20190315165150812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>完整代码参考</strong>：<a href="https://github.com/WangPerryWPY/Computer-Graphics/tree/master/3dRotate" target="_blank" rel="noopener">https://github.com/WangPerryWPY/Computer-Graphics/tree/master/3dRotate</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;坐标系统&quot;&gt;&lt;a href=&quot;#坐标系统&quot; class=&quot;headerlink&quot; title=&quot;坐标系统&quot;&gt;&lt;/a&gt;坐标系统&lt;/h2&gt;&lt;p&gt;（coordinate system)&lt;/p&gt;
&lt;h3 id=&quot;局部空间（物体空间）&quot;&gt;&lt;a href=&quot;#局部空间（物体空
      
    
    </summary>
    
      <category term="计算机图形学" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="计算机图形学" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>openGL中的线性代数(矩阵的变换)</title>
    <link href="http://yoursite.com/2019/07/08/OpenGL%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8F%98%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/07/08/OpenGL中的线性代数-矩阵的变换/</id>
    <published>2019-07-08T07:04:39.000Z</published>
    <updated>2019-07-08T07:06:09.492Z</updated>
    
    <content type="html"><![CDATA[<h3 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h3><p>位移(Translation)是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程，从而在位移向量基础上移动了原始向量。<br>和缩放矩阵一样，在4×4矩阵上有几个特别的位置用来执行特定的操作，对于位移来说它们是第四列最上面的3个值。如果我们把位移向量表示为(Tx,Ty,Tz)，我们就能把位移矩阵定义为：<br>$$<br>\begin{bmatrix}  \color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}{T_x} \ \color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}{T_y} \ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}{T_z} \ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \ y \ z \ 1 \end{pmatrix} = \begin{pmatrix} x + \color{red}{T_x} \ y + \color{green}{T_y} \ z + \color{blue}{T_z} \ 1 \end{pmatrix}<br>$$<br>这样是能工作的，因为所有的位移值都要乘以向量的w行，所以位移值会加到向量的原始值上（想想矩阵乘法法则）。而如果你用3x3矩阵我们的位移值就没地方放也没地方乘了，所以是不行的。</p><blockquote><p><strong>齐次坐标(Homogeneous Coordinates)</strong></p><p>向量的w分量也叫齐次坐标。想要从齐次向量得到3D向量，我们可以把x、y和z坐标分别除以w坐标。我们通常不会注意这个问题，因为w分量通常是1.0。使用齐次坐标有几点好处：它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的），而且下一章我们会用w值创建3D视觉效果。</p><p>如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移（译注：这也就是我们说的不能位移一个方向）。</p></blockquote><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>2D空间的旋转可以通过向量表示，比如(x, y)旋转角度A旋转到(x1,y1)。</p><p>那么x1 = xcosA - ysinA，y1 = xsinA + ycosA（或者是x1 = xcosA + ysinA，y1 = -xsinA + y * cosA）</p><p>也就是说它的二维旋转变换矩阵就是：<br>$$<br> \begin{matrix}<br>  cosA &amp; sinA\<br>   -sinA &amp; cosA<br>  \end{matrix}<br>$$<br>或者是：<br>$$<br> \begin{matrix}<br>  cosA &amp; -sinA\<br>   sinA &amp; cosA<br>  \end{matrix}<br>$$<br>在3D空间中旋转需要定义一个角和一个旋转轴(Rotation Axis)。物体会沿着给定的旋转轴旋转特定角度。<br>旋转矩阵在3D空间中每个单位轴都有不同定义，旋转角度用θ表示：</p><p>沿x轴旋转：<br>$$<br>\begin{bmatrix} \color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \ \color{green}0 &amp; \color{green}{\cos \theta} &amp; - \color{green}{\sin \theta} &amp; \color{green}0 \ \color{blue}0 &amp; \color{blue}{\sin \theta} &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \ y \ z \ 1 \end{pmatrix} = \begin{pmatrix} x \ \color{green}{\cos \theta} \cdot y - \color{green}{\sin \theta} \cdot z \ \color{blue}{\sin \theta} \cdot y + \color{blue}{\cos \theta} \cdot z \ 1 \end{pmatrix}<br>$$<br>沿y轴旋转：<br>$$<br>\begin{bmatrix} \color{red}{\cos \theta} &amp; \color{red}0 &amp; \color{red}{\sin \theta} &amp; \color{red}0 \ \color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}0 \ - \color{blue}{\sin \theta} &amp; \color{blue}0 &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \ y \ z \ 1 \end{pmatrix} = \begin{pmatrix} \color{red}{\cos \theta} \cdot x + \color{red}{\sin \theta} \cdot z \ y \ - \color{blue}{\sin \theta} \cdot x + \color{blue}{\cos \theta} \cdot z \ 1 \end{pmatrix}<br>$$<br>沿z轴旋转：<br>$$<br>\begin{bmatrix} \color{red}{\cos \theta} &amp; - \color{red}{\sin \theta} &amp; \color{red}0 &amp; \color{red}0 \ \color{green}{\sin \theta} &amp; \color{green}{\cos \theta} &amp; \color{green}0 &amp; \color{green}0 \ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0 \ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \ y \ z \ 1 \end{pmatrix} = \begin{pmatrix} \color{red}{\cos \theta} \cdot x - \color{red}{\sin \theta} \cdot y  \ \color{green}{\sin \theta} \cdot x + \color{green}{\cos \theta} \cdot y \ z \ 1 \end{pmatrix}<br>$$<br>沿着任意轴(Rx, Ry, Rz)旋转：<br>$$<br>\begin{bmatrix} \cos \theta + \color{red}{R_x}^2(1 - \cos \theta) &amp; \color{red}{R_x}\color{green}{R_y}(1 - \cos \theta) - \color{blue}{R_z} \sin \theta &amp; \color{red}{R_x}\color{blue}{R_z}(1 - \cos \theta) + \color{green}{R_y} \sin \theta &amp; 0 \ \color{green}{R_y}\color{red}{R_x} (1 - \cos \theta) + \color{blue}{R_z} \sin \theta &amp; \cos \theta + \color{green}{R_y}^2(1 - \cos \theta) &amp; \color{green}{R_y}\color{blue}{R_z}(1 - \cos \theta) - \color{red}{R_x} \sin \theta &amp; 0 \ \color{blue}{R_z}\color{red}{R_x}(1 - \cos \theta) - \color{green}{R_y} \sin \theta &amp; \color{blue}{R_z}\color{green}{R_y}(1 - \cos \theta) + \color{red}{R_x} \sin \theta &amp; \cos \theta + \color{blue}{R_z}^2(1 - \cos \theta) &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}<br>$$</p><h3 id="矩阵的组合"><a href="#矩阵的组合" class="headerlink" title="矩阵的组合"></a>矩阵的组合</h3><p>使用矩阵进行变换的真正力量在于，根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中。让我们看看我们是否能生成一个变换矩阵，让它组合多个变换。假设我们有一个顶点(x, y, z)，我们希望将其缩放2倍，然后位移(1, 2, 3)个单位。我们需要一个位移和缩放矩阵来完成这些变换。结果的变换矩阵看起来像这样：<br>$$<br>Trans . Scale = \begin{bmatrix} \color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}1 \ \color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}2 \ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}3 \ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} . \begin{bmatrix} \color{red}2 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \ \color{green}0 &amp; \color{green}2 &amp; \color{green}0 &amp; \color{green}0 \ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}2 &amp; \color{blue}0 \ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} = \begin{bmatrix} \color{red}2 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}1 \ \color{green}0 &amp; \color{green}2 &amp; \color{green}0 &amp; \color{green}2 \ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}2 &amp; \color{blue}3 \ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix}<br>$$<br>注意，当矩阵相乘时我们先写位移再写缩放变换的。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该从右向左读这个乘法。建议您在组合矩阵时，<strong>先进行缩放操作，然后是旋转，最后才是位移</strong>，否则它们会（消极地）互相影响。比如，如果你先位移再缩放，位移的向量也会同样被缩放（译注：比如向某方向移动2米，2米也许会被缩放成1米）！</p><p>用最终的变换矩阵左乘我们的向量会得到以下结果：</p><p>$$<br>\begin{bmatrix} \color{red}2 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}1 \ \color{green}0 &amp; \color{green}2 &amp; \color{green}0 &amp; \color{green}2 \ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}2 &amp; \color{blue}3 \ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} . \begin{bmatrix} x \ y \ z \ 1 \end{bmatrix} = \begin{bmatrix} \color{red}2x + \color{red}1 \ \color{green}2y + \color{green}2  \ \color{blue}2z + \color{blue}3 \ 1 \end{bmatrix}<br>$$</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>openGL配合GLM库使用，这是一个专门为openGL定制的数学库。</p><blockquote><p>GLM库从0.9.9版本起，默认会将矩阵类型初始化为一个零矩阵（所有元素均为0），而不是单位矩阵（对角元素为1，其它元素为0）。如果你使用的是0.9.9或0.9.9以上的版本，你需要将所有的矩阵初始化改为 <figure class="highlight plain"><figcaption><span>mat </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">头文件</span><br><span class="line">```c</span><br><span class="line">#include &lt;glm/glm.hpp&gt;</span><br><span class="line">#include &lt;glm/gtc/matrix_transform.hpp&gt;</span><br><span class="line">#include &lt;glm/gtc/type_ptr.hpp&gt;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><ul><li>位移</li></ul><p>例如将一个向量(1, 0, 0)位移(1, 1, 0)个单位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::<span class="function">vec4 <span class="title">vec</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line">glm::mat4 trans = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">trans = glm::translate(trans, glm::vec3(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">vec = trans * vec;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ul><li>旋转+缩放</li></ul><p>例如将物体先在每个轴都缩放到0.5倍，然后沿z轴旋转90度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">trans = glm::rotate(trans, glm::radians(<span class="number">90.0f</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">trans = glm::scale(trans, glm::vec3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br></pre></td></tr></table></figure><h4 id="将矩阵传递给着色器："><a href="#将矩阵传递给着色器：" class="headerlink" title="将矩阵传递给着色器："></a>将矩阵传递给着色器：</h4><p>GLSL里也有一个mat4类型，修改顶点着色器让其接收一个mat4的uniform变量，然后再用矩阵uniform乘以位置向量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">uniform mat4 transform;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = transform * vec4(aPos, <span class="number">1.0f</span>);</span><br><span class="line">    TexCoord = vec2(aTexCoord.x, <span class="number">1.0</span> - aTexCoord.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在把位置向量传给gl_Position之前，先添加一个uniform，并且将其与变换矩阵相乘。物体现在应该是原来的二分之一大小并（向左）旋转了90度。当然，我们仍需要把变换矩阵传递给着色器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> transformLoc = glGetUniformLocation(ourShader.ID, <span class="string">"transform"</span>);</span><br><span class="line">glUniformMatrix4fv(transformLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(trans));</span><br></pre></td></tr></table></figure><p>我们首先查询uniform变量的地址，然后用有Matrix4fv后缀的glUniform函数把矩阵数据发送给着色器。第一个参数你现在应该很熟悉了，它是uniform的位置值。第二个参数告诉OpenGL我们将要发送多少个矩阵，这里是1。第三个参数询问我们我们是否希望对我们的矩阵进行置换(Transpose)，也就是说交换我们矩阵的行和列。OpenGL开发者通常使用一种内部矩阵布局，叫做列主序(Column-major Ordering)布局。GLM的默认布局就是列主序，所以并不需要置换矩阵，我们填GL_FALSE。最后一个参数是真正的矩阵数据，但是GLM并不是把它们的矩阵储存为OpenGL所希望接受的那种，因此我们要先用GLM的自带的函数value_ptr来变换这些数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;位移&quot;&gt;&lt;a href=&quot;#位移&quot; class=&quot;headerlink&quot; title=&quot;位移&quot;&gt;&lt;/a&gt;位移&lt;/h3&gt;&lt;p&gt;位移(Translation)是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程，从而在位移向量基础上移动了原始向量。&lt;
      
    
    </summary>
    
      <category term="计算机图形学" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="计算机图形学" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>绘制简单三角形并利用ImGUI改变三角形颜色</title>
    <link href="http://yoursite.com/2019/07/08/%E7%BB%98%E5%88%B6%E7%AE%80%E5%8D%95%E4%B8%89%E8%A7%92%E5%BD%A2%E5%B9%B6%E5%88%A9%E7%94%A8ImGUI%E6%94%B9%E5%8F%98%E4%B8%89%E8%A7%92%E5%BD%A2%E9%A2%9C%E8%89%B2/"/>
    <id>http://yoursite.com/2019/07/08/绘制简单三角形并利用ImGUI改变三角形颜色/</id>
    <published>2019-07-08T07:03:12.000Z</published>
    <updated>2019-07-08T07:04:17.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GUI-and-Draw-simple-graphics"><a href="#GUI-and-Draw-simple-graphics" class="headerlink" title="GUI and Draw simple graphics"></a>GUI and Draw simple graphics</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>学习来源</strong></p><ul><li>learnOpenGL</li></ul><p><strong>重要概念</strong></p><p>顶点数组对象(VAO)</p><p>顶点缓冲对象(VBO)</p><p>索引缓冲对象(EBO)</p><h4 id="图形渲染管线"><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h4><p>3D坐标转为2D像素的处理过程是由OpenGL的<strong>图形渲染管线</strong>管理的，它分为两部分工作。</p><ul><li>第一部分把3D坐标转为适应屏幕的2D坐标。</li><li>第二部分把2D坐标转变为实际有颜色的像素。</li></ul><h4 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h4><p><strong>标准化设备坐标(NDC)</strong>，将输入的顶点定义在-1.0～1.0之间，接着通过<strong>视口变换</strong>将标准化设备坐标变为<strong>屏幕空间坐标</strong>。</p><p>顶点着色器会在GPU上创建内存存储这些顶点数据并配置OpenGL如何解释这些内存并指定其如何发送给显卡。通过<strong>顶点缓冲对象(VBO)</strong>来管理这个内存，它会在显存种存储大量顶点。使用VBO的好处是能一次性的发送大批数据到显卡上。</p><h4 id="着色器-Shader"><a href="#着色器-Shader" class="headerlink" title="着色器(Shader)"></a>着色器(Shader)</h4><p>着色器是使用一种为GLSL的类c语言写成的，GLSL是为图形计算量身定制的。</p><ul><li>顶点着色器：把一个单独的顶点作为输入。主要目的是把3D坐标转为另一种3D坐标，同时允许我们对顶点属性进行一些基本操作。</li><li>图元装配：将顶点着色器输出的所有顶点作为输入(GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP等来指定数据表示的渲染类型，这称为<strong>图元</strong>)，并将所有的点装配成指定图元的形状。</li><li>几何着色器：将图元形式的一些列顶点的集合作为输入，它通过产生新顶点构造出新的（或是其他的）图元来生成其他形状。</li><li>光栅化阶段：把图元映射为最终屏幕上相应的像素，生成供片段着色器使用的片段。同时在片段着色器运行前会执行<strong>裁切</strong>。裁切会丢弃超出视图外的所有像素来提升执行效率。</li><li>片段着色器：计算一个像素的最终颜色，通常包含3D场景的数据（比如光照，阴影，光的颜色等等），这些数据可以被用来计算最终像素的颜色。</li><li>Alpha测试和混合阶段：检测片段对应的深度(和模板)值，用他们来判断这个像素是其他物体的前面还是后面，决定是否应该丢弃。同时检测alpha值(这定义了一个物体的透明度)，并对物体进行<strong>混合</strong>。</li></ul><h4 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h4><p>设置顶点属性指针将其绑定到<strong>顶点数组对象VAO</strong>上，VAO上会存储以下内容：</p><ul><li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li><li>通过glVertexAttribPointer设置的顶点属性配置。</li><li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li></ul><p>之后再打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。</p><h4 id="索引缓存对象-EBO"><a href="#索引缓存对象-EBO" class="headerlink" title="索引缓存对象(EBO)"></a>索引缓存对象(EBO)</h4><p>索引绘制：通过设置顶点，以索引的方式来绘制图形，这就避免了重复存储顶点。</p><p><strong>总结以上流程理解并绘制如下</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20190313142438112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Work"><a href="#Work" class="headerlink" title="Work"></a>Work</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h5 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h5><ul><li>Mac OS X</li></ul><h5 id="IDE："><a href="#IDE：" class="headerlink" title="IDE："></a>IDE：</h5><ul><li>Xcode</li></ul><h5 id="引用库："><a href="#引用库：" class="headerlink" title="引用库："></a>引用库：</h5><ul><li>glfw3+glad+ImGUI</li></ul><h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic:"></a>Basic:</h3><h5 id="1-使用OpenGL-3-3及以上-GLFW或freeglut画一个简单的三角形。"><a href="#1-使用OpenGL-3-3及以上-GLFW或freeglut画一个简单的三角形。" class="headerlink" title="1. 使用OpenGL(3.3及以上)+GLFW或freeglut画一个简单的三角形。"></a>1. 使用OpenGL(3.3及以上)+GLFW或freeglut画一个简单的三角形。</h5><p><strong>顶点输入</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左</span></span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 右</span></span><br><span class="line">        <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>  <span class="comment">// 上</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p><strong>编写着色器代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"out vec4 vertexColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"   vertexColor = vec4(1.0f, 1.0f, 0.8f, 0.8f);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"in vec4 vertexColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vertexColor;\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br></pre></td></tr></table></figure><p><strong>编译着色器代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译顶点着色器</span></span><br><span class="line">    <span class="keyword">int</span> vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">// 错误检查</span></span><br><span class="line">    <span class="keyword">int</span> success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编译片段着色器</span></span><br><span class="line">    <span class="keyword">int</span> fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">    <span class="comment">// 错误检查</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>链接着色器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个程序对象</span></span><br><span class="line">    <span class="keyword">int</span> shaderProgram = glCreateProgram();</span><br><span class="line">    <span class="comment">// 将编译好的着色器附着到程序上</span></span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    <span class="comment">// 链接错误检查</span></span><br><span class="line">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链接完成，删除着色器对象</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure><p><strong>配置生成VAO</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="comment">// bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制顶点数组到缓冲中供openGL使用</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置顶点属性指针, 告知openGL如何解析这些顶点数据</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>绘制三角形</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//渲染</span></span><br><span class="line">       glClearColor(<span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);<span class="comment">//设置清空p屏幕所用的颜色</span></span><br><span class="line">       glClear(GL_COLOR_BUFFER_BIT);<span class="comment">//使用当前状态来获取应该清除为的颜色</span></span><br><span class="line">       </span><br><span class="line">       glUseProgram(shaderProgram);</span><br><span class="line">       glBindVertexArray(VAO); </span><br><span class="line">       glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><strong>生成效果：</strong></p><p><img src="https://img-blog.csdnimg.cn/20190313142516822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="2-对三角形的三个顶点分别改为红绿蓝，像下面这样。并解释为什么会出现这样的结果。"><a href="#2-对三角形的三个顶点分别改为红绿蓝，像下面这样。并解释为什么会出现这样的结果。" class="headerlink" title="2. 对三角形的三个顶点分别改为红绿蓝，像下面这样。并解释为什么会出现这样的结果。"></a>2. 对三角形的三个顶点分别改为红绿蓝，像下面这样。并解释为什么会出现这样的结果。</h5><ul><li>比起第一问主要有以下更改：</li></ul><p><strong>在输入顶点中添加颜色属性：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="comment">//位置               // 颜色</span></span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左</span></span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="comment">// 右</span></span><br><span class="line">        <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> <span class="comment">// 上</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p><strong>添加配置顶点颜色属性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 颜色属性</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><img src="https://img-blog.csdnimg.cn/20190313142537709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>现象解释：</strong></p><blockquote><p>这是在片段着色器中进行的片段插值(Fragment Interpolation)的结果。当渲染一个三角形时，光栅化(Rasterization)阶段通常会造成比原指定顶点更多的片段。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。 </p><p>基于这些位置，它会插值(Interpolate)所有片段着色器的输入变量。</p></blockquote><p>光栅化会把顶点数据映射为像素点，生成供片段着色器使用的片段，同时会裁切出超出视图外的所有像素。也就是说虽然我们只输入三个顶点但是光栅化会补充其他构成三角形的片段像素点。然后片段着色器会根据我们提供的三个点的颜色值对其他的像素点进行等比例插值。</p><h5 id="3-给上述工作添加一个GUI，里面有一个菜单栏，使得可以选择并改变三角形的颜色。"><a href="#3-给上述工作添加一个GUI，里面有一个菜单栏，使得可以选择并改变三角形的颜色。" class="headerlink" title="3. 给上述工作添加一个GUI，里面有一个菜单栏，使得可以选择并改变三角形的颜色。"></a>3. 给上述工作添加一个GUI，里面有一个菜单栏，使得可以选择并改变三角形的颜色。</h5><p>比起前两步的工作：</p><ul><li>将着色器封装成一个类文件，将着色器代码写到单独的文件中去</li><li>调用ImGUI做出一个图形界面</li></ul><p><strong>窗口初始化设置：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imgui窗口设置</span></span><br><span class="line">    IMGUI_CHECKVERSION();</span><br><span class="line">    ImGui::CreateContext();</span><br><span class="line">    ImGuiIO &amp;io = ImGui::GetIO(); (<span class="keyword">void</span>)io;</span><br><span class="line">    <span class="comment">// 设置颜色主题</span></span><br><span class="line">    ImGui::StyleColorsLight();</span><br><span class="line">    <span class="comment">// Setup Platform/Renderer bindings</span></span><br><span class="line">    ImGui_ImplGlfw_InitForOpenGL(window, <span class="literal">true</span>);</span><br><span class="line">    ImGui_ImplOpenGL3_Init(<span class="string">"#version 330"</span>);</span><br></pre></td></tr></table></figure><p><strong>启动imGUI的框架并处理相应的IO事件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ImGui_ImplOpenGL3_NewFrame();</span><br><span class="line">        ImGui_ImplGlfw_NewFrame();</span><br><span class="line">        ImGui::NewFrame();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//static float f = 0.0f;</span></span><br><span class="line">            ImGui::Begin(<span class="string">"HW2"</span>);</span><br><span class="line">            ImGui::Text(<span class="string">"change color"</span>);</span><br><span class="line">            <span class="comment">//ImGui::SliderFloat("float", &amp;f, 0.0f, 1.0f);</span></span><br><span class="line">            <span class="comment">// 将更改的颜色存入color中</span></span><br><span class="line">            ImGui::ColorEdit3(<span class="string">"choose one color"</span>, (<span class="keyword">float</span> *)&amp;color, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 勾选框，选中则使三角形保持三色渐变色，取消勾选则课进行全局颜色设置</span></span><br><span class="line">            ImGui::Checkbox(<span class="string">"default color"</span>,  &amp;default_color);</span><br><span class="line">            <span class="keyword">if</span> (default_color)</span><br><span class="line">            &#123;</span><br><span class="line">                vertices[<span class="number">3</span>] = <span class="number">0.0f</span>; vertices[<span class="number">4</span>] = <span class="number">1.0f</span>; vertices[<span class="number">5</span>] = <span class="number">0.0f</span>;</span><br><span class="line">                vertices[<span class="number">9</span>] = <span class="number">0.0f</span>; vertices[<span class="number">10</span>] = <span class="number">0.0f</span>; vertices[<span class="number">11</span>] = <span class="number">1.0f</span>;</span><br><span class="line">                vertices[<span class="number">15</span>] = <span class="number">1.0f</span>; vertices[<span class="number">16</span>] = <span class="number">0.0f</span>; vertices[<span class="number">17</span>] = <span class="number">0.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    vertices[i * <span class="number">6</span> + <span class="number">3</span>] = color.x;</span><br><span class="line">                    vertices[i * <span class="number">6</span> + <span class="number">4</span>] = color.y;</span><br><span class="line">                    vertices[i * <span class="number">6</span> + <span class="number">5</span>] = color.z;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ImGui::Text(<span class="string">"Application average %.3f ms/frame (%.1f FPS)"</span>, <span class="number">1000.0f</span> / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);</span><br><span class="line">            ImGui::End();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>同时因为在每次IO操作都会改变三角形的属性，所以将VBO，VAO配置加入到窗口循环中，并用ImGUI进行渲染</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染</span></span><br><span class="line">ImGui::Render();</span><br><span class="line">ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</span><br></pre></td></tr></table></figure><p><strong>最终clean up</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除GUI资源</span></span><br><span class="line">ImGui_ImplOpenGL3_Shutdown();</span><br><span class="line">ImGui_ImplGlfw_Shutdown();</span><br><span class="line">ImGui::DestroyContext();</span><br></pre></td></tr></table></figure><p><strong>实现效果：</strong></p><ul><li>功能一：<ul><li>勾选default  color三角形保持默认三原色渐变</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20190313142608944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>功能二：<ul><li>不勾选default  color，选择一个颜色，三角形变为选择的全局色</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20190313142616373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190313142627248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus:"></a>Bonus:</h3><h5 id="1-绘制其他的图元，除了三角形，还有点、线等。"><a href="#1-绘制其他的图元，除了三角形，还有点、线等。" class="headerlink" title="1. 绘制其他的图元，除了三角形，还有点、线等。"></a>1. 绘制其他的图元，除了三角形，还有点、线等。</h5><p><strong>加入两条直线，6个点</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直线1</span></span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.9f</span>, <span class="number">0.9f</span>, <span class="number">0.666f</span>, <span class="comment">// 左下</span></span><br><span class="line"><span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.9f</span>, <span class="number">0.9f</span>, <span class="number">0.666f</span>, <span class="comment">// 左上</span></span><br><span class="line"><span class="comment">// 直线2</span></span><br><span class="line"><span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.36f</span>, <span class="number">0.36f</span>, <span class="comment">// 右下</span></span><br><span class="line"><span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.36f</span>, <span class="number">0.36f</span>, <span class="comment">// 右上</span></span><br><span class="line"><span class="comment">// 点1</span></span><br><span class="line"><span class="number">0.75f</span>, <span class="number">0.05f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 上</span></span><br><span class="line"><span class="comment">// 点2</span></span><br><span class="line"><span class="number">0.75f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 中</span></span><br><span class="line"><span class="comment">// 点3</span></span><br><span class="line"><span class="number">0.75f</span>, <span class="number">-0.05f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 下</span></span><br><span class="line"><span class="comment">// 点1</span></span><br><span class="line"><span class="number">0.8f</span>, <span class="number">0.05f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 上</span></span><br><span class="line"><span class="comment">// 点2</span></span><br><span class="line"><span class="number">0.8f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 中</span></span><br><span class="line"><span class="comment">// 点3</span></span><br><span class="line"><span class="number">0.8f</span>, <span class="number">-0.05f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> <span class="comment">// 下</span></span><br></pre></td></tr></table></figure><p><strong>加入勾选框，选择则出现对应的图形</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ImGui::Checkbox(<span class="string">"default color"</span>,  &amp;default_color);</span><br><span class="line">ImGui::Checkbox(<span class="string">"draw lines"</span>, &amp;lines);</span><br><span class="line">ImGui::Checkbox(<span class="string">"draw points"</span>, &amp;points);</span><br></pre></td></tr></table></figure><p><strong>绘制图形</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_LINES, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">glDrawArrays(GL_POINTS, <span class="number">7</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><ul><li>直线：</li></ul><p><img src="https://img-blog.csdnimg.cn/20190313142700714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>点：</li></ul><p><img src="https://img-blog.csdnimg.cn/20190313142707346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="2-使用EBO-Element-Buffer-Object-绘制多个三角形。"><a href="#2-使用EBO-Element-Buffer-Object-绘制多个三角形。" class="headerlink" title="2. 使用EBO(Element Buffer Object)绘制多个三角形。"></a>2. 使用EBO(Element Buffer Object)绘制多个三角形。</h5><p><strong>五个顶点索引2个三角形</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三角形</span></span><br><span class="line"><span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左</span></span><br><span class="line"><span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="comment">// 右</span></span><br><span class="line"><span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 上</span></span><br><span class="line"><span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="comment">// 第二个三角形</span></span><br><span class="line"><span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">//</span></span><br></pre></td></tr></table></figure><p><strong>绘制索引</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引绘制</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> <span class="comment">// 第二个三角形</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p><strong>生成EBO对象</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO, EBO;</span><br><span class="line">    <span class="comment">// 生成对象</span></span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br></pre></td></tr></table></figure><p><strong>将索引数组复制到索引缓冲中供openGL使用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p><strong>绘制</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190313142751582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>成品展示：</strong><br><img src="https://img-blog.csdnimg.cn/20190313143001475.gif" alt="在这里插入图片描述"><br>代码地址：<br><a href="https://github.com/WangPerryWPY/Computer_Graphics/tree/master/HW2" target="_blank" rel="noopener">https://github.com/WangPerryWPY/Computer_Graphics/tree/master/HW2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GUI-and-Draw-simple-graphics&quot;&gt;&lt;a href=&quot;#GUI-and-Draw-simple-graphics&quot; class=&quot;headerlink&quot; title=&quot;GUI and Draw simple graphics&quot;&gt;&lt;/a&gt;GU
      
    
    </summary>
    
      <category term="计算机图形学" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="计算机图形学" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CMD获取所有连接过的WIFI密码</title>
    <link href="http://yoursite.com/2019/07/08/CMD%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%9A%84WIFI%E5%AF%86%E7%A0%81/"/>
    <id>http://yoursite.com/2019/07/08/CMD获取所有连接过的WIFI密码/</id>
    <published>2019-07-08T07:01:15.000Z</published>
    <updated>2019-07-08T07:02:32.476Z</updated>
    
    <content type="html"><![CDATA[<p>一、以管理员权限运行CMD （以及 开启无线网卡、最好是笔记本）</p><p>二、输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for /f "skip=9 tokens=1,2 delims=:" %i in ('netsh wlan show profiles') do  @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear</span><br></pre></td></tr></table></figure><p>三、然后CMD就列出很多行 你以前连接过的wifi信息、加密方式、包括密码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、以管理员权限运行CMD （以及 开启无线网卡、最好是笔记本）&lt;/p&gt;
&lt;p&gt;二、输入命令：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="skill" scheme="http://yoursite.com/categories/skill/"/>
    
    
      <category term="skill" scheme="http://yoursite.com/tags/skill/"/>
    
  </entry>
  
  <entry>
    <title>图中两点的最短路径-弗洛伊德算法</title>
    <link href="http://yoursite.com/2019/07/08/%E5%9B%BE%E4%B8%AD%E4%B8%A4%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E4%BD%9B%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/07/08/图中两点的最短路径-佛洛伊德算法/</id>
    <published>2019-07-08T06:59:56.000Z</published>
    <updated>2019-07-08T07:00:31.047Z</updated>
    
    <content type="html"><![CDATA[<p>原理讲解参考：<a href="https://www.cnblogs.com/wangyuliang/p/9216365.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangyuliang/p/9216365.html</a></p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"><span class="built_in">string</span> vexs[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(Graph G, <span class="built_in">string</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (G.vexs[i] == v) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(Graph *G)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点数和弧数: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;vexnum &gt;&gt; G-&gt;arcnum;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;vexs[i];</span><br><span class="line">G-&gt;arcs[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">G-&gt;arcs[i][j] = INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;arcnum; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入边的两个顶点, from v1 to v2: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> v1, v2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line"><span class="keyword">int</span> i1 = LocateVex(*G, v1);</span><br><span class="line"><span class="keyword">int</span> i2 = LocateVex(*G, v2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入弧的权值: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;arcs[i1][i2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"图的邻接矩阵是: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"     "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; G.vexs[i] &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; <span class="string">"|"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; G.vexs[(G.vexnum - 1)];</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (G.arcs[i][j] == INT_MAX) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"|"</span> &lt;&lt; setw(<span class="number">5</span>) &lt;&lt; <span class="string">"∞"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;  <span class="string">"|"</span> &lt;&lt; setw(<span class="number">5</span>) &lt;&lt; G.arcs[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"|"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Flyod</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = G.vexnum;</span><br><span class="line"><span class="keyword">int</span> ShortPathTable[num][num];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">ShortPathTable[i][j] = G.arcs[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != j) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; num; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j != k) &#123;</span><br><span class="line"><span class="keyword">if</span> (ShortPathTable[i][k] != INT_MAX &amp;&amp; ShortPathTable[j][i] != INT_MAX) &#123;</span><br><span class="line"><span class="keyword">if</span> (ShortPathTable[i][k] + ShortPathTable[j][i] &lt; ShortPathTable[j][k]) &#123;</span><br><span class="line">ShortPathTable[j][k] = ShortPathTable[i][k] + ShortPathTable[j][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"更新后图的最短路径矩阵是: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"     "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; G.vexs[i] &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; <span class="string">"|"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ShortPathTable[i][j] == INT_MAX) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"|"</span> &lt;&lt; setw(<span class="number">5</span>) &lt;&lt; <span class="string">"∞"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;  <span class="string">"|"</span> &lt;&lt; setw(<span class="number">5</span>) &lt;&lt; ShortPathTable[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"|"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">Graph G;</span><br><span class="line">CreateGraph(&amp;G);</span><br><span class="line">Print(G);</span><br><span class="line">ShortestPath_Flyod(G);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现效果："><a href="#实现效果：" class="headerlink" title="实现效果："></a>实现效果：</h3><p><img src="https://img-blog.csdnimg.cn/20190125154525488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190125154334171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>测试2：</strong><br><img src="https://img-blog.csdnimg.cn/2019012515425385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原理讲解参考：&lt;a href=&quot;https://www.cnblogs.com/wangyuliang/p/9216365.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/wangyuliang/p/
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>图中两点的最短路径-迪杰斯特拉算法</title>
    <link href="http://yoursite.com/2019/07/08/%E5%9B%BE%E4%B8%AD%E4%B8%A4%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/07/08/图中两点的最短路径-迪杰斯特拉算法/</id>
    <published>2019-07-08T06:57:08.000Z</published>
    <updated>2019-07-08T06:58:22.540Z</updated>
    
    <content type="html"><![CDATA[<p>从某个顶点出发到其他所有各点的最短路径<strong>迪杰斯特拉算法</strong></p><p>数据结构采用有向图的邻接矩阵存储。</p><h3 id="算法基本思想："><a href="#算法基本思想：" class="headerlink" title="算法基本思想："></a>算法基本思想：</h3><p>依路径长度递增的次序来求各个路径。</p><ul><li>长度最短的路径一定是一条从源点直达的弧。</li><li>其他长度的路径求原点到其最短路径一定是以下两种情况之一：<ul><li>源点到此点一条直通弧。</li><li>前面已经求得的最短路径中的其他顶点中到它的直通弧。 </li></ul></li></ul><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"><span class="built_in">string</span> vexs[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(Graph G, <span class="built_in">string</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (G.vexs[i] == v) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(Graph *G)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点数和弧数: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;vexnum &gt;&gt; G-&gt;arcnum;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;vexs[i];</span><br><span class="line">G-&gt;arcs[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">G-&gt;arcs[i][j] = INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;arcnum; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入边的两个顶点, from v1 to v2: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> v1, v2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line"><span class="keyword">int</span> i1 = LocateVex(*G, v1);</span><br><span class="line"><span class="keyword">int</span> i2 = LocateVex(*G, v2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入弧的权值: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;arcs[i1][i2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"图的邻接矩阵是: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"     "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; G.vexs[i] &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; <span class="string">"|"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; G.vexs[(G.vexnum - 1)];</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (G.arcs[i][j] == INT_MAX) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"|"</span> &lt;&lt; setw(<span class="number">5</span>) &lt;&lt; <span class="string">"∞"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;  <span class="string">"|"</span> &lt;&lt; setw(<span class="number">5</span>) &lt;&lt; G.arcs[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"|"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ShortestPath_DIJ</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入想查询到其他点最短距离的起点: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> s0;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s0;</span><br><span class="line"><span class="keyword">int</span> v0 = LocateVex(G, s0);</span><br><span class="line"><span class="keyword">if</span> (v0 &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"wrong!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = G.vexnum;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path[num];</span><br><span class="line"><span class="keyword">int</span> ShortPathTable[num];</span><br><span class="line"><span class="keyword">bool</span> final[num];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">final[i] = <span class="literal">false</span>;</span><br><span class="line">ShortPathTable[i] = G.arcs[v0][i];</span><br><span class="line"><span class="keyword">if</span> (ShortPathTable[i] &lt; INT_MAX) &#123;</span><br><span class="line">path[i].push_back(v0);</span><br><span class="line">path[i].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ShortPathTable[v0] = <span class="number">0</span>;</span><br><span class="line">final[v0] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> min = INT_MAX;</span><br><span class="line"><span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!final[w]) &#123;</span><br><span class="line"><span class="keyword">if</span> (ShortPathTable[w] &lt; min) &#123;</span><br><span class="line">min = ShortPathTable[w];</span><br><span class="line">v = w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">final[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!final[w] &amp;&amp; G.arcs[v][w] &lt; INT_MAX &amp;&amp; min + G.arcs[v][w] &lt; ShortPathTable[w]) &#123;</span><br><span class="line">ShortPathTable[w] = min + G.arcs[v][w];</span><br><span class="line">path[w].clear();</span><br><span class="line">path[w] = path[v];</span><br><span class="line">path[w].push_back(w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != v0) &#123;</span><br><span class="line"><span class="keyword">if</span> (ShortPathTable[i] == INT_MAX) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"从源点"</span> &lt;&lt; G.vexs[v0] &lt;&lt; <span class="string">"到终点"</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="string">"不可达！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"从源点"</span> &lt;&lt; G.vexs[v0] &lt;&lt; <span class="string">"到终点"</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="string">"的最短路径: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.vexs[path[i][<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; path[i].size(); j++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; G.vexs[path[i][j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"其最短长度为: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ShortPathTable[i] &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">Graph G;</span><br><span class="line">CreateGraph(&amp;G);</span><br><span class="line">Print(G);</span><br><span class="line">ShortestPath_DIJ(G);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现效果："><a href="#实现效果：" class="headerlink" title="实现效果："></a>实现效果：</h3><p><img src="https://img-blog.csdnimg.cn/20190124131851876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019012413194120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从某个顶点出发到其他所有各点的最短路径&lt;strong&gt;迪杰斯特拉算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据结构采用有向图的邻接矩阵存储。&lt;/p&gt;
&lt;h3 id=&quot;算法基本思想：&quot;&gt;&lt;a href=&quot;#算法基本思想：&quot; class=&quot;headerlink&quot; title=&quot;算法
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>内存管理||物理内存</title>
    <link href="http://yoursite.com/2019/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/07/08/内存管理/</id>
    <published>2019-07-08T06:54:30.000Z</published>
    <updated>2019-07-08T06:55:50.166Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内存管理的层次"><a href="#内存管理的层次" class="headerlink" title="内存管理的层次"></a>内存管理的层次</h3><p><img src="https://img-blog.csdnimg.cn/20190708143143780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="内存管理的目标"><a href="#内存管理的目标" class="headerlink" title="内存管理的目标"></a>内存管理的目标</h3><ul><li>抽象：<ul><li>逻辑地址空间（不考虑底层细节，只需访问一个连续的地址空间）</li></ul></li><li>保护：<ul><li>独立地址空间（不会被别的进程破坏）</li></ul></li><li>共享<ul><li>访问相同内存（进程间数据传递）</li></ul></li><li>虚拟化<ul><li>更多的地址空间（把最需要的数据放入内存，暂时不需要的数据放到磁盘）</li></ul></li></ul><h3 id="地址空间-amp-地址生成"><a href="#地址空间-amp-地址生成" class="headerlink" title="地址空间 &amp; 地址生成"></a>地址空间 &amp; 地址生成</h3><ul><li>物理地址空间</li><li>逻辑地址空间</li></ul><h4 id="地址空间定义："><a href="#地址空间定义：" class="headerlink" title="地址空间定义："></a>地址空间定义：</h4><p>物理地址空间：主存和磁盘等硬件直接管理的地址空间</p><p>逻辑地址空间：运行的应用程序直接看到一维的线性地址空间</p><p>操作系统将逻辑地址空间映射到实际的地址空间</p><h4 id="逻辑地址空间的生成："><a href="#逻辑地址空间的生成：" class="headerlink" title="逻辑地址空间的生成："></a>逻辑地址空间的生成：</h4><p>c语言–<strong>编译</strong>–&gt;汇编语言–<strong>汇编</strong>–&gt;机器语言(.o文件)–<strong>链接</strong>–&gt;可执行文件(.exe)–<strong>载入(loader)</strong>/<strong>程序重定位</strong>–&gt;加载到内存中去运行</p><p>c/汇编语言内的变量名和函数名实际就是地址，是名字</p><p>机器语言内已将变量符号名和函数符号名等转化为相应的相对连续的地址空间(逻辑地址空间)，是地址的二进制</p><h4 id="逻辑地址和物理地址的对应："><a href="#逻辑地址和物理地址的对应：" class="headerlink" title="逻辑地址和物理地址的对应："></a>逻辑地址和物理地址的对应：</h4><p>CPU的内存管理单元(MMU)中有物理地址和逻辑地址的对应关系表，当CPU要取指或数据是则根据逻辑地址查表前往对应的物理地址去取出</p><p>操作系统负责建立物理地址空间和逻辑地址空间的映射关系(建表)，存在内存中，为了加快访问放在CPU中进行缓存。</p><h3 id="连续内存分配："><a href="#连续内存分配：" class="headerlink" title="连续内存分配："></a>连续内存分配：</h3><h4 id="内存碎片："><a href="#内存碎片：" class="headerlink" title="内存碎片："></a>内存碎片：</h4><p>空闲内存不能被利用</p><ul><li>外部碎片：在分配单元之间的未使用的内存</li><li>内部碎片：在分配单元内未使用的内存</li></ul><h4 id="分区的动态分配："><a href="#分区的动态分配：" class="headerlink" title="分区的动态分配："></a>分区的动态分配：</h4><ul><li>将应用程序加载到内存时，需要为应用程序分配内存空间</li><li>应用程序在运行时，需要访问数据，要给这些数据分配内存空间</li></ul><h5 id="分配策略："><a href="#分配策略：" class="headerlink" title="分配策略："></a>分配策略：</h5><ul><li>首次适配：简单，产生外部碎片，大的内存块集中在内存尾部</li><li>最佳适配：重分配慢，和应用程序所需内存差值最小的内存块，产生小的外部碎片，不易于后续的回收</li><li>最差适配：重分配慢，寻找和所需内存差值最大的内存块，对大块的请求造成影响</li></ul><h4 id="减少内存碎片的方法："><a href="#减少内存碎片的方法：" class="headerlink" title="减少内存碎片的方法："></a>减少内存碎片的方法：</h4><p>压缩式碎片整理</p><p>交换式碎片整理(换入换出)</p><ul><li>充分应用硬盘，抢占正在等待的程序，将等待的程序载入硬盘上去，并回收他们的内存。</li></ul><h4 id="伙伴系统："><a href="#伙伴系统：" class="headerlink" title="伙伴系统："></a>伙伴系统：</h4><ul><li>整个可分配的分区大小 2^U</li><li>需要的分区大小为 2^(U-1) &lt; s &lt;= 2^U 时，把整个块分配给该进程<ul><li>如 s &lt;= 2^(i-1) ，将大小为 2i 的当前空闲分区划分成两个大小为 2^(i-1) 的空闲分区</li><li>重复划分过程，直到 2^(i-1) &lt; s &lt;= 2^i ，并把一个空闲分区分配给该进程</li></ul></li></ul><h5 id="伙伴系统的实现"><a href="#伙伴系统的实现" class="headerlink" title="伙伴系统的实现"></a>伙伴系统的实现</h5><ul><li>数据结构<ul><li>空闲块按大小和起始地址组织成二维数组</li><li>初始状态：只有一个大小为 2^U 的空闲块</li></ul></li><li>分配过程<ul><li>由小到大在空闲块数组中找最小的可用空闲块</li><li>如空闲块过大，对可用空闲块进行二等分，知道得到合适的可用空闲块</li></ul></li><li>释放过程<ul><li>把释放的块放入空闲块数组</li><li>合并满足合并条件的空闲块</li></ul></li><li>合并条件<ul><li>大小相同 2^i</li><li>地址相邻</li><li>起始地址较小的块的起始地址必须是 2^(i+1) 的倍数</li></ul></li></ul><h3 id="非连续的内存分配："><a href="#非连续的内存分配：" class="headerlink" title="非连续的内存分配："></a>非连续的内存分配：</h3><p>非连续内存分配方法：</p><ul><li>一个程序的物理地址空间是非连续的</li><li>更好的内存利用和利用，减少内碎片和外碎片</li><li>允许共享代码和数据(共享库等…)</li><li>支持动态加载和动态链接</li></ul><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>将程序的不同段分散到多个物理地址中去</p><ul><li><p>连续的逻辑地址映射到不连续的物理地址中去</p></li><li><p>例如c程序中栈段，堆段，代码段，数据段</p></li></ul><h5 id="寻址方案的实现："><a href="#寻址方案的实现：" class="headerlink" title="寻址方案的实现："></a>寻址方案的实现：</h5><p>段访问机制：</p><ul><li>段号<ul><li>查询段表查找所对应物理内存的起始地址</li><li>通过段表还可以查询到段的长度限制</li></ul></li><li>段内偏移<ul><li>段偏移和段长度进行比较，若偏移超出段长，则该逻辑地址无效，抛出异常</li></ul></li></ul><p>PS：分段机制类似之前的动态分区，也会产生外部碎片，但是因为程序分布在不连续的物理地址空间，所以产生的外部碎片大大减小了。</p><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>分页分为页寻址和页帧寻址两部分</p><ul><li>页帧(物理地址的寻址)</li><li>页(逻辑地址的寻址)</li></ul><p>分页寻址机制：</p><ul><li>页映射到帧</li><li>页是连续的虚拟内存</li><li>帧是非连续的物理内存</li><li>不是所有的页都有对应的帧</li></ul><p><img src="https://img-blog.csdnimg.cn/20190708143056309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>根据逻辑地址获取页号p–&gt;查询页表根据页号查到帧号f—&gt;f和逻辑地址中的偏移量o结合为物理地址–&gt;[2^(o的位数，例如图中为9)*f+o] 即为所需要数据所在的物理地址</p><p>PS：采用分页机制类似之前的固定分区，但分页技术的分区相当小，一个程序可以占据不连续的多个分区，因而大大减小了内部碎片，提高了内存利用率。</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><ul><li>每个进程有一个页表<ul><li>页表岁进程运行状态的变化而动态变化</li><li>页表基址寄存器存储页表在内存中的地址</li></ul></li></ul><h5 id="页存储管理机制存在性能问题："><a href="#页存储管理机制存在性能问题：" class="headerlink" title="页存储管理机制存在性能问题："></a>页存储管理机制存在性能问题：</h5><ul><li>访问一个内存单元需要访问2次内存（访问页表项，访问数据）</li><li>页表可能非常大</li></ul><p><strong>解决方法：</strong></p><ul><li>建立快表(TLB)</li><li>多级页表</li><li>反向页表</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;内存管理的层次&quot;&gt;&lt;a href=&quot;#内存管理的层次&quot; class=&quot;headerlink&quot; title=&quot;内存管理的层次&quot;&gt;&lt;/a&gt;内存管理的层次&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201907081431
      
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>求连通图的关节点</title>
    <link href="http://yoursite.com/2019/07/08/%E6%B1%82%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E5%85%B3%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2019/07/08/求连通图的关节点/</id>
    <published>2019-07-08T02:48:57.000Z</published>
    <updated>2019-07-08T02:49:45.814Z</updated>
    
    <content type="html"><![CDATA[<p><strong>对图的存储结构基于无向图的邻接多重表。</strong></p><h3 id="关节点和重连通图："><a href="#关节点和重连通图：" class="headerlink" title="关节点和重连通图："></a>关节点和重连通图：</h3><p>假若在删去顶点v以及v相关联的各边之后，将图的一个连通分量分割成两个或两个以上的连通分量，则称顶点v为该图的一个<strong>关节点</strong>。</p><p>如果没有关节点的连通图则称为<strong>重连通图(双连通图)</strong>。</p><h3 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h3><h5 id="1-方法一："><a href="#1-方法一：" class="headerlink" title="1. 方法一："></a>1. 方法一：</h5><p>最简单也是最直接的算法是，删除一个点然后判断连通性，如果删除此点，图不再连通，则此点是关节点，反之不是关节点（图的连通性一般通过深搜来判定，是否能一次搜索完全部顶点）；</p><h5 id="2-方法二："><a href="#2-方法二：" class="headerlink" title="2. 方法二："></a>2. 方法二：</h5><p>通过深搜优先生成树来判定。从任一点出发深度优先遍历得到优先生成树，对于树中任一顶点Ｖ而言，其孩子节点为邻接点。由深度优先生成树可得出两类邻接点的特性：</p><p>（１）若生成树的根有两棵或两棵以上的子树，则此根顶点必为邻接点。因为图中不存在连接不同子树顶点的边，若删除此节点，则树便成为森林；</p><p>（２）若生成树中某个非叶子顶点V，其某棵子树的根和子树中的其他节点均没有指向V的祖先的回边，则V为割点。因为删去v，则其子树和图的其它部分被分割开来。</p><p>仍然利用深搜算法，只不过在这里定义visit[v]表示为深度优先搜索遍历图时访问顶点v的次序号，也就是第1，2，3…次访问，定义low[v]=Min{visit[v]，low[w]，visit[k]}，其中w是顶点v在深度优先生成树上的孩子节点；k是顶点v在深度优先生成树上由回边联结的祖先节点。</p><p><strong>关节点判定条件</strong>：如果对于某个顶点v，存在孩子节点w且low[w]&gt;=visit[v]，则该顶点v必为关节点。因为当w是v的孩子节点时，low[w]&gt;=visit[v]，表明w及其子孙均无指向v的祖先的回边，那么当删除顶点v后，v的孩子节点将于其他节点被分割开来，从来形成新的连通分量。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EBox</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> ivex, jvex; <span class="comment">//该边依附的两个顶点位置</span></span><br><span class="line">EBox *ilink, *jlink; <span class="comment">//分别指向依附这两个顶点的下一条边</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VexBox</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> visit; <span class="comment">//访问标记</span></span><br><span class="line"><span class="keyword">int</span> low; <span class="comment">//Low函数标记</span></span><br><span class="line"><span class="built_in">string</span> data;</span><br><span class="line">EBox *firstedge; <span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMLGraph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">VexBox adjmulist[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">int</span> vexnum, edgenum; <span class="comment">//无向图的当前顶点数和边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(VexBox adj[], <span class="keyword">int</span> num, <span class="built_in">string</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (adj[i].data == v) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(AMLGraph *G)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点数和弧数: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;vexnum &gt;&gt; G-&gt;edgenum;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;adjmulist[i].data;</span><br><span class="line">G-&gt;adjmulist[i].firstedge = <span class="literal">NULL</span>;</span><br><span class="line">G-&gt;adjmulist[i].visit = <span class="number">0</span>;</span><br><span class="line">G-&gt;adjmulist[i].low = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;edgenum; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入边的两个顶点: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> v1, v2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line"><span class="keyword">int</span> i1 = LocateVex(G-&gt;adjmulist, G-&gt;vexnum, v1);</span><br><span class="line"><span class="keyword">int</span> i2 = LocateVex(G-&gt;adjmulist, G-&gt;vexnum, v2);</span><br><span class="line">EBox *p = <span class="keyword">new</span> EBox;</span><br><span class="line">p-&gt;ivex = i1;</span><br><span class="line">p-&gt;jvex = i2;</span><br><span class="line">p-&gt;ilink = G-&gt;adjmulist[i1].firstedge;</span><br><span class="line">p-&gt;jlink = G-&gt;adjmulist[i2].firstedge;</span><br><span class="line">G-&gt;adjmulist[i1].firstedge = p;</span><br><span class="line">G-&gt;adjmulist[i2].firstedge = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex</span><span class="params">(AMLGraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = v;</span><br><span class="line"><span class="keyword">if</span> (G.adjmulist[i].firstedge) &#123;</span><br><span class="line"><span class="keyword">if</span> (G.adjmulist[i].firstedge-&gt;ivex == i) &#123;</span><br><span class="line"><span class="keyword">return</span> G.adjmulist[i].firstedge-&gt;jvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> G.adjmulist[i].firstedge-&gt;ivex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v是G中的某个顶点，w是v的邻接顶点</span></span><br><span class="line"><span class="comment">//返回v的(相对于w的)下一个邻接顶点。若w是v的最后一个邻接点，则返回空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextAdjVex</span><span class="params">(AMLGraph G, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i1 = v;</span><br><span class="line"><span class="keyword">int</span> i2 = w;</span><br><span class="line">EBox *p = G.adjmulist[i1].firstedge;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;ivex == i1 &amp;&amp; p-&gt;jvex != i2) &#123;</span><br><span class="line">p = p-&gt;ilink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;ivex != i2 &amp;&amp; p-&gt;jvex == i1) &#123;</span><br><span class="line">p = p-&gt;jlink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; p-&gt;ivex == i1 &amp;&amp; p-&gt;jvex == i2) &#123;</span><br><span class="line">p = p-&gt;ilink;</span><br><span class="line"><span class="keyword">if</span> (p&amp;&amp;p-&gt;ivex == i1) &#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;jvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p&amp;&amp;p-&gt;jvex == i1)</span><br><span class="line"><span class="keyword">return</span> p-&gt;ivex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; p-&gt;ivex == i2 &amp;&amp; p-&gt;jvex == i1) &#123;</span><br><span class="line">p = p-&gt;jlink;</span><br><span class="line"><span class="keyword">if</span> (p&amp;&amp;p-&gt;ivex == i1) &#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;jvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p&amp;&amp;p-&gt;jvex == i1)</span><br><span class="line"><span class="keyword">return</span> p-&gt;ivex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AMLGraph *G, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G-&gt;adjmulist[i].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">G-&gt;adjmulist[i].visit += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = FirstAdjVex(*G, i); w &gt;= <span class="number">0</span>; w = NextAdjVex(*G,i,w)) &#123;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;adjmulist[w].visit == <span class="number">0</span>) &#123;</span><br><span class="line">DFS(G, w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(AMLGraph *G)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;adjmulist[i].visit == <span class="number">0</span>) &#123;</span><br><span class="line">DFS(G, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearVisited</span><span class="params">(AMLGraph *G)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line">G-&gt;adjmulist[i].visit = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSArticul</span><span class="params">(AMLGraph *G, <span class="keyword">int</span> v0, <span class="keyword">int</span> *count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">G-&gt;adjmulist[v0].visit = min = ++(*count); <span class="comment">//v是第count个被访问的点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = FirstAdjVex(*G, v0); w &gt;= <span class="number">0</span>; w = NextAdjVex(*G, v0, w)) &#123;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;adjmulist[w].visit == <span class="number">0</span>) &#123;</span><br><span class="line">DFSArticul(G, w, count); <span class="comment">//返回前求得low[w]</span></span><br><span class="line"><span class="keyword">if</span> (G-&gt;adjmulist[w].low &lt; min) &#123;</span><br><span class="line">min = G-&gt;adjmulist[w].low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;adjmulist[w].low &gt;= G-&gt;adjmulist[v0].visit) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G-&gt;adjmulist[v0].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (G-&gt;adjmulist[w].visit &lt; min) &#123;</span><br><span class="line">min = G-&gt;adjmulist[w].visit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">G-&gt;adjmulist[v0].low = min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindArticul</span><span class="params">(AMLGraph *G)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">G-&gt;adjmulist[<span class="number">0</span>].visit = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> v = FirstAdjVex(*G, <span class="number">0</span>);</span><br><span class="line">DFSArticul(G, v, &amp;count);</span><br><span class="line"><span class="comment">//根是关节点</span></span><br><span class="line"><span class="keyword">if</span> (count &lt; G-&gt;vexnum) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G-&gt;adjmulist[<span class="number">0</span>].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (v &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">v = NextAdjVex(*G, <span class="number">0</span>, v);</span><br><span class="line"><span class="keyword">if</span> (G-&gt;adjmulist[v].visit == <span class="number">0</span>) &#123;</span><br><span class="line">DFSArticul(G, v, &amp;count);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">AMLGraph g;</span><br><span class="line">CreateGraph(&amp;g);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"深度优先遍历: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">DFSTraverse(&amp;g);</span><br><span class="line">clearVisited(&amp;g);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"关节点有: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">FindArticul(&amp;g);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现效果："><a href="#实现效果：" class="headerlink" title="实现效果："></a>实现效果：</h3><p><img src="https://img-blog.csdnimg.cn/20190123145721735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;对图的存储结构基于无向图的邻接多重表。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;关节点和重连通图：&quot;&gt;&lt;a href=&quot;#关节点和重连通图：&quot; class=&quot;headerlink&quot; title=&quot;关节点和重连通图：&quot;&gt;&lt;/a&gt;关节点和重连通图：&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c++实现Prim算法和Kruskal算法</title>
    <link href="http://yoursite.com/2019/07/08/c-%E5%AE%9E%E7%8E%B0Prim%E7%AE%97%E6%B3%95%E5%92%8CKruskal%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/07/08/c-实现Prim算法和Kruskal算法/</id>
    <published>2019-07-08T02:47:37.000Z</published>
    <updated>2019-07-08T02:48:21.678Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Prim算法和Kruskal都是典型的贪心算法，也就是在求解最小生成树时，我们总是不从全局考虑，而每次仅仅是考虑局部最优解。下面的算法都基于无向图的邻接多重表。</strong></p><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法:"></a>Prim算法:</h2><h3 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h3><h4 id="基本步骤："><a href="#基本步骤：" class="headerlink" title="基本步骤："></a>基本步骤：</h4><p>设R是有n个定点的对称连通关系。</p><ul><li>1）选取R的一个定点v1，设V = {v1}， E={}。</li><li>2）选取与vj ∈ V邻接的V的最近邻元vi， 并且边（vi, vj)不与E中元素形成回路。添加vi到V中，添加(vi, vj)到E中。</li><li>重复2），知道|E|=n - 1,于是V包含R的所有n个定点，E包含R的最小生成树。<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找无向图的最小生成树的Prim算法</span></span><br><span class="line"><span class="comment">//最小生成树：对于n个顶点，找到n-1条边</span></span><br><span class="line"><span class="comment">//选一个任意一点出发作为生成树的根，之后往树上添加顶点，使得两点之间存在一条边，并且该边权值再所有两点之间可选边中取最小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">enum</span> VisitIf &#123;unvisited, visited&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EBox</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> ivex, jvex; <span class="comment">//该边依附的两个顶点位置</span></span><br><span class="line">EBox *ilink, *jlink; <span class="comment">//分别指向依附这两个顶点的下一条边</span></span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VexBox</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> data;</span><br><span class="line">EBox *firstedge; <span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">VisitIf mark; <span class="comment">//访问标记</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMLGraph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">VexBox adjmulist[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">int</span> vexnum, edgenum; <span class="comment">//无向图的当前顶点数和边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(VexBox adj[], <span class="keyword">int</span> num, <span class="built_in">string</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (adj[i].data == v) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(AMLGraph *G)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点数和弧数: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;vexnum &gt;&gt; G-&gt;edgenum;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;adjmulist[i].data;</span><br><span class="line">G-&gt;adjmulist[i].mark = unvisited;</span><br><span class="line">G-&gt;adjmulist[i].firstedge = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;edgenum; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入边的两个顶点以及此边的权重: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> v1, v2;</span><br><span class="line"><span class="keyword">int</span> vw;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; vw;</span><br><span class="line"><span class="keyword">int</span> i1 = LocateVex(G-&gt;adjmulist, G-&gt;vexnum, v1);</span><br><span class="line"><span class="keyword">int</span> i2 = LocateVex(G-&gt;adjmulist, G-&gt;vexnum, v2);</span><br><span class="line"><span class="comment">//cout &lt;&lt; i1 &lt;&lt; "...." &lt;&lt; i2 &lt;&lt; endl;</span></span><br><span class="line">EBox *p = <span class="keyword">new</span> EBox;</span><br><span class="line">p-&gt;ivex = i1;</span><br><span class="line">p-&gt;jvex = i2;</span><br><span class="line">p-&gt;weight = vw;</span><br><span class="line">p-&gt;ilink = G-&gt;adjmulist[i1].firstedge;</span><br><span class="line">p-&gt;jlink = G-&gt;adjmulist[i2].firstedge;</span><br><span class="line">G-&gt;adjmulist[i1].firstedge = p;</span><br><span class="line">G-&gt;adjmulist[i2].firstedge = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex</span><span class="params">(AMLGraph G, <span class="keyword">int</span> v, <span class="keyword">int</span> &amp;wei)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = v;</span><br><span class="line"><span class="keyword">if</span> (G.adjmulist[i].firstedge) &#123;</span><br><span class="line"><span class="keyword">if</span> (G.adjmulist[i].firstedge-&gt;ivex == i) &#123;</span><br><span class="line">wei = G.adjmulist[i].firstedge-&gt;weight;</span><br><span class="line"><span class="keyword">return</span> G.adjmulist[i].firstedge-&gt;jvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">wei = G.adjmulist[i].firstedge-&gt;weight;</span><br><span class="line"><span class="keyword">return</span> G.adjmulist[i].firstedge-&gt;ivex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v是G中的某个顶点，w是v的邻接顶点</span></span><br><span class="line"><span class="comment">//返回v的(相对于w的)下一个邻接顶点。若w是v的最后一个邻接点，则返回空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextAdjVex</span><span class="params">(AMLGraph G, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> &amp;wei)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i1 = v;</span><br><span class="line"><span class="keyword">int</span> i2 = w;</span><br><span class="line">EBox *p = G.adjmulist[i1].firstedge;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;ivex == i1 &amp;&amp; p-&gt;jvex != i2) &#123;</span><br><span class="line">p = p-&gt;ilink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;ivex != i2 &amp;&amp; p-&gt;jvex == i1) &#123;</span><br><span class="line">p = p-&gt;jlink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; p-&gt;ivex == i1 &amp;&amp; p-&gt;jvex == i2) &#123;</span><br><span class="line">p = p-&gt;ilink;</span><br><span class="line"><span class="keyword">if</span> (p&amp;&amp;p-&gt;ivex == i1) &#123;</span><br><span class="line">wei = p-&gt;weight;</span><br><span class="line"><span class="keyword">return</span> p-&gt;jvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p&amp;&amp;p-&gt;jvex == i1) &#123;</span><br><span class="line">wei = p-&gt;weight;</span><br><span class="line"><span class="keyword">return</span> p-&gt;ivex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; p-&gt;ivex == i2 &amp;&amp; p-&gt;jvex == i1) &#123;</span><br><span class="line">p = p-&gt;jlink;</span><br><span class="line"><span class="keyword">if</span> (p&amp;&amp;p-&gt;ivex == i1) &#123;</span><br><span class="line">wei = p-&gt;weight;</span><br><span class="line"><span class="keyword">return</span> p-&gt;jvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p&amp;&amp;p-&gt;jvex == i1) &#123;</span><br><span class="line">wei = p-&gt;weight;</span><br><span class="line"><span class="keyword">return</span> p-&gt;ivex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintGraph</span><span class="params">(AMLGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EBox *p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = G.adjmulist[i].firstedge;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;ivex == i)    <span class="comment">//判断相等才能知道连接上的是ivex还是jvex;</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;  G.adjmulist[p-&gt;ivex].data &lt;&lt; <span class="string">"---"</span> &lt;&lt; p-&gt;weight &lt;&lt; <span class="string">"---"</span> &lt;&lt; G.adjmulist[p-&gt;jvex].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                p = p-&gt;ilink;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt;  G.adjmulist[p-&gt;jvex].data &lt;&lt; <span class="string">"---"</span> &lt;&lt; p-&gt;weight &lt;&lt; <span class="string">"---"</span> &lt;&lt; G.adjmulist[p-&gt;ivex].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                p = p-&gt;jlink;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_PRIM</span><span class="params">(AMLGraph G)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex;</span><br><span class="line"><span class="keyword">int</span> lowcost;</span><br><span class="line">&#125;close[MAX_VERTEX_NUM];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"选择一个顶点出发建立生成树: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> v0;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v0;</span><br><span class="line"><span class="keyword">int</span> i0 = LocateVex(G.adjmulist, G.vexnum, v0);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != i0) &#123;</span><br><span class="line">close[i].adjvex = i0;</span><br><span class="line">close[i].lowcost = INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> wei = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = FirstAdjVex(G, i0, wei); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, i0, w, wei)) &#123;</span><br><span class="line">close[w].lowcost = wei;</span><br><span class="line">&#125;</span><br><span class="line">close[i0].lowcost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> min = INT_MAX;</span><br><span class="line"><span class="keyword">int</span> minadj = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (close[j].lowcost != <span class="number">0</span> &amp;&amp; close[j].lowcost &lt; min) &#123;</span><br><span class="line">minadj = j;</span><br><span class="line">min = close[j].lowcost;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjmulist[minadj].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">close[minadj].lowcost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = FirstAdjVex(G, minadj, wei); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, minadj, w, wei)) &#123;</span><br><span class="line"><span class="keyword">if</span> (close[w].lowcost &gt; wei) &#123;</span><br><span class="line">close[w].adjvex = minadj;</span><br><span class="line">close[w].lowcost = wei;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">AMLGraph g;</span><br><span class="line">CreateGraph(&amp;g);</span><br><span class="line">PrintGraph(g);</span><br><span class="line">MiniSpanTree_PRIM(g);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实现效果："><a href="#实现效果：" class="headerlink" title="实现效果："></a>实现效果：</h4><p><img src="https://img-blog.csdnimg.cn/20190123013919160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法:"></a>Kruskal算法:</h2><ul><li><p>算法是将图中所有的边按权值进行排序，每次取权值最小的边且保证选出的边与生成树已包含的边不构成回路。</p></li><li><p>此算法的关键在于如何判断是否构成回路，这里巧妙地运用了一种叫做并查集的数据结构，也就是到达一个点的出发点，若要新加入的这条边中的两个点的并查集包含相同的出发点，那么这个路径的加入将必然会带来回路，不可取。</p></li></ul><h3 id="算法描述：-1"><a href="#算法描述：-1" class="headerlink" title="算法描述："></a>算法描述：</h3><p>设R是有n个顶点的对称连通关系。S={e1,e2,e3…..ek}是R的加权边集合。</p><p>1）在S中选择最小权的边e1，设E = {e1} 用S- {e1}取代S。<br>2）在S中选最小权的边ei，并且不与E中的元素形成回路。用E∪{ei}代替E，并用S- {ei}取代S。<br>3）重复步骤知道|E|=n-1。</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集:"></a>并查集:</h3><p>我们可以把每个连通分量看成一个集合，该集合包含了连通分量的所有点。而具体的连通方式无关紧要，好比集合中的元素没有先后顺序之分，只有“属于”与“不属于”的区别。图的所有连通分量可以用若干个不相交集合来表示。<br>而并查集的精妙之处在于用数来表示集合。如果把x的父结点保存在uset[x]中(如果没有父亲，uset[x]=x)，则不难写出结点x所在树的递归程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindSet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; uset, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> uset[i] == i ? i : FindSet(uset, uset[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思是，如果uset[x]=x，说明x本身就是树根，因此返回x；否则返回x的父亲uset[x]所在树的根结点。</p><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">enum</span> VisitIf &#123;unvisited, visited&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EBox</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> ivex, jvex; <span class="comment">//该边依附的两个顶点位置</span></span><br><span class="line">EBox *ilink, *jlink; <span class="comment">//分别指向依附这两个顶点的下一条边</span></span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VexBox</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> data;</span><br><span class="line">EBox *firstedge; <span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">VisitIf mark; <span class="comment">//访问标记</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMLGraph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">VexBox adjmulist[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">int</span> vexnum, edgenum; <span class="comment">//无向图的当前顶点数和边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(VexBox adj[], <span class="keyword">int</span> num, <span class="built_in">string</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (adj[i].data == v) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(AMLGraph *G)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点数和弧数: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;vexnum &gt;&gt; G-&gt;edgenum;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;adjmulist[i].data;</span><br><span class="line">G-&gt;adjmulist[i].mark = unvisited;</span><br><span class="line">G-&gt;adjmulist[i].firstedge = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;edgenum; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入边的两个顶点以及此边的权重: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> v1, v2;</span><br><span class="line"><span class="keyword">int</span> vw;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; vw;</span><br><span class="line"><span class="keyword">int</span> i1 = LocateVex(G-&gt;adjmulist, G-&gt;vexnum, v1);</span><br><span class="line"><span class="keyword">int</span> i2 = LocateVex(G-&gt;adjmulist, G-&gt;vexnum, v2);</span><br><span class="line"><span class="comment">//cout &lt;&lt; i1 &lt;&lt; "...." &lt;&lt; i2 &lt;&lt; endl;</span></span><br><span class="line">EBox *p = <span class="keyword">new</span> EBox;</span><br><span class="line">p-&gt;ivex = i1;</span><br><span class="line">p-&gt;jvex = i2;</span><br><span class="line">p-&gt;weight = vw;</span><br><span class="line">p-&gt;ilink = G-&gt;adjmulist[i1].firstedge;</span><br><span class="line">p-&gt;jlink = G-&gt;adjmulist[i2].firstedge;</span><br><span class="line">G-&gt;adjmulist[i1].firstedge = p;</span><br><span class="line">G-&gt;adjmulist[i2].firstedge = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindSet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; uset, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> uset[i] == i ? i : FindSet(uset, uset[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_Kruskal</span><span class="params">(AMLGraph G)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> u;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line">Edge () : u(<span class="number">0</span>), v(<span class="number">0</span>), weight(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">Edge (<span class="keyword">int</span> _u, <span class="keyword">int</span> _v, <span class="keyword">int</span> _weight) &#123;</span><br><span class="line">u = _u;</span><br><span class="line">v = _v;</span><br><span class="line">weight = _weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge e) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;weight &lt; e.weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edg;</span><br><span class="line">EBox *p;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">p = G.adjmulist[i].firstedge;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;ivex == i)    <span class="comment">//判断相等才能知道连接上的是ivex还是jvex;</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">int</span> i1 = LocateVex(G.adjmulist, G.vexnum, G.adjmulist[p-&gt;ivex].data);</span><br><span class="line"><span class="keyword">int</span> i2 = LocateVex(G.adjmulist, G.vexnum, G.adjmulist[p-&gt;jvex].data);</span><br><span class="line"><span class="comment">//cout &lt;&lt; i1 &lt;&lt; i2 &lt;&lt; p-&gt;weight &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (i1 &lt; i2) &#123;</span><br><span class="line">                edg.push_back(Edge(i1, i2, p-&gt;weight));</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;ilink; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">int</span> i1 = LocateVex(G.adjmulist, G.vexnum, G.adjmulist[p-&gt;jvex].data);</span><br><span class="line"><span class="keyword">int</span> i2 = LocateVex(G.adjmulist, G.vexnum, G.adjmulist[p-&gt;ivex].data);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; i1 &lt;&lt; i2 &lt;&lt; p-&gt;weight &lt;&lt; endl;</span></span><br><span class="line">               <span class="keyword">if</span> (i1 &lt; i2) &#123;</span><br><span class="line">                edg.push_back(Edge(i1, i2, p-&gt;weight));</span><br><span class="line">                &#125;</span><br><span class="line">                p = p -&gt; jlink;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(edg.begin(), edg.end());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; uset;</span><br><span class="line">uset.assign(G.vexnum, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">uset[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edg.size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> e1 = FindSet(uset, edg[i].u);</span><br><span class="line"><span class="keyword">int</span> e2 = FindSet(uset, edg[i].v);</span><br><span class="line"><span class="keyword">if</span> (e1 != e2) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjmulist[edg[i].u].data &lt;&lt; <span class="string">"---"</span> &lt;&lt; edg[i].weight &lt;&lt; <span class="string">"---"</span> &lt;&lt; G.adjmulist[edg[i].v].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">uset[e2] = e1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">AMLGraph g;</span><br><span class="line">CreateGraph(&amp;g);</span><br><span class="line">MiniSpanTree_Kruskal(g);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现效果：-1"><a href="#实现效果：-1" class="headerlink" title="实现效果："></a>实现效果：</h4><p><img src="https://img-blog.csdnimg.cn/20190123012930479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Prim算法和Kruskal都是典型的贪心算法，也就是在求解最小生成树时，我们总是不从全局考虑，而每次仅仅是考虑局部最优解。下面的算法都基于无向图的邻接多重表。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Prim算法&quot;&gt;&lt;a href=&quot;#Prim算法&quot; c
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>图的广度优先搜索遍历以及求两点间的最短路径</title>
    <link href="http://yoursite.com/2019/07/08/%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%81%8D%E5%8E%86%E4%BB%A5%E5%8F%8A%E6%B1%82%E4%B8%A4%E7%82%B9%E9%97%B4%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/07/08/图的广度优先搜索遍历以及求两点间的最短路径/</id>
    <published>2019-07-08T02:46:13.000Z</published>
    <updated>2019-07-08T02:47:01.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的广度优先搜索遍历："><a href="#图的广度优先搜索遍历：" class="headerlink" title="图的广度优先搜索遍历："></a>图的广度优先搜索遍历：</h2><ul><li><strong>存储的数据结构为无向图的多重邻接表</strong></li><li><strong>类似于树的层序遍历，依次按照路径为1，2，3…进行遍历，因而每次要获得一个节点然后得到这点的未经访问的邻近点后再将此点抛弃，因此我们用队列这一结构。</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSReverse</span><span class="params">(AMLGraph G)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) &#123;</span><br><span class="line">visit[i] = unvisited;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[i] == unvisited) &#123;</span><br><span class="line">a.push(i);</span><br><span class="line">visit[i] = visited;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjmulist[i].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (!a.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> v = a.front();</span><br><span class="line">a.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, v, w)) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[w] == unvisited) &#123;</span><br><span class="line">a.push(w);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjmulist[w].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">visit[w] = visited;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="求图的任意两点间的最短路径："><a href="#求图的任意两点间的最短路径：" class="headerlink" title="求图的任意两点间的最短路径："></a>求图的任意两点间的最短路径：</h2><p>如下：<br><img src="https://img-blog.csdnimg.cn/20190121194922140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>将队列的结构改为如图所示，即每次不将队列的头部退出队列内而是每次通过移动头部指针来完成，而其他节点都附加一个前向指针(front)，指向引导当前节点的前一个节点，也就是每一次的head。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Node *next;</span><br><span class="line">Node *front;</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFSPath</span><span class="params">(AMLGraph G, <span class="built_in">string</span> v1, <span class="built_in">string</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i1 = LocateVex(G.adjmulist, G.vexnum, v1);</span><br><span class="line"><span class="keyword">int</span> i2 = LocateVex(G.adjmulist, G.vexnum, v2);</span><br><span class="line"><span class="comment">//int num = 0;</span></span><br><span class="line">Node *head;</span><br><span class="line">Node *rear;</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">rear = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) &#123;</span><br><span class="line">visit[i] = unvisited;</span><br><span class="line">&#125;</span><br><span class="line">visit[i1] = visited;</span><br><span class="line">Node *temp = <span class="keyword">new</span> Node;</span><br><span class="line">temp-&gt;data = i1;</span><br><span class="line">temp-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head = rear = temp;</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line"><span class="keyword">int</span> v = head-&gt;data;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, v, w)) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[w] == unvisited) &#123;</span><br><span class="line">Node *temp0 = <span class="keyword">new</span> Node;</span><br><span class="line">temp0-&gt;data = w;</span><br><span class="line">temp0-&gt;front = head;</span><br><span class="line">temp0-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">rear-&gt;next = temp0;</span><br><span class="line">rear = temp0;</span><br><span class="line">visit[w] = visited;</span><br><span class="line"><span class="keyword">if</span> (rear-&gt;data == i2) &#123;</span><br><span class="line">Node *p = rear;</span><br><span class="line"><span class="keyword">while</span>(p) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p = p-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Not Find!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用如下效果图测试："><a href="#用如下效果图测试：" class="headerlink" title="用如下效果图测试："></a>用如下效果图测试：</h3><p><strong>有两个连通图：</strong><br><img src="https://img-blog.csdnimg.cn/20190121214446631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190121214615240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="最后附上全部代码："><a href="#最后附上全部代码：" class="headerlink" title="最后附上全部代码："></a>最后附上全部代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无向图的邻接多重表</span></span><br><span class="line"><span class="comment">//广度优先搜索的实现</span></span><br><span class="line"><span class="comment">//求两个顶点之间一条路径长度最短的路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">enum</span> VisitIf &#123;unvisited, visited&#125;;</span><br><span class="line">VisitIf visit[MAX_VERTEX_NUM];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EBox</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">VisitIf mark; <span class="comment">//访问标记</span></span><br><span class="line"><span class="keyword">int</span> ivex, jvex; <span class="comment">//该边依附的两个顶点位置</span></span><br><span class="line">EBox *ilink, *jlink; <span class="comment">//分别指向依附这两个顶点的下一条边</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VexBox</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> data;</span><br><span class="line">EBox *firstedge; <span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMLGraph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">VexBox adjmulist[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">int</span> vexnum, edgenum; <span class="comment">//无向图的当前顶点数和边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Node *next;</span><br><span class="line">Node *front;</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(VexBox adj[], <span class="keyword">int</span> num, <span class="built_in">string</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (adj[i].data == v) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(AMLGraph *G)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点数和弧数: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;vexnum &gt;&gt; G-&gt;edgenum;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;adjmulist[i].data;</span><br><span class="line">G-&gt;adjmulist[i].firstedge = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;edgenum; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入边的两个顶点: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> v1, v2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line"><span class="keyword">int</span> i1 = LocateVex(G-&gt;adjmulist, G-&gt;vexnum, v1);</span><br><span class="line"><span class="keyword">int</span> i2 = LocateVex(G-&gt;adjmulist, G-&gt;vexnum, v2);</span><br><span class="line"><span class="comment">//cout &lt;&lt; i1 &lt;&lt; "...." &lt;&lt; i2 &lt;&lt; endl;</span></span><br><span class="line">EBox *p = <span class="keyword">new</span> EBox;</span><br><span class="line">p-&gt;mark = unvisited;</span><br><span class="line">p-&gt;ivex = i1;</span><br><span class="line">p-&gt;jvex = i2;</span><br><span class="line">p-&gt;ilink = G-&gt;adjmulist[i1].firstedge;</span><br><span class="line">p-&gt;jlink = G-&gt;adjmulist[i2].firstedge;</span><br><span class="line">G-&gt;adjmulist[i1].firstedge = p;</span><br><span class="line">G-&gt;adjmulist[i2].firstedge = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex</span><span class="params">(AMLGraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = v;</span><br><span class="line"><span class="keyword">if</span> (G.adjmulist[i].firstedge) &#123;</span><br><span class="line"><span class="keyword">if</span> (G.adjmulist[i].firstedge-&gt;ivex == i) &#123;</span><br><span class="line"><span class="keyword">return</span> G.adjmulist[i].firstedge-&gt;jvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> G.adjmulist[i].firstedge-&gt;ivex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v是G中的某个顶点，w是v的邻接顶点</span></span><br><span class="line"><span class="comment">//返回v的(相对于w的)下一个邻接顶点。若w是v的最后一个邻接点，则返回空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextAdjVex</span><span class="params">(AMLGraph G, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i1 = v;</span><br><span class="line"><span class="keyword">int</span> i2 = w;</span><br><span class="line">EBox *p = G.adjmulist[i1].firstedge;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;ivex == i1 &amp;&amp; p-&gt;jvex != i2) &#123;</span><br><span class="line">p = p-&gt;ilink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;ivex != i2 &amp;&amp; p-&gt;jvex == i1) &#123;</span><br><span class="line">p = p-&gt;jlink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; p-&gt;ivex == i1 &amp;&amp; p-&gt;jvex == i2) &#123;</span><br><span class="line">p = p-&gt;ilink;</span><br><span class="line"><span class="keyword">if</span> (p&amp;&amp;p-&gt;ivex == i1) &#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;jvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p&amp;&amp;p-&gt;jvex == i1)</span><br><span class="line"><span class="keyword">return</span> p-&gt;ivex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; p-&gt;ivex == i2 &amp;&amp; p-&gt;jvex == i1) &#123;</span><br><span class="line">p = p-&gt;jlink;</span><br><span class="line"><span class="keyword">if</span> (p&amp;&amp;p-&gt;ivex == i1) &#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;jvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p&amp;&amp;p-&gt;jvex == i1)</span><br><span class="line"><span class="keyword">return</span> p-&gt;ivex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSReverse</span><span class="params">(AMLGraph G)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) &#123;</span><br><span class="line">visit[i] = unvisited;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[i] == unvisited) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"连通图："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">a.push(i);</span><br><span class="line">visit[i] = visited;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjmulist[i].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (!a.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> v = a.front();</span><br><span class="line">a.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, v, w)) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[w] == unvisited) &#123;</span><br><span class="line">a.push(w);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjmulist[w].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">visit[w] = visited;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFSPath</span><span class="params">(AMLGraph G, <span class="built_in">string</span> v1, <span class="built_in">string</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v1 == v2) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the same point!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i1 = LocateVex(G.adjmulist, G.vexnum, v1);</span><br><span class="line"><span class="keyword">int</span> i2 = LocateVex(G.adjmulist, G.vexnum, v2);</span><br><span class="line"><span class="comment">//int num = 0;</span></span><br><span class="line">Node *head;</span><br><span class="line">Node *rear;</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">rear = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) &#123;</span><br><span class="line">visit[i] = unvisited;</span><br><span class="line">&#125;</span><br><span class="line">visit[i1] = visited;</span><br><span class="line">Node *temp = <span class="keyword">new</span> Node;</span><br><span class="line">temp-&gt;data = i1;</span><br><span class="line">temp-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head = rear = temp;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; a;</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line"><span class="keyword">int</span> v = head-&gt;data;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, v, w)) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[w] == unvisited) &#123;</span><br><span class="line">Node *temp0 = <span class="keyword">new</span> Node;</span><br><span class="line">temp0-&gt;data = w;</span><br><span class="line">temp0-&gt;front = head;</span><br><span class="line">temp0-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">rear-&gt;next = temp0;</span><br><span class="line">rear = temp0;</span><br><span class="line">visit[w] = visited;</span><br><span class="line"><span class="keyword">if</span> (rear-&gt;data == i2) &#123;</span><br><span class="line">Node *p = rear;</span><br><span class="line"><span class="keyword">while</span>(p) &#123;</span><br><span class="line">a.push(G.adjmulist[p-&gt;data].data);</span><br><span class="line">p = p-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.top();</span><br><span class="line">a.pop();</span><br><span class="line"><span class="keyword">while</span> (!a.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; a.top();</span><br><span class="line">a.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Not Find!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintGraph</span><span class="params">(AMLGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EBox *p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = G.adjmulist[i].firstedge;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;ivex == i)    <span class="comment">//判断相等才能知道连接上的是ivex还是jvex;</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;  G.adjmulist[p-&gt;ivex].data &lt;&lt; <span class="string">"------"</span> &lt;&lt; G.adjmulist[p-&gt;jvex].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="comment">//printf("%d--%d\n", G.adjmulist[p-&gt;ivex].data, G.adjmulist[p-&gt;jvex].data);</span></span><br><span class="line">                p = p-&gt;ilink;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt;  G.adjmulist[p-&gt;jvex].data &lt;&lt; <span class="string">"------"</span> &lt;&lt; G.adjmulist[p-&gt;ivex].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                p = p-&gt;jlink;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">AMLGraph g;</span><br><span class="line">CreateGraph(&amp;g);</span><br><span class="line"><span class="comment">//PrintGraph(g);</span></span><br><span class="line">BFSReverse(g);</span><br><span class="line"><span class="comment">//DFSTraverse(g);</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">string</span> v1, v2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入你想查询的两点: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">BFSPath(g, v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图的广度优先搜索遍历：&quot;&gt;&lt;a href=&quot;#图的广度优先搜索遍历：&quot; class=&quot;headerlink&quot; title=&quot;图的广度优先搜索遍历：&quot;&gt;&lt;/a&gt;图的广度优先搜索遍历：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;存储的数据结构为无向图的多重邻接表&lt;/s
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>图深度优先搜索遍历以及求两点间的简单路径</title>
    <link href="http://yoursite.com/2019/07/07/%E5%9B%BE%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%81%8D%E5%8E%86%E4%BB%A5%E5%8F%8A%E6%B1%82%E4%B8%A4%E7%82%B9%E9%97%B4%E7%9A%84%E7%AE%80%E5%8D%95%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/07/07/图深度优先搜索遍历以及求两点间的简单路径/</id>
    <published>2019-07-07T12:10:17.000Z</published>
    <updated>2019-07-07T12:11:22.180Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文图的存储结构是基于无向图的邻接多重表实现的</strong></p><h2 id="图的深度优先搜索的递归遍历"><a href="#图的深度优先搜索的递归遍历" class="headerlink" title="图的深度优先搜索的递归遍历"></a>图的深度优先搜索的递归遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AMLGraph G, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjmulist[i].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">visit[i] = visited;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = FirstAdjVex(G, i); w &gt;= <span class="number">0</span>; w = NextAdjVex(G,i,w)) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; w &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span> (visit[w] == unvisited) &#123;</span><br><span class="line">DFS(G, w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(AMLGraph G)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">visit[i] = unvisited;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[i] == unvisited) &#123;</span><br><span class="line">DFS(G, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的深度优先搜索的非递归遍历"><a href="#图的深度优先搜索的非递归遍历" class="headerlink" title="图的深度优先搜索的非递归遍历"></a>图的深度优先搜索的非递归遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFStack</span><span class="params">(AMLGraph G)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">visit[i] = unvisited;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[i] == unvisited) &#123;</span><br><span class="line">visit[i] = visited;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjmulist[i].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">a.push(i);</span><br><span class="line"><span class="keyword">while</span> (!a.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> v = a.top();</span><br><span class="line"><span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G,v,w)) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[w] == unvisited) &#123;</span><br><span class="line">a.push(w);</span><br><span class="line">visit[w] = visited;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjmulist[w].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">find = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (find == <span class="literal">false</span>) &#123;</span><br><span class="line">a.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的深度优先搜索实现查找两点间的简单路径"><a href="#图的深度优先搜索实现查找两点间的简单路径" class="headerlink" title="图的深度优先搜索实现查找两点间的简单路径"></a>图的深度优先搜索实现查找两点间的简单路径</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFSPath</span><span class="params">(AMLGraph G, <span class="built_in">string</span> v1, <span class="built_in">string</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i1 = LocateVex(G.adjmulist, G.vexnum, v1);</span><br><span class="line"><span class="keyword">int</span> i2 = LocateVex(G.adjmulist, G.vexnum, v2);</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">visit[i] = unvisited;</span><br><span class="line">&#125;</span><br><span class="line">visit[i1] = visited;</span><br><span class="line">a.push(i1);</span><br><span class="line">b.push_back(i1);</span><br><span class="line"><span class="keyword">if</span> (i1 == i2) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!a.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> v = a.top();</span><br><span class="line"><span class="keyword">bool</span> adjem = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, v, w)) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[w] == unvisited) &#123;</span><br><span class="line">a.push(w);</span><br><span class="line">b.push_back(w);</span><br><span class="line">visit[w] = visited;</span><br><span class="line"><span class="keyword">if</span> (w == i2) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = b.begin(); iter != b.end(); iter++) &#123;</span><br><span class="line"><span class="keyword">if</span> (iter == b.begin())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjmulist[(*iter)].data;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; G.adjmulist[(*iter)].data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">adjem = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (adjem == <span class="literal">false</span>) &#123;</span><br><span class="line">a.pop();</span><br><span class="line">b.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Not Find!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后附上完整代码："><a href="#最后附上完整代码：" class="headerlink" title="最后附上完整代码："></a>最后附上完整代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无向图的邻接多重表</span></span><br><span class="line"><span class="comment">//深度优先搜索的递归以及非递归实现</span></span><br><span class="line"><span class="comment">//从一节点出发到另一个节点的简单路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">enum</span> VisitIf &#123;unvisited, visited&#125;;</span><br><span class="line">VisitIf visit[MAX_VERTEX_NUM];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EBox</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">VisitIf mark; <span class="comment">//访问标记</span></span><br><span class="line"><span class="keyword">int</span> ivex, jvex; <span class="comment">//该边依附的两个顶点位置</span></span><br><span class="line">EBox *ilink, *jlink; <span class="comment">//分别指向依附这两个顶点的下一条边</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VexBox</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> data;</span><br><span class="line">EBox *firstedge; <span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMLGraph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">VexBox adjmulist[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">int</span> vexnum, edgenum; <span class="comment">//无向图的当前顶点数和边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(VexBox adj[], <span class="keyword">int</span> num, <span class="built_in">string</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (adj[i].data == v) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(AMLGraph *G)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点数和弧数: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;vexnum &gt;&gt; G-&gt;edgenum;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G-&gt;adjmulist[i].data;</span><br><span class="line">G-&gt;adjmulist[i].firstedge = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;edgenum; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入边的两个顶点: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> v1, v2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line"><span class="keyword">int</span> i1 = LocateVex(G-&gt;adjmulist, G-&gt;vexnum, v1);</span><br><span class="line"><span class="keyword">int</span> i2 = LocateVex(G-&gt;adjmulist, G-&gt;vexnum, v2);</span><br><span class="line"><span class="comment">//cout &lt;&lt; i1 &lt;&lt; "...." &lt;&lt; i2 &lt;&lt; endl;</span></span><br><span class="line">EBox *p = <span class="keyword">new</span> EBox;</span><br><span class="line">p-&gt;mark = unvisited;</span><br><span class="line">p-&gt;ivex = i1;</span><br><span class="line">p-&gt;jvex = i2;</span><br><span class="line">p-&gt;ilink = G-&gt;adjmulist[i1].firstedge;</span><br><span class="line">p-&gt;jlink = G-&gt;adjmulist[i2].firstedge;</span><br><span class="line">G-&gt;adjmulist[i1].firstedge = p;</span><br><span class="line">G-&gt;adjmulist[i2].firstedge = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex</span><span class="params">(AMLGraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = v;</span><br><span class="line"><span class="keyword">if</span> (G.adjmulist[i].firstedge) &#123;</span><br><span class="line"><span class="keyword">if</span> (G.adjmulist[i].firstedge-&gt;ivex == i) &#123;</span><br><span class="line"><span class="keyword">return</span> G.adjmulist[i].firstedge-&gt;jvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> G.adjmulist[i].firstedge-&gt;ivex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v是G中的某个顶点，w是v的邻接顶点</span></span><br><span class="line"><span class="comment">//返回v的(相对于w的)下一个邻接顶点。若w是v的最后一个邻接点，则返回空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextAdjVex</span><span class="params">(AMLGraph G, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i1 = v;</span><br><span class="line"><span class="keyword">int</span> i2 = w;</span><br><span class="line">EBox *p = G.adjmulist[i1].firstedge;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;ivex == i1 &amp;&amp; p-&gt;jvex != i2) &#123;</span><br><span class="line">p = p-&gt;ilink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;ivex != i2 &amp;&amp; p-&gt;jvex == i1) &#123;</span><br><span class="line">p = p-&gt;jlink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; p-&gt;ivex == i1 &amp;&amp; p-&gt;jvex == i2) &#123;</span><br><span class="line">p = p-&gt;ilink;</span><br><span class="line"><span class="keyword">if</span> (p&amp;&amp;p-&gt;ivex == i1) &#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;jvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p&amp;&amp;p-&gt;jvex == i1)</span><br><span class="line"><span class="keyword">return</span> p-&gt;ivex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; p-&gt;ivex == i2 &amp;&amp; p-&gt;jvex == i1) &#123;</span><br><span class="line">p = p-&gt;jlink;</span><br><span class="line"><span class="keyword">if</span> (p&amp;&amp;p-&gt;ivex == i1) &#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;jvex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p&amp;&amp;p-&gt;jvex == i1)</span><br><span class="line"><span class="keyword">return</span> p-&gt;ivex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AMLGraph G, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjmulist[i].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">visit[i] = visited;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = FirstAdjVex(G, i); w &gt;= <span class="number">0</span>; w = NextAdjVex(G,i,w)) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; w &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span> (visit[w] == unvisited) &#123;</span><br><span class="line">DFS(G, w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(AMLGraph G)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">visit[i] = unvisited;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[i] == unvisited) &#123;</span><br><span class="line">DFS(G, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFStack</span><span class="params">(AMLGraph G)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">visit[i] = unvisited;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[i] == unvisited) &#123;</span><br><span class="line">visit[i] = visited;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjmulist[i].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">a.push(i);</span><br><span class="line"><span class="keyword">while</span> (!a.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> v = a.top();</span><br><span class="line"><span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G,v,w)) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[w] == unvisited) &#123;</span><br><span class="line">a.push(w);</span><br><span class="line">visit[w] = visited;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjmulist[w].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">find = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (find == <span class="literal">false</span>) &#123;</span><br><span class="line">a.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFSPath</span><span class="params">(AMLGraph G, <span class="built_in">string</span> v1, <span class="built_in">string</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i1 = LocateVex(G.adjmulist, G.vexnum, v1);</span><br><span class="line"><span class="keyword">int</span> i2 = LocateVex(G.adjmulist, G.vexnum, v2);</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">visit[i] = unvisited;</span><br><span class="line">&#125;</span><br><span class="line">visit[i1] = visited;</span><br><span class="line">a.push(i1);</span><br><span class="line">b.push_back(i1);</span><br><span class="line"><span class="keyword">if</span> (i1 == i2) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!a.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> v = a.top();</span><br><span class="line"><span class="keyword">bool</span> adjem = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, v, w)) &#123;</span><br><span class="line"><span class="keyword">if</span> (visit[w] == unvisited) &#123;</span><br><span class="line">a.push(w);</span><br><span class="line">b.push_back(w);</span><br><span class="line">visit[w] = visited;</span><br><span class="line"><span class="keyword">if</span> (w == i2) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = b.begin(); iter != b.end(); iter++) &#123;</span><br><span class="line"><span class="keyword">if</span> (iter == b.begin())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.adjmulist[(*iter)].data;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; G.adjmulist[(*iter)].data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">adjem = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (adjem == <span class="literal">false</span>) &#123;</span><br><span class="line">a.pop();</span><br><span class="line">b.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Not Find!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintGraph</span><span class="params">(AMLGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EBox *p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = G.adjmulist[i].firstedge;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;ivex == i)    <span class="comment">//判断相等才能知道连接上的是ivex还是jvex;</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;  G.adjmulist[p-&gt;ivex].data &lt;&lt; <span class="string">"------"</span> &lt;&lt; G.adjmulist[p-&gt;jvex].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="comment">//printf("%d--%d\n", G.adjmulist[p-&gt;ivex].data, G.adjmulist[p-&gt;jvex].data);</span></span><br><span class="line">                p = p-&gt;ilink;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt;  G.adjmulist[p-&gt;jvex].data &lt;&lt; <span class="string">"------"</span> &lt;&lt; G.adjmulist[p-&gt;ivex].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                p = p-&gt;jlink;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">AMLGraph g;</span><br><span class="line">CreateGraph(&amp;g);</span><br><span class="line">PrintGraph(g);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">string</span> v1, v2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入你想查询的两点: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">DFSPath(g, v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h3><p><img src="https://img-blog.csdnimg.cn/20190121163319289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="遍历："><a href="#遍历：" class="headerlink" title="遍历："></a>遍历：</h4><p><img src="https://img-blog.csdnimg.cn/20190121163600366.png" alt="在这里插入图片描述"></p><h4 id="简单路径："><a href="#简单路径：" class="headerlink" title="简单路径："></a>简单路径：</h4><p><img src="https://img-blog.csdnimg.cn/20190121164053545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文图的存储结构是基于无向图的邻接多重表实现的&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;图的深度优先搜索的递归遍历&quot;&gt;&lt;a href=&quot;#图的深度优先搜索的递归遍历&quot; class=&quot;headerlink&quot; title=&quot;图的深度优先搜索的递归遍历&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="c" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>图像分割进行A4纸矫正</title>
    <link href="http://yoursite.com/2019/07/07/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E8%BF%9B%E8%A1%8CA4%E7%BA%B8%E7%9F%AB%E6%AD%A3/"/>
    <id>http://yoursite.com/2019/07/07/图像分割进行A4纸矫正/</id>
    <published>2019-07-07T11:55:54.000Z</published>
    <updated>2019-07-07T11:56:31.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图像分割进行A4纸矫正"><a href="#图像分割进行A4纸矫正" class="headerlink" title="图像分割进行A4纸矫正"></a>图像分割进行A4纸矫正</h2><h3 id="1-将图像从rgb空间转为灰度空间"><a href="#1-将图像从rgb空间转为灰度空间" class="headerlink" title="(1) 将图像从rgb空间转为灰度空间"></a>(1) 将图像从rgb空间转为灰度空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageSegmentation::rgb2gray() &#123;</span><br><span class="line">grayImg.resize(Img._width, Img._height, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">cimg_forXY(grayImg, x, y) &#123;</span><br><span class="line"><span class="keyword">double</span> R = Img(x,y,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">double</span> G = Img(x,y,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">double</span> B = Img(x,y,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">double</span> Gray = (R * <span class="number">299</span> + G * <span class="number">587</span> + B * <span class="number">114</span> + <span class="number">500</span>) / <span class="number">1000</span>;</span><br><span class="line">grayImg(x,y) = Gray;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-高斯滤波"><a href="#2-高斯滤波" class="headerlink" title="(2) 高斯滤波"></a>(2) 高斯滤波</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageSegmentation::Gauss_blur() &#123;</span><br><span class="line">blurImg = grayImg.get_blur(guassian_blur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-求阈值"><a href="#3-求阈值" class="headerlink" title="(3) 求阈值"></a>(3) 求阈值</h3><h4 id="1-迭代法求阈值"><a href="#1-迭代法求阈值" class="headerlink" title="1. 迭代法求阈值"></a>1. 迭代法求阈值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代法求阈值</span></span><br><span class="line"><span class="keyword">void</span> ImageSegmentation::get_thres_iteration() &#123;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; image = blurImg;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; hist = image.histogram(<span class="number">256</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="keyword">int</span> size = blurImg.size();</span><br><span class="line">cimg_forX(hist, i) &#123;</span><br><span class="line">threshold += i*hist(i);</span><br><span class="line">&#125;</span><br><span class="line">threshold /= size;</span><br><span class="line"><span class="keyword">int</span> threshold_new;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> t1 = <span class="number">0</span>, t2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 计算小于等于阈值threshold的灰度平均值t1以及大于阈值的t2</span></span><br><span class="line">cimg_forX(hist, i) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt;= threshold) &#123;</span><br><span class="line">t1 += i * hist(i);</span><br><span class="line">num1 += hist(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">t2 += i * hist(i);</span><br><span class="line">num2 += hist(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num1 == <span class="number">0</span> || num2 == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">t1 /= num1;</span><br><span class="line">t2 /= num2;</span><br><span class="line">threshold_new = (t1 + t2) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 若两个阈值相等，则返回阈值threshold，否则更新阈值继续循环</span></span><br><span class="line"><span class="keyword">if</span> (threshold == threshold_new) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> threshold = threshold_new;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"threshold = "</span> &lt;&lt; threshold &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-OSTU法求阈值"><a href="#2-OSTU法求阈值" class="headerlink" title="2.OSTU法求阈值"></a>2.OSTU法求阈值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OSTU法求阈值</span></span><br><span class="line"><span class="keyword">void</span> ImageSegmentation::get_thres_ostu() &#123;</span><br><span class="line"><span class="comment">//定义类间方差</span></span><br><span class="line"><span class="keyword">double</span> variance = <span class="number">0.0</span>;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; image = blurImg;</span><br><span class="line">CImg&lt;<span class="keyword">int</span>&gt; hist = image.histogram(<span class="number">256</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="keyword">int</span> size = blurImg.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line"><span class="comment">//定义前景图，背景图的像素点所占比例以及平均灰度</span></span><br><span class="line"><span class="keyword">double</span> p1 = <span class="number">0.0</span>, p2 = <span class="number">0.0</span>, g1 = <span class="number">0.0</span>, g2 = <span class="number">0.0</span>;</span><br><span class="line">cimg_forX(hist, j) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= i) &#123;</span><br><span class="line">p1 += hist(j);</span><br><span class="line">g1 += j*hist(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p2 += hist(j);</span><br><span class="line">g2 += j*hist(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p1 == <span class="number">0</span> || p2 == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">g1 /= p1;</span><br><span class="line">p1 /= size;</span><br><span class="line">g2 /= p2;</span><br><span class="line">p2 /= size;</span><br><span class="line"><span class="keyword">double</span> temp_variance = p1 * p2 * (g1 - g2) * (g1 - g2);</span><br><span class="line"><span class="keyword">if</span> (variance &lt; temp_variance) &#123;</span><br><span class="line">variance = temp_variance;</span><br><span class="line">threshold = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"threshold = "</span> &lt;&lt; threshold &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-按阈值进行图像分割"><a href="#4-按阈值进行图像分割" class="headerlink" title="(4)按阈值进行图像分割"></a>(4)按阈值进行图像分割</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageSegmentation::Segmentation() &#123;</span><br><span class="line">segImg.resize(Img._width, Img._height, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">cimg_forXY(blurImg, x, y) &#123;</span><br><span class="line"><span class="keyword">if</span> (blurImg(x,y) &gt; threshold) &#123;</span><br><span class="line">segImg(x,y) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">segImg(x,y) = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//segImg.display();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-对分割后的图像进行梯度检测"><a href="#5-对分割后的图像进行梯度检测" class="headerlink" title="(5) 对分割后的图像进行梯度检测"></a>(5) 对分割后的图像进行梯度检测</h3><p><strong>PS:如果此时直接进行矫正或者膨胀后膨胀效果不好，所以我们检测一步梯度（采用sobel算子）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageSegmentation::gradDection() &#123;</span><br><span class="line">gradImg.resize(segImg._width, segImg._height, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">CImg_3x3(I, <span class="keyword">double</span>);</span><br><span class="line">cimg_for3x3(segImg, x, y, <span class="number">0</span>, <span class="number">0</span>, I, <span class="keyword">double</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> ix = (Inn + <span class="number">2</span> * Icn + Ipn) - (Ipp + <span class="number">2</span> * Icp + Inp);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> iy = (Inp + <span class="number">2</span> * Inc + Inn) - (Ipp + <span class="number">2</span> * Ipc + Ipn);</span><br><span class="line"><span class="keyword">double</span> grad = <span class="built_in">sqrt</span>(ix * ix + iy * iy);</span><br><span class="line"><span class="keyword">if</span> (grad &gt; <span class="number">255</span>) grad = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">if</span> (grad &lt; <span class="number">0</span> ) grad = <span class="number">0</span>;</span><br><span class="line">gradImg(x, y) = grad;</span><br><span class="line">&#125;</span><br><span class="line">gradImg.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-霍夫变换"><a href="#6-霍夫变换" class="headerlink" title="(6) 霍夫变换"></a>(6) 霍夫变换</h3><h4 id="1-统计霍夫空间点"><a href="#1-统计霍夫空间点" class="headerlink" title="1. 统计霍夫空间点"></a>1. 统计霍夫空间点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageSegmentation::Hough_Statistics() &#123;</span><br><span class="line"><span class="comment">//double maxDistance = sqrt(Img._width*Img._width + Img._height*Img._height);</span></span><br><span class="line"><span class="keyword">double</span> w = Img._width;</span><br><span class="line"><span class="keyword">double</span> h = Img._height;</span><br><span class="line"><span class="keyword">double</span> center_x = w/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> center_y = h/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> hough_h = ((<span class="built_in">sqrt</span>(<span class="number">2.0</span>) * (<span class="keyword">double</span>)(h&gt;w?h:w)) / <span class="number">2.0</span>);</span><br><span class="line">houghImg.resize(<span class="number">180</span>, hough_h * <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">cimg_forXY(gradImg, x, y) &#123;</span><br><span class="line"><span class="keyword">if</span> (gradImg(x,y) != <span class="number">0</span>) &#123;</span><br><span class="line">cimg_forX(houghImg, angle) &#123;</span><br><span class="line"><span class="keyword">double</span> _angle = (<span class="keyword">double</span>)PI*angle / <span class="number">180.0f</span>;</span><br><span class="line"><span class="keyword">int</span> polar = (<span class="keyword">int</span>)((((<span class="keyword">double</span>)x - center_x)*<span class="built_in">cos</span>(_angle) + ((<span class="keyword">double</span>)y - center_y)*<span class="built_in">sin</span>(_angle)) + hough_h);</span><br><span class="line"><span class="comment">//cout &lt;&lt; polar &lt;&lt; endl;</span></span><br><span class="line">houghImg(angle, polar) += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//houghImg.display();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-获取对应检测出的直线"><a href="#2-获取对应检测出的直线" class="headerlink" title="2. 获取对应检测出的直线"></a>2. 获取对应检测出的直线</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageSegmentation::GetLine() &#123;</span><br><span class="line">resultImg = Img;</span><br><span class="line"><span class="comment">//剔除掉可能出现的重合线，方法是取9x9空间内的霍夫最大值</span></span><br><span class="line"><span class="keyword">int</span> hough_h = houghImg._height;</span><br><span class="line"><span class="comment">//int hough_w = houghImg._width;</span></span><br><span class="line"><span class="keyword">int</span> img_h = Img._height;</span><br><span class="line"><span class="keyword">int</span> img_w = Img._width;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y_min = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y_max = Img._height - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x_min = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x_max = Img._width - <span class="number">1</span>;</span><br><span class="line">cimg_forXY(houghImg, angle, polar) &#123;</span><br><span class="line"><span class="keyword">if</span> (houghImg(angle, polar) &gt;= Min_thres) &#123;</span><br><span class="line"><span class="keyword">int</span> max = houghImg(angle, polar);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ly=-DIFF;ly&lt;=DIFF;ly++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> lx=-DIFF;lx&lt;=DIFF;lx++) &#123;</span><br><span class="line"><span class="keyword">if</span>( (ly+polar&gt;=<span class="number">0</span> &amp;&amp; ly+polar&lt;houghImg._height) &amp;&amp; (lx+angle&gt;=<span class="number">0</span> &amp;&amp; lx+angle&lt;houghImg._width) ) &#123;</span><br><span class="line"><span class="keyword">if</span>( (<span class="keyword">int</span>)houghImg(angle + lx, polar + ly ) &gt; max ) &#123;</span><br><span class="line">max = houghImg(angle + lx, polar + ly );</span><br><span class="line">ly = lx = DIFF + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (max &gt; (<span class="keyword">int</span>)houghImg(angle, polar) )</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">peaks.push_back(pair&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span> &gt;(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(angle, polar), houghImg(angle, polar)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(peaks.begin(), peaks.end(), [](<span class="keyword">const</span> pair&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span> &gt; &amp;a, <span class="keyword">const</span> pair&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span> &gt; &amp;b) -&gt; <span class="keyword">int</span> &#123;<span class="keyword">return</span> a.second &gt; b.second ;&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; lines.size() != <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> angle = peaks[i].first.first;</span><br><span class="line"><span class="keyword">int</span> polar = peaks[i].first.second;</span><br><span class="line"><span class="comment">//cout &lt;&lt; angle &lt;&lt; endl &lt;&lt; polar &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">x1 = y1 = x2 = y2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> _angle = (<span class="keyword">double</span>)PI*angle / <span class="number">180.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(angle &gt;= <span class="number">45</span> &amp;&amp; angle &lt;= <span class="number">135</span>) &#123;</span><br><span class="line">x1 = <span class="number">0</span>;</span><br><span class="line">y1 = ((<span class="keyword">double</span>)(polar-(hough_h/<span class="number">2</span>)) - ((x1 - (img_w/<span class="number">2</span>) ) * <span class="built_in">cos</span>(_angle))) / <span class="built_in">sin</span>(_angle) + (img_h / <span class="number">2</span>);</span><br><span class="line">x2 = img_w;</span><br><span class="line">y2 = ((<span class="keyword">double</span>)(polar-(hough_h/<span class="number">2</span>)) - ((x2 - (img_w/<span class="number">2</span>) ) * <span class="built_in">cos</span>(_angle))) / <span class="built_in">sin</span>(_angle) + (img_h / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">y1 = <span class="number">0</span>;</span><br><span class="line">x1 = ((<span class="keyword">double</span>)(polar-(hough_h/<span class="number">2</span>)) - ((y1 - (img_h/<span class="number">2</span>) ) * <span class="built_in">sin</span>(_angle))) / <span class="built_in">cos</span>(_angle) + (img_w / <span class="number">2</span>);</span><br><span class="line">y2 = img_h;</span><br><span class="line">x2 = ((<span class="keyword">double</span>)(polar-(hough_h/<span class="number">2</span>)) - ((y2 - (img_h/<span class="number">2</span>) ) * <span class="built_in">sin</span>(_angle))) / <span class="built_in">cos</span>(_angle) + (img_w / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; lines.size(); k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (distance(lines[k].first.first - x1, lines[k].first.second - y1) &lt; <span class="number">100</span> &amp;&amp; distance(lines[k].second.first - x2, lines[k].second.second - y2) &lt; <span class="number">100</span>) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">lines.push_back(pair&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(x1, y1), pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(x2, y2)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lines.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; lines[i].first.first &lt;&lt; <span class="string">", "</span> &lt;&lt; lines[i].first.second &lt;&lt; <span class="string">"  ..  "</span> &lt;&lt; lines[i].second.first &lt;&lt; <span class="string">", "</span> &lt;&lt; lines[i].second.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">resultImg.draw_line(lines[i].first.first, lines[i].first.second, lines[i].second.first, lines[i].second.second, Red);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//resultImg.draw_line(200, 3458, 2500, 3459, Red);</span></span><br><span class="line"><span class="comment">//resultImg.display();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-获得四个角点"><a href="#3-获得四个角点" class="headerlink" title="3.  获得四个角点"></a>3.  获得四个角点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageSegmentation::GetVertexs() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lines.size(); i++) &#123;</span><br><span class="line"><span class="keyword">double</span> k0, b0;</span><br><span class="line"><span class="keyword">if</span> (lines[i].first.first == lines[i].second.first) &#123;</span><br><span class="line">k0 = DBL_MAX;</span><br><span class="line">b0 = lines[i].first.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">k0 = (<span class="keyword">double</span>) (lines[i].first.second - lines[i].second.second) / (lines[i].first.first - lines[i].second.first);</span><br><span class="line">b0 = (<span class="keyword">double</span>) (lines[i].first.second * lines[i].second.first - lines[i].second.second * lines[i].first.first) / (lines[i].second.first - lines[i].first.first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; lines.size(); j++) &#123;</span><br><span class="line"><span class="keyword">double</span> k1, b1;</span><br><span class="line"><span class="keyword">if</span> (lines[j].first.first == lines[j].second.first) &#123;</span><br><span class="line">k1 = DBL_MAX;</span><br><span class="line">b1 = lines[j].first.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">k1 = (<span class="keyword">double</span>) (lines[j].first.second - lines[j].second.second) / (lines[j].first.first - lines[j].second.first);</span><br><span class="line">b1 = (<span class="keyword">double</span>) (lines[j].first.second * lines[j].second.first - lines[j].second.second * lines[j].first.first) / (lines[j].second.first - lines[j].first.first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k0 == k1)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (k0 == DBL_MAX) &#123;</span><br><span class="line"><span class="keyword">int</span> _x = b0, _y = k1 * b0 + b1;</span><br><span class="line"><span class="keyword">if</span> (_x &gt;= <span class="number">0</span> &amp;&amp; _x &lt; Img._width &amp;&amp; _y &gt;= <span class="number">0</span> &amp;&amp; _y &lt; Img._height)</span><br><span class="line">vertex.push_back(make_pair(_x, _y));</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k1 == DBL_MAX) &#123;</span><br><span class="line"><span class="keyword">int</span> _x = b1, _y = k0 * b1 + b0;</span><br><span class="line"><span class="keyword">if</span> (_x &gt;= <span class="number">0</span> &amp;&amp; _x &lt; Img._width &amp;&amp; _y &gt;= <span class="number">0</span> &amp;&amp; _y &lt; Img._height)</span><br><span class="line">vertex.push_back(make_pair(_x, _y));</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _x = (b0 - b1) / (k1 - k0);</span><br><span class="line"><span class="keyword">int</span> _y = (k0 * b1 - k1 * b0) / (k0 - k1);</span><br><span class="line"><span class="keyword">if</span> (_x &gt;= <span class="number">0</span> &amp;&amp; _x &lt; Img._width &amp;&amp; _y &gt;= <span class="number">0</span> &amp;&amp; _y &lt; Img._height)</span><br><span class="line">vertex.push_back(make_pair(_x, _y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertex.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; vertex[i].first &lt;&lt; <span class="string">"  ...  "</span> &lt;&lt; vertex[i].second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">resultImg.draw_circle(vertex[i].first, vertex[i].second, <span class="number">50</span>, Red);</span><br><span class="line">&#125;</span><br><span class="line">resultImg.display();</span><br><span class="line">resultImg.save(<span class="string">"result_a.bmp"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-对获得的角点进行排序："><a href="#7-对获得的角点进行排序：" class="headerlink" title="(7) 对获得的角点进行排序："></a>(7) 对获得的角点进行排序：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageSegmentation::orderVertexs() &#123;</span><br><span class="line">sort(vertex.begin(), vertex.end(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)-&gt; <span class="keyword">int</span> &#123;<span class="keyword">return</span> distance(a.first, a.second) &lt; distance(b.first, b.second);&#125;);</span><br><span class="line"><span class="keyword">double</span> w = distance(vertex[<span class="number">0</span>].first - vertex[<span class="number">1</span>].first, vertex[<span class="number">0</span>].second - vertex[<span class="number">1</span>].second);</span><br><span class="line"><span class="keyword">double</span> h = distance(vertex[<span class="number">0</span>].first - vertex[<span class="number">2</span>].first, vertex[<span class="number">0</span>].second - vertex[<span class="number">2</span>].second);</span><br><span class="line"><span class="comment">//纸张是横向的</span></span><br><span class="line"><span class="keyword">if</span> (vertex[<span class="number">1</span>].first &lt; vertex[<span class="number">2</span>].first &amp;&amp; h &gt; w) &#123;</span><br><span class="line">swap(vertex[<span class="number">1</span>], vertex[<span class="number">2</span>]);</span><br><span class="line">swap(vertex[<span class="number">2</span>], vertex[<span class="number">3</span>]);</span><br><span class="line">vertex.push_back(vertex[<span class="number">0</span>]);</span><br><span class="line">vertex.erase(vertex.begin());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//纸张是竖向的</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">swap(vertex[<span class="number">2</span>], vertex[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-得到用于矫正A4纸的特征矩阵"><a href="#8-得到用于矫正A4纸的特征矩阵" class="headerlink" title="(8) 得到用于矫正A4纸的特征矩阵"></a>(8) 得到用于矫正A4纸的特征矩阵</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageSegmentation::calcMatrix() &#123;</span><br><span class="line">  <span class="keyword">double</span> x0 = vertex[<span class="number">0</span>].first, x1 = vertex[<span class="number">1</span>].first, x2 = vertex[<span class="number">2</span>].first, x3 = vertex[<span class="number">3</span>].first;</span><br><span class="line">  <span class="keyword">double</span> y0 = vertex[<span class="number">0</span>].second, y1 = vertex[<span class="number">1</span>].second, y2 = vertex[<span class="number">2</span>].second, y3 = vertex[<span class="number">3</span>].second;</span><br><span class="line">  <span class="keyword">double</span> dx3 = x0 - x1 + x2 - x3;</span><br><span class="line">  <span class="keyword">double</span> dy3 = y0 - y1 + y2 - y3;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(dx3) &lt; <span class="number">10e-5</span> &amp;&amp; <span class="built_in">fabs</span>(dy3) &lt; <span class="number">10e-5</span>) &#123;</span><br><span class="line">    M[<span class="number">0</span>] = x1 - x0, M[<span class="number">1</span>] = y1 - y0, M[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    M[<span class="number">3</span>] = x2 - x1, M[<span class="number">4</span>] = y2 - y1, M[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    M[<span class="number">6</span>] = x0, M[<span class="number">7</span>] = y0, M[<span class="number">8</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">double</span> dx1 = x1 - x2, dx2 = x3 - x2, dy1 = y1 - y2, dy2 = y3 - y2;</span><br><span class="line">    <span class="keyword">double</span> det = dx1 * dy2 - dx2 * dy1;</span><br><span class="line">    <span class="keyword">double</span> a13 = (dx3 * dy2 - dx2 * dy3) / det;</span><br><span class="line">    <span class="keyword">double</span> a23 = (dx1 * dy3 - dx3 * dy1) / det;</span><br><span class="line">    M[<span class="number">0</span>] = x1 - x0 + a13 * x1, M[<span class="number">1</span>] = y1 - y0 + a13 * y1, M[<span class="number">2</span>] = a13;</span><br><span class="line">    M[<span class="number">3</span>] = x3 - x0 + a23 * x3, M[<span class="number">4</span>] = y3 - y0 + a23 * y3, M[<span class="number">5</span>] = a23;</span><br><span class="line">    M[<span class="number">6</span>] = x0, M[<span class="number">7</span>] = y0, M[<span class="number">8</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-进行A4纸矫正"><a href="#9-进行A4纸矫正" class="headerlink" title="(9) 进行A4纸矫正"></a>(9) 进行A4纸矫正</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageSegmentation::warping() &#123;</span><br><span class="line">resultImg = Img;</span><br><span class="line"><span class="keyword">double</span> P[<span class="number">3</span>];</span><br><span class="line">  resultImg.resize(<span class="number">1050</span>, <span class="number">1485</span>);  <span class="comment">// 标准A4纸比例</span></span><br><span class="line">  <span class="keyword">double</span> width = resultImg.width(), height = resultImg.height();</span><br><span class="line">cimg_forXY(resultImg, x, y) &#123;</span><br><span class="line"><span class="keyword">double</span> _x = x / width, _y = y / height;</span><br><span class="line"><span class="keyword">double</span> denominator = M[<span class="number">2</span>] * _x + M[<span class="number">5</span>] * _y + M[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">double</span> tx = (M[<span class="number">0</span>] * _x + M[<span class="number">3</span>] * _y + M[<span class="number">6</span>]) / denominator;</span><br><span class="line"><span class="keyword">double</span> ty = (M[<span class="number">1</span>] * _x + M[<span class="number">4</span>] * _y + M[<span class="number">7</span>]) / denominator;</span><br><span class="line"><span class="comment">/*Interpolation(Img, tx, ty, P);</span></span><br><span class="line"><span class="comment">resultImg(x,y,0) = P[0];</span></span><br><span class="line"><span class="comment">resultImg(x,y,1) = P[1];</span></span><br><span class="line"><span class="comment">resultImg(x,y,2) = P[2];</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; P[0] &lt;&lt; endl;*/</span></span><br><span class="line">cimg_forC(resultImg, c) &#123;</span><br><span class="line">resultImg(x,y,c) = Img((<span class="keyword">int</span>)tx, (<span class="keyword">int</span>)ty, c);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  resultImg.display();</span><br><span class="line">  resultImg.save(<span class="string">"result_b.bmp"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-封装成类"><a href="#10-封装成类" class="headerlink" title="(10) 封装成类"></a>(10) 封装成类</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageSegmentation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//源图</span></span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; Img;</span><br><span class="line"><span class="comment">//灰度图</span></span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; grayImg;</span><br><span class="line"><span class="comment">//高斯平滑后的图像</span></span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; blurImg;</span><br><span class="line"><span class="comment">//用于图像分割的阈值</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//图像分割后的图片</span></span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; segImg;</span><br><span class="line"><span class="comment">//梯度图像</span></span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; gradImg;</span><br><span class="line"><span class="comment">//霍夫空间图像</span></span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; houghImg;</span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; resultImg;</span><br><span class="line"><span class="built_in">vector</span>&lt; pair&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span> &gt; &gt; peaks;</span><br><span class="line"><span class="comment">//直线点集</span></span><br><span class="line"><span class="built_in">vector</span>&lt; pair&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt; lines;</span><br><span class="line"><span class="comment">//四个角点</span></span><br><span class="line"><span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span> &gt; &gt; vertex;</span><br><span class="line"><span class="keyword">double</span> M[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rgb2gray</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gauss_blur</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//迭代法求阈值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_thres_iteration</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//OSTU法求阈值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_thres_ostu</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_thres</span><span class="params">(<span class="built_in">string</span> type_c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Segmentation</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gradDection</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hough_Statistics</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetLine</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetVertexs</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">orderVertexs</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcMatrix</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">warping</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ImageSegmentation();</span><br><span class="line">ImageSegmentation(<span class="keyword">const</span> <span class="keyword">char</span>* filename);</span><br><span class="line">~ImageSegmentation();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">correct_process</span><span class="params">(<span class="built_in">string</span> type_c)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="11-效果展示："><a href="#11-效果展示：" class="headerlink" title="(11) 效果展示："></a>(11) 效果展示：</h3><h4 id="1-jpg"><a href="#1-jpg" class="headerlink" title="1.jpg"></a>1.jpg</h4><p><img src="https://img-blog.csdnimg.cn/20181221004328407.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181221004347445.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-jpg"><a href="#2-jpg" class="headerlink" title="2.jpg"></a>2.jpg</h4><p><img src="https://img-blog.csdnimg.cn/20181221004406485.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181221004419687.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3-jpg"><a href="#3-jpg" class="headerlink" title="3.jpg"></a>3.jpg</h4><p><img src="https://img-blog.csdnimg.cn/2018122100443531.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181221004510343.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="4-jpg"><a href="#4-jpg" class="headerlink" title="4.jpg"></a>4.jpg</h4><p><img src="https://img-blog.csdnimg.cn/20181221004523755.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181221004537784.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="5-jpg"><a href="#5-jpg" class="headerlink" title="5.jpg"></a>5.jpg</h4><p><img src="https://img-blog.csdnimg.cn/20181221004553481.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181221004602800.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="6-jpg"><a href="#6-jpg" class="headerlink" title="6.jpg"></a>6.jpg</h4><p><img src="https://img-blog.csdnimg.cn/20181221004614514.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181221004634542.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>完整代码参见：</strong><br><a href="https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp7/code/work1" target="_blank" rel="noopener">https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp7/code/work1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图像分割进行A4纸矫正&quot;&gt;&lt;a href=&quot;#图像分割进行A4纸矫正&quot; class=&quot;headerlink&quot; title=&quot;图像分割进行A4纸矫正&quot;&gt;&lt;/a&gt;图像分割进行A4纸矫正&lt;/h2&gt;&lt;h3 id=&quot;1-将图像从rgb空间转为灰度空间&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>mnist手写字体识别</title>
    <link href="http://yoursite.com/2019/07/07/mnist%E6%89%8B%E5%86%99%E5%AD%97%E4%BD%93%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2019/07/07/mnist手写字体识别/</id>
    <published>2019-07-07T11:53:24.000Z</published>
    <updated>2019-07-07T11:55:27.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手写字体的检测"><a href="#手写字体的检测" class="headerlink" title="手写字体的检测"></a>手写字体的检测</h2><h3 id="1-Adaboost进行手写字体的检测"><a href="#1-Adaboost进行手写字体的检测" class="headerlink" title="(1) Adaboost进行手写字体的检测"></a>(1) Adaboost进行手写字体的检测</h3><h4 id="导入mnist数据集"><a href="#导入mnist数据集" class="headerlink" title="导入mnist数据集"></a>导入mnist数据集</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow.examples.tutorials.mnist.input_data <span class="keyword">as</span> input_data</span><br><span class="line">data_dir = <span class="string">'../MNIST_data/'</span></span><br><span class="line">mnist = input_data.read_data_sets(data_dir,one_hot=<span class="literal">False</span>)</span><br><span class="line">batch_size = <span class="number">50000</span></span><br><span class="line">test_x = mnist.test.images[:<span class="number">10000</span>]</span><br><span class="line">test_y = mnist.test.labels[:<span class="number">10000</span>]</span><br></pre></td></tr></table></figure><p>一共60000个数据集，取50000用于训练，10000用于测试训练出的模型。</p><h4 id="调用Adaboost分类器进行训练："><a href="#调用Adaboost分类器进行训练：" class="headerlink" title="调用Adaboost分类器进行训练："></a>调用Adaboost分类器进行训练：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">batch_x,batch_y = mnist.train.next_batch(batch_size)</span><br><span class="line">clf_rf = AdaBoostClassifier(n_estimators = <span class="number">60</span>)</span><br><span class="line">clf_rf.fit(batch_x,batch_y)</span><br></pre></td></tr></table></figure><h4 id="评估预测的效果："><a href="#评估预测的效果：" class="headerlink" title="评估预测的效果："></a>评估预测的效果：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred_rf = clf_rf.predict(test_x)</span><br><span class="line">acc_rf = accuracy_score(test_y,y_pred_rf)</span><br><span class="line">print(<span class="string">"%s n_estimators = 60, accuracy:%f"</span> % (datetime.now(), acc_rf))</span><br></pre></td></tr></table></figure><h4 id="选取较好的参数-弱分类器数量-："><a href="#选取较好的参数-弱分类器数量-：" class="headerlink" title="选取较好的参数(弱分类器数量)："></a>选取较好的参数(弱分类器数量)：</h4><p>先通过调节弱分类器数量来获得一个训练效果比较不错的数量参数(<strong>虽然之后发现预测率好像是改变的</strong>)</p><p><img src="https://img-blog.csdnimg.cn/20181221003558443.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>之后选取弱分类器参数为60进行训练</strong></p><h5 id="在对自己的手写图片读入前先进行几步处理："><a href="#在对自己的手写图片读入前先进行几步处理：" class="headerlink" title="在对自己的手写图片读入前先进行几步处理："></a>在对自己的手写图片读入前先进行几步处理：</h5><ul><li>将图片转为二值图</li><li>resize为mnist训练集要求的(28*28)尺寸</li><li>将图像进行膨胀处理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.resize(img, (<span class="number">28</span>, <span class="number">28</span>), interpolation=cv2.INTER_CUBIC)</span><br><span class="line">GrayImage = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret,thresh2=cv2.threshold(GrayImage,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY_INV)</span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">img = cv2.dilate(thresh2,kernel)</span><br></pre></td></tr></table></figure><p><strong>处理好的图片效果如下：</strong></p><p><img src="https://img-blog.csdnimg.cn/20181221003609115.JPG" alt="在这里插入图片描述"></p><p><strong>同时有一点很坑的要注意就是mnist要识别的是西方的手写字体，和我们常写的有一点区别。</strong></p><h5 id="下面是用于读入的手写数字"><a href="#下面是用于读入的手写数字" class="headerlink" title="下面是用于读入的手写数字"></a>下面是用于读入的手写数字</h5><p><img src="https://img-blog.csdnimg.cn/2018122100362140.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="进行一步裁剪处理："><a href="#进行一步裁剪处理：" class="headerlink" title="进行一步裁剪处理："></a>进行一步裁剪处理：</h5><p><img src="https://img-blog.csdnimg.cn/20181221003631478.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="下面是预测效果："><a href="#下面是预测效果：" class="headerlink" title="下面是预测效果："></a>下面是预测效果：</h4><p><img src="https://img-blog.csdnimg.cn/20181221003648945.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>test集的准确率为75%左右，自己手写数字的准确率为60%，这是一个比较不期望的结果，于是考虑用一个自己搭建的CNN网络对模型进行测试(参考tensorflow中文社区)</strong></p><h3 id="2-卷积神经网络-CNN-进行手写字体的检测"><a href="#2-卷积神经网络-CNN-进行手写字体的检测" class="headerlink" title="(2) 卷积神经网络(CNN)进行手写字体的检测"></a>(2) 卷积神经网络(CNN)进行手写字体的检测</h3><h4 id="1-权重初始化"><a href="#1-权重初始化" class="headerlink" title="1. 权重初始化"></a>1. 权重初始化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span><span class="params">(shape)</span>:</span></span><br><span class="line">  initial = tf.truncated_normal(shape, stddev=<span class="number">0.1</span>)</span><br><span class="line">  <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span><span class="params">(shape)</span>:</span></span><br><span class="line">  initial = tf.constant(<span class="number">0.1</span>, shape=shape)</span><br><span class="line">  <span class="keyword">return</span> tf.Variable(initial)</span><br></pre></td></tr></table></figure><h4 id="2-卷积和池化"><a href="#2-卷积和池化" class="headerlink" title="2. 卷积和池化"></a>2. 卷积和池化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv2d</span><span class="params">(x, W)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> tf.nn.conv2d(x, W, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pool_2x2</span><span class="params">(x)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> tf.nn.max_pool(x, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span><br></pre></td></tr></table></figure><h4 id="3-第一层卷积"><a href="#3-第一层卷积" class="headerlink" title="3. 第一层卷积"></a>3. 第一层卷积</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">W_conv1 = weight_variable([<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">32</span>])</span><br><span class="line">b_conv1 = bias_variable([<span class="number">32</span>])</span><br><span class="line"></span><br><span class="line">x_image = tf.reshape(x, [<span class="number">-1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>])</span><br><span class="line">h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)</span><br><span class="line">h_pool1 = max_pool_2x2(h_conv1)</span><br></pre></td></tr></table></figure><h4 id="4-第二层卷积"><a href="#4-第二层卷积" class="headerlink" title="4.第二层卷积"></a>4.第二层卷积</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">W_conv2 = weight_variable([<span class="number">5</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">64</span>])</span><br><span class="line">b_conv2 = bias_variable([<span class="number">64</span>])</span><br><span class="line"></span><br><span class="line">h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)</span><br><span class="line">h_pool2 = max_pool_2x2(h_conv2)</span><br></pre></td></tr></table></figure><h4 id="5-密集连接层"><a href="#5-密集连接层" class="headerlink" title="5. 密集连接层"></a>5. 密集连接层</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">W_fc1 = weight_variable([<span class="number">7</span> * <span class="number">7</span> * <span class="number">64</span>, <span class="number">1024</span>])</span><br><span class="line">b_fc1 = bias_variable([<span class="number">1024</span>])</span><br><span class="line"></span><br><span class="line">h_pool2_flat = tf.reshape(h_pool2, [<span class="number">-1</span>, <span class="number">7</span>*<span class="number">7</span>*<span class="number">64</span>])</span><br><span class="line">h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</span><br></pre></td></tr></table></figure><h4 id="6-Dropout"><a href="#6-Dropout" class="headerlink" title="6. Dropout"></a>6. Dropout</h4><p><strong>(屏蔽神经元的输出以及自动处理神经元输出值的scale )</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keep_prob = tf.placeholder(tf.float32)</span><br><span class="line">h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)</span><br></pre></td></tr></table></figure><h4 id="7-输出层"><a href="#7-输出层" class="headerlink" title="7. 输出层"></a>7. 输出层</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">W_fc2 = weight_variable([<span class="number">1024</span>, <span class="number">10</span>])</span><br><span class="line">b_fc2 = bias_variable([<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">y_conv=tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2)</span><br></pre></td></tr></table></figure><h4 id="8-训练和评估模型"><a href="#8-训练和评估模型" class="headerlink" title="8. 训练和评估模型"></a>8. 训练和评估模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cross_entropy = tf.reduce_mean(</span><br><span class="line">    tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=y_conv))</span><br><span class="line">train_step = tf.train.AdamOptimizer(<span class="number">1e-4</span>).minimize(cross_entropy)</span><br><span class="line">correct_prediction = tf.equal(tf.argmax(y_conv,<span class="number">1</span>), tf.argmax(y_,<span class="number">1</span>))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line"></span><br><span class="line">saver = tf.train.Saver()  <span class="comment"># defaults to saving all variables</span></span><br><span class="line"></span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20000</span>):</span><br><span class="line">  batch = mnist.train.next_batch(<span class="number">50</span>)</span><br><span class="line">  <span class="keyword">if</span> i%<span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">    train_accuracy = accuracy.eval(feed_dict=&#123;</span><br><span class="line">        x:batch[<span class="number">0</span>], y_: batch[<span class="number">1</span>], keep_prob: <span class="number">1.0</span>&#125;)</span><br><span class="line">    print(<span class="string">"step %d, training accuracy %g"</span>%(i, train_accuracy))</span><br><span class="line"></span><br><span class="line">  train_step.run(feed_dict=&#123;x: batch[<span class="number">0</span>], y_: batch[<span class="number">1</span>], keep_prob: <span class="number">0.5</span>&#125;)</span><br><span class="line">saver.save(sess, <span class="string">'./model/model.ckpt'</span>)  <span class="comment">#保存模型参数，注意把这里改为自己的路径</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"test accuracy %g"</span>%accuracy.eval(feed_dict=&#123;</span><br><span class="line">    x: mnist.test.images, y_: mnist.test.labels, keep_prob: <span class="number">1.0</span>&#125;))</span><br></pre></td></tr></table></figure><p><strong>最终跑出的模型准确度接近99.3%</strong></p><h5 id="训练出的模型："><a href="#训练出的模型：" class="headerlink" title="训练出的模型："></a>训练出的模型：</h5><p><img src="https://img-blog.csdnimg.cn/20181221003700538.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="9-用存储的model对自己的手写字体进行测试："><a href="#9-用存储的model对自己的手写字体进行测试：" class="headerlink" title="9. 用存储的model对自己的手写字体进行测试："></a>9. 用存储的model对自己的手写字体进行测试：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">init_op = tf.initialize_all_variables()</span><br><span class="line"></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init_op)</span><br><span class="line">    saver.restore(sess, <span class="string">"./model/model.ckpt"</span>)<span class="comment">#这里使用了之前保存的模型参数</span></span><br><span class="line"></span><br><span class="line">    prediction=tf.argmax(y_conv,<span class="number">1</span>)</span><br><span class="line">    predint=prediction.eval(feed_dict=&#123;x: [result],keep_prob: <span class="number">1.0</span>&#125;, session=sess)</span><br><span class="line">    print(<span class="string">'the digit is 9: '</span>)</span><br><span class="line">    print(<span class="string">'recognize result:'</span>)</span><br><span class="line">    print(predint[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h4 id="10-效果："><a href="#10-效果：" class="headerlink" title="10. 效果："></a>10. 效果：</h4><p><strong>(最终效果10张图全部都预测准确，再测了几张写得不是特别规范的数字也基本都识别正确)</strong><br><img src="https://img-blog.csdnimg.cn/20181221003803598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>完整代码参见：</strong><br><a href="https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp7/code/work2" target="_blank" rel="noopener">https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp7/code/work2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;手写字体的检测&quot;&gt;&lt;a href=&quot;#手写字体的检测&quot; class=&quot;headerlink&quot; title=&quot;手写字体的检测&quot;&gt;&lt;/a&gt;手写字体的检测&lt;/h2&gt;&lt;h3 id=&quot;1-Adaboost进行手写字体的检测&quot;&gt;&lt;a href=&quot;#1-Adaboost进行手写
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="神经网络" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>c++实现DES加密算法</title>
    <link href="http://yoursite.com/2019/07/06/c-%E5%AE%9E%E7%8E%B0DES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/07/06/c-实现DES加密算法/</id>
    <published>2019-07-06T13:12:25.000Z</published>
    <updated>2019-07-06T13:13:07.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法原理："><a href="#算法原理：" class="headerlink" title="算法原理："></a>算法原理：</h2><p>DES算法是一种对称加密算法，以64位为分组对数据加密，加密和解密用的是同一个算法。它的密钥长度是56位（因为每个第8 位都用作奇偶校验），密钥可以是任意的56位的数，而且可以任意时候改变。其中有极少数被认为是易破解的弱密钥，但是很容易避开它们不用。所以保密性依赖于密钥。 </p><p><strong>其基本流程如下：</strong></p><p>首先要生成一套加密密钥，从用户处取得一个64位长的密码口令，然后通过等分、移位、选取和迭代形成一套16个加密密钥，分别供每一轮运算中使用。</p><p>DES对64位(bit)的明文分组M进行操作，M经过一个初始置换IP，置换成m0。将m0明文分成左半部分和右半部分m0 = (L0，R0)，各32位长。然后进行16轮完全相同的运算（迭代），这些运算被称为函数f，在每一轮运算过程中数据与相应的密钥结合。</p><p>在每一轮中，密钥位移位，然后再从密钥的56位中选出48位。通过一个扩展置换将数据的右半部分扩展成48位，并通过一个异或操作替代成新的48位数据，再将其压缩置换成32位。这四步运算构成了函数f。然后，通过另一个异或运算，函数f的输出与左半部分结合，其结果成为新的右半部分，原来的右半部分成为新的左半部分。将该操作重复16次。</p><p>经过16轮迭代后，左，右半部分合在一起经过一个末置换（数据整理），这样就完成了加密过程。</p><p>DES的解密和加密唯一的不同是密钥的次序相反。如果各轮加密密钥分别是K1，K2，K3…K16，那么解密密钥就是K16，K15，K14…K1。</p><h2 id="总体结构："><a href="#总体结构：" class="headerlink" title="总体结构："></a>总体结构：</h2><p><strong>Feistel结构：</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209200251183.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="模块分解："><a href="#模块分解：" class="headerlink" title="模块分解："></a>模块分解：</h2><h4 id="由给定的密钥获取16个子密钥："><a href="#由给定的密钥获取16个子密钥：" class="headerlink" title="由给定的密钥获取16个子密钥："></a>由给定的密钥获取16个子密钥：</h4><ul><li>对K 的56个非校验位实行置换PC-1，得到C0D0，其中C0 和D0 分别由PC-1 置换后的前28位和后28位组成。 </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//密钥置换表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PC_1[<span class="number">56</span>] = &#123;</span><br><span class="line"><span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,</span><br><span class="line"> <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>,</span><br><span class="line"><span class="number">10</span>,  <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line"><span class="number">19</span>, <span class="number">11</span>,  <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>,</span><br><span class="line"><span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>,</span><br><span class="line"> <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line"><span class="number">14</span>,  <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>,</span><br><span class="line"><span class="number">21</span>, <span class="number">13</span>,  <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>,  <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>计算Ci = LSi(Ci-1) 和Di = LSi(Di-1) </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//密钥置换时每轮移动的位数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> shift[<span class="number">16</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将密钥的前后部分分别左移</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftShift</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> K[<span class="number">28</span>], <span class="keyword">int</span> shift)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ar[<span class="number">28</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(ar, K, <span class="number">28</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">27</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i-shift &lt; <span class="number">0</span>)</span><br><span class="line">K[i] = ar[i-shift+<span class="number">28</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">K[i] = ar[i-shift];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对56位的CiDi 实行PC-2 压缩置换，得到48位的Ki 。i= i+1。 </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//压缩置换表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PC_2[<span class="number">48</span>] = &#123;</span><br><span class="line"><span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>,  <span class="number">1</span>,  <span class="number">5</span>,</span><br><span class="line"> <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>,  <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line"><span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>,  <span class="number">4</span>, <span class="number">26</span>,  <span class="number">8</span>,</span><br><span class="line"><span class="number">16</span>,  <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>,  <span class="number">2</span>,</span><br><span class="line"><span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line"><span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line"><span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line"><span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>之后的16轮按照以上步骤重复得到16个子密钥</li></ul><p>[外链图片转存失败(img-Dov3dif3-1562418750620)(C:\Users\ADMINI~1\AppData\Local\Temp\1540735921928.png)]</p><ul><li><strong>总的算法实现：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMyKey</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">64</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> subKey[<span class="number">16</span>][<span class="number">48</span>])</span> </span>&#123;</span><br><span class="line"><span class="comment">//去掉奇偶检验位的key</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> key_f[<span class="number">56</span>];</span><br><span class="line"><span class="comment">//左半部分</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> L[<span class="number">28</span>];</span><br><span class="line"><span class="comment">//右半部分</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R[<span class="number">28</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> C_key[<span class="number">48</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">56</span>; i++) &#123;</span><br><span class="line">key_f[<span class="number">55</span>-i] = key[<span class="number">64</span>-PC_1[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成左右子密钥</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">28</span>; j++) &#123;</span><br><span class="line">L[j] = key_f[j+<span class="number">28</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">28</span>; j++) &#123;</span><br><span class="line">R[j] = key_f[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左移</span></span><br><span class="line">leftShift(L, shift[i]);</span><br><span class="line">leftShift(R, shift[i]);</span><br><span class="line"><span class="comment">//压缩置换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">28</span>; j++) &#123;</span><br><span class="line">key_f[j+<span class="number">28</span>] = L[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">28</span>; j++) &#123;</span><br><span class="line">key_f[j] = R[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">48</span>; j++) &#123;</span><br><span class="line">C_key[<span class="number">47</span>-j] = key_f[<span class="number">56</span>-PC_2[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(subKey[i], C_key, <span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始IP置换："><a href="#初始IP置换：" class="headerlink" title="初始IP置换："></a>初始IP置换：</h4><p> 给定64位明文块M，通过一个固定的初始置换IP来重排M中的二进制位，得到二进制串M0 = IP(M) = L0 R0，这里L0 和R0分别是M0 的前32位和后32位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IP置换表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> IP[<span class="number">64</span>] = &#123;</span><br><span class="line"><span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line"><span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>,</span><br><span class="line"><span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line"><span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,  <span class="number">1</span>,</span><br><span class="line"><span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line"><span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>,</span><br><span class="line"><span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始置换IP</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> FirstKey[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">FirstKey[<span class="number">63</span>-i] = word[<span class="number">64</span>-IP[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代T"><a href="#迭代T" class="headerlink" title="迭代T"></a>迭代T</h4><ul><li>根据L0R0 按下述规则进行16次迭代，即 </li></ul><p>$$<br>Li= Ri-1,  Ri= Li-1 (XOR) f(Ri-1, Ki), i= 1 .. 16<br>$$</p><ul><li>这里 (XOR) 是32位二进制串按位异或运算，f 是输出32位的Feistel 轮函数；</li><li>16个长度为48位的子密钥Ki(i= 1 .. 16) 由密钥K生成；</li><li>16次迭代后得到L16R16 ;</li><li>左右交换输出R16L16 。</li></ul><p><img src="https://img-blog.csdnimg.cn/20181209200339257.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//16轮迭代</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> L[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">L[i] = FirstKey[i+<span class="number">32</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">R[i] = FirstKey[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> tmp_R[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R1[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(tmp_R, R, <span class="number">32</span>);</span><br><span class="line">f(R, subKey[i], R1);</span><br><span class="line">XOR_32(L, R1);</span><br><span class="line"><span class="built_in">memcpy</span>(R, L, <span class="number">32</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(L, tmp_R, <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>轮询函数Feistel：</strong></p><ul><li>将长度为32位的串Ri-1作E-扩展,成为48位的串E(Ri-1)； </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩展置换表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> E[<span class="number">48</span>] = &#123;</span><br><span class="line"><span class="number">32</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,</span><br><span class="line"> <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,</span><br><span class="line"> <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,</span><br><span class="line"><span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>,</span><br><span class="line"><span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line"><span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>,</span><br><span class="line"><span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>,</span><br><span class="line"><span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>,  <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>将E(Ri-1) 和长度为48位的子密钥Ki作48位二进制串按位异或运算，Ki 由密钥K生成； </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XOR_48</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ER[<span class="number">48</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> K[<span class="number">48</span>])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">48</span>; i++) &#123;</span><br><span class="line">ER[i] ^= K[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将上面得到的结果平均分成8个分组(每个分组长度6位)，各个分 组分别经过8个不同的S-盒进行6-4 转换，得到8个长度分别为4 位的分组； </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S盒置换表，每个S盒是4x16的置换表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S_BOX[<span class="number">8</span>][<span class="number">4</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">14</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">0</span>&#125;, </span><br><span class="line">&#123;<span class="number">15</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">13</span>&#125; </span><br><span class="line">&#125;,</span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">15</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>&#125;,  </span><br><span class="line">&#123;<span class="number">3</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">5</span>&#125;, </span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">15</span>&#125;,  </span><br><span class="line">&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">9</span>&#125;  </span><br><span class="line">&#125;, </span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">10</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">&#123;<span class="number">13</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">12</span>&#125;  </span><br><span class="line">&#125;, </span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">7</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">15</span>&#125;,  </span><br><span class="line">&#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,  </span><br><span class="line">&#123;<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>&#125;,  </span><br><span class="line">&#123;<span class="number">3</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">14</span>&#125;  </span><br><span class="line">&#125;,</span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,  </span><br><span class="line">&#123;<span class="number">14</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">14</span>&#125;,  </span><br><span class="line">&#123;<span class="number">11</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>&#125;  </span><br><span class="line">&#125;,</span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>&#125;,  </span><br><span class="line">&#123;<span class="number">10</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">&#123;<span class="number">9</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>&#125;  </span><br><span class="line">&#125;, </span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">&#123;<span class="number">13</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,  </span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,  </span><br><span class="line">&#123;<span class="number">6</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>&#125;  </span><br><span class="line">&#125;, </span><br><span class="line">&#123;  </span><br><span class="line">&#123;<span class="number">13</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">7</span>&#125;,  </span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,  </span><br><span class="line">&#123;<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>&#125;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>将上面得到的分组结果顺序连接得到长度为32位的串；</li><li>再将上面的32位串经过P-置换，得到的结果作为轮函数f(Ri-1, Ki) 的最终32位输出。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P盒置换表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P[<span class="number">32</span>] = &#123;</span><br><span class="line"><span class="number">16</span>,  <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line"><span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>,</span><br><span class="line"> <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>,</span><br><span class="line"> <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line"> <span class="number">2</span>,  <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>,</span><br><span class="line"><span class="number">32</span>, <span class="number">27</span>,  <span class="number">3</span>,  <span class="number">9</span>,</span><br><span class="line"><span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>,  <span class="number">6</span>,</span><br><span class="line"><span class="number">22</span>, <span class="number">11</span>,  <span class="number">4</span>, <span class="number">25</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>整个函数的实现过程：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//轮询函数Feistel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> R[<span class="number">32</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> K[<span class="number">48</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> R1[<span class="number">32</span>])</span> </span>&#123;</span><br><span class="line"><span class="comment">//将32位进行扩展成48位</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ER[<span class="number">48</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">48</span>; i++) &#123;</span><br><span class="line">ER[<span class="number">47</span>-i] = R[<span class="number">32</span>-E[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展后的R和K异或</span></span><br><span class="line">XOR_48(ER, K);</span><br><span class="line"><span class="comment">//轮询S_Box，将6-&gt;4</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">48</span>; i+=<span class="number">6</span>, j+=<span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> m = (ER[<span class="number">47</span>-i]&lt;&lt;<span class="number">1</span>) +ER[<span class="number">47</span>-i<span class="number">-5</span>];</span><br><span class="line"><span class="keyword">int</span> n = (ER[<span class="number">47</span>-i<span class="number">-1</span>]&lt;&lt;<span class="number">3</span>) + (ER[<span class="number">47</span>-i<span class="number">-2</span>]&lt;&lt;<span class="number">2</span>) + (ER[<span class="number">47</span>-i<span class="number">-3</span>]&lt;&lt;<span class="number">1</span>) + ER[<span class="number">47</span>-i<span class="number">-4</span>];</span><br><span class="line"><span class="keyword">int</span> num = S_BOX[i/<span class="number">6</span>][m][n];</span><br><span class="line"><span class="comment">//printf("%d  %d", m, n);</span></span><br><span class="line">R1[<span class="number">31</span>-j] = (num&amp;<span class="number">0x08</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">R1[<span class="number">31</span>-j<span class="number">-1</span>] = (num&amp;<span class="number">0x04</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">R1[<span class="number">31</span>-j<span class="number">-2</span>] = (num&amp;<span class="number">0x02</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">R1[<span class="number">31</span>-j<span class="number">-3</span>] = num&amp;<span class="number">0x01</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//P置换， 32-&gt;32</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ar[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(ar, R1, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">R1[<span class="number">31</span>-i] = ar[<span class="number">32</span>-P[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加密："><a href="#加密：" class="headerlink" title="加密："></a>加密：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnCode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> word[<span class="number">64</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> cipher[<span class="number">64</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> subKey[<span class="number">16</span>][<span class="number">48</span>])</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始置换IP</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> FirstKey[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">FirstKey[<span class="number">63</span>-i] = word[<span class="number">64</span>-IP[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//16轮迭代</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> L[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">L[i] = FirstKey[i+<span class="number">32</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">R[i] = FirstKey[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> tmp_R[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R1[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(tmp_R, R, <span class="number">32</span>);</span><br><span class="line">f(R, subKey[i], R1);</span><br><span class="line">XOR_32(L, R1);</span><br><span class="line"><span class="built_in">memcpy</span>(R, L, <span class="number">32</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(L, tmp_R, <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并迭代后的L和R,并进行IP-1的置换</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> LR[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">LR[i] = L[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">LR[i+<span class="number">32</span>] = R[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> tmp_LR[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(tmp_LR, LR, <span class="number">64</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">cipher[<span class="number">63</span>-i] = tmp_LR[<span class="number">64</span>-IP_1[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解密："><a href="#解密：" class="headerlink" title="解密："></a>解密：</h4><ul><li>分析所有的代替、置换、异或和循环移动过程，获得一个非常 有用的性质：DES 的加密和解密可使用相同的算法和密钥。 </li><li>DES 的过程设计使得用相同的函数来加密或解密每个分组成为 可能。加解密过程中使用由同一个密钥K 经过相同的子密钥生 成算法得到的子密钥序列，唯一不同之处是加解密过程中子密 钥的调度次序恰好相反。<ul><li>加密过程的子密钥按(K1 K2 … K15 K16) 次序调度</li><li>解密过程的子密钥按(K16 K15 … K2 K1) 次序调度</li></ul></li></ul><p><strong>代码实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeCode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> cipher[<span class="number">64</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> word[<span class="number">64</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> subKey[<span class="number">16</span>][<span class="number">48</span>])</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始置换IP</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> FirstKey[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">FirstKey[<span class="number">63</span>-i] = cipher[<span class="number">64</span>-IP[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//16轮迭代</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> L[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">L[i] = FirstKey[i+<span class="number">32</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">R[i] = FirstKey[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> tmp_R[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R1[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(tmp_R, R, <span class="number">32</span>);</span><br><span class="line">f(R, subKey[<span class="number">15</span>-i], R1);</span><br><span class="line">XOR_32(L, R1);</span><br><span class="line"><span class="built_in">memcpy</span>(R, L, <span class="number">32</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(L, tmp_R, <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并迭代后的L和R,并进行IP-1的置换</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> LR[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">LR[i] = L[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">LR[i+<span class="number">32</span>] = R[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> tmp_LR[<span class="number">64</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(tmp_LR, LR, <span class="number">64</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">word[<span class="number">63</span>-i] = tmp_LR[<span class="number">64</span>-IP_1[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h2><p>使用<strong>unsigned char数组</strong>来存储二进制位串</p><p>通过c语言的移位操作符实现二进制位串的逻辑运算。</p><p><strong>通过以下代码实现字符串与二进制位串的转换：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符转换成二进制符号 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CharToBit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> c, <span class="keyword">unsigned</span> <span class="keyword">char</span> bit[<span class="number">8</span>])</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;  </span><br><span class="line">        *(bit+i) = (c&gt;&gt;i) &amp; <span class="number">1</span>;  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line"><span class="comment">//将长度为8的字符串转为64位二进制  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringToBits</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> c[<span class="number">8</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> bit[<span class="number">64</span>])</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;          </span><br><span class="line">        CharToBit(*(c + i), bit + (i&lt;&lt;<span class="number">3</span>));  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//二进制转换成字节  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitToChar</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> bit[<span class="number">8</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> *c)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;  </span><br><span class="line">        *c |= *(bit + i) &lt;&lt; i;  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将二进制字节转为长度为8的字符串  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitsToString</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> bit[<span class="number">64</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> c[<span class="number">8</span>])</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="number">8</span>);  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;  </span><br><span class="line">        BitToChar(bit + (i&lt;&lt;<span class="number">3</span>), c + i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二进制位串的一些逻辑运算如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">XOR_32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ER[<span class="number">32</span>], <span class="keyword">unsigned</span> <span class="keyword">char</span> K[<span class="number">32</span>])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">ER[i] ^= K[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = (ER[<span class="number">47</span>-i]&lt;&lt;<span class="number">1</span>) +ER[<span class="number">47</span>-i<span class="number">-5</span>];</span><br><span class="line"><span class="keyword">int</span> n = (ER[<span class="number">47</span>-i<span class="number">-1</span>]&lt;&lt;<span class="number">3</span>) + (ER[<span class="number">47</span>-i<span class="number">-2</span>]&lt;&lt;<span class="number">2</span>) + (ER[<span class="number">47</span>-i<span class="number">-3</span>]&lt;&lt;<span class="number">1</span>) + ER[<span class="number">47</span>-i<span class="number">-4</span>];</span><br><span class="line"><span class="keyword">int</span> num = S_BOX[i/<span class="number">6</span>][m][n];</span><br><span class="line"><span class="comment">//printf("%d  %d", m, n);</span></span><br><span class="line">R1[<span class="number">31</span>-j] = (num&amp;<span class="number">0x08</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">R1[<span class="number">31</span>-j<span class="number">-1</span>] = (num&amp;<span class="number">0x04</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">R1[<span class="number">31</span>-j<span class="number">-2</span>] = (num&amp;<span class="number">0x02</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">R1[<span class="number">31</span>-j<span class="number">-3</span>] = num&amp;<span class="number">0x01</span>;</span><br></pre></td></tr></table></figure><h2 id="编译运行结果："><a href="#编译运行结果：" class="headerlink" title="编译运行结果："></a>编译运行结果：</h2><p><strong>用于测试的main文件：</strong></p><ul><li>将加密的文字存到一个记事本里，解密过程读取记事本中的位串进行解码。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"desCode.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please input the words you want to encode: \n\n"</span>);</span><br><span class="line"><span class="comment">//加密的文字</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> word[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memset</span>(word, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *s_word = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">gets(s_word);</span><br><span class="line"><span class="built_in">strcpy</span>(word, s_word);</span><br><span class="line"><span class="built_in">free</span>(s_word);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> words[<span class="number">64</span>];</span><br><span class="line">StringToBits(word, words);</span><br><span class="line"><span class="comment">//密钥</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c_key[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//取1~9的随机数作为密钥</span></span><br><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> key_1 = rand() % <span class="number">10</span>;</span><br><span class="line">c_key[i] = key_1 + <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nthe key help us to encode is: \n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, c_key[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"><span class="comment">//unsigned char *c_key = "12342a78";</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">64</span>];</span><br><span class="line">StringToBits(c_key, key);</span><br><span class="line"><span class="comment">//根据提供的密钥生成16个子密钥</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> subKey[<span class="number">16</span>][<span class="number">48</span>];</span><br><span class="line">getMyKey(key, subKey);</span><br><span class="line"><span class="comment">//加密过程</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> cipher[<span class="number">64</span>];</span><br><span class="line">EnCode(words, cipher, subKey);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"After encode, your cipher is: \n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, cipher[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"><span class="comment">//将密码写到密码本里面</span></span><br><span class="line">FILE *fp;</span><br><span class="line">fp = fopen(<span class="string">"code.txt"</span>,<span class="string">"w+t"</span>);</span><br><span class="line">fwrite(cipher, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="number">64</span>, fp);</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="comment">//将密码本的密码读取出</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> cipher_read[<span class="number">64</span>];</span><br><span class="line">fp = fopen(<span class="string">"code.txt"</span>,<span class="string">"r+t"</span>);</span><br><span class="line">fread(cipher_read, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="number">64</span>, fp);</span><br><span class="line"><span class="comment">//fscanf(fp, "%s", cipher_read);</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="comment">//解密过程</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> decode[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> answer[<span class="number">8</span>];</span><br><span class="line">DeCode(cipher_read, decode, subKey);</span><br><span class="line">BitsToString(decode, answer);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"After decode, your answer is: \n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, answer[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br><img src="https://img-blog.csdnimg.cn/20181209200433922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法原理：&quot;&gt;&lt;a href=&quot;#算法原理：&quot; class=&quot;headerlink&quot; title=&quot;算法原理：&quot;&gt;&lt;/a&gt;算法原理：&lt;/h2&gt;&lt;p&gt;DES算法是一种对称加密算法，以64位为分组对数据加密，加密和解密用的是同一个算法。它的密钥长度是56位（因为每个第
      
    
    </summary>
    
      <category term="信息安全技术" scheme="http://yoursite.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="信息安全技术" scheme="http://yoursite.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>c++实现MD5</title>
    <link href="http://yoursite.com/2019/07/06/c-%E5%AE%9E%E7%8E%B0MD5/"/>
    <id>http://yoursite.com/2019/07/06/c-实现MD5/</id>
    <published>2019-07-06T13:10:58.000Z</published>
    <updated>2019-07-06T13:11:57.393Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MD5算法简介："><a href="#MD5算法简介：" class="headerlink" title="MD5算法简介："></a>MD5算法简介：</h4><p>消息摘要算法第五版（英语：Message-Digest Algorithm 5，缩写为MD5），是当前计算机领域用于确保信息传输完整一致而广泛使用的散列算法之一（又译哈希算法、摘要算法等），主流编程语言普遍已有MD5的实现。将数据 （如一段文字）运算变为另一固定长度值，是散列算法的基础原理，MD5的前身有MD2、MD3和MD4。MD5由MD4、MD3、MD2改进而来，主要增强算法复杂度和不可逆性。目前，MD5算法因其普遍、稳定、快速的特点，仍广泛应用于普通 数据的错误检查领域。例如在一些BitTorrent下载中，软件将通过计算MD5检验下载到的文件片段的完整性。MD5已经广泛使用在为文件传输提供一定的可靠性方面。例如，服务器预先提供一个MD5校验和，用户下载完文件以后， 用MD5算法计算下载文件的MD5校验和，然后通过检查这两个校验和是否一致，就能判断下载的文件是否出错。MD5是输入不定长度信息，输出固定长度128-bits的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个 128-bits散列。基本方式为，求余、取余、调整长度、与链接变量进行循环运算。得出结果。</p><h4 id="MD5运算步骤："><a href="#MD5运算步骤：" class="headerlink" title="MD5运算步骤："></a>MD5运算步骤：</h4><p>假设输入信息(input message)的长度为b(bit)，我们想要产生它的报文摘要，在此处b为任意的非负整数：b也可能为0，也不一定为8的整数倍，且可能是任意大的长度。设该信息的比特流表示如下： M[0] M[1] M[2] … M[b-1] 计算此信息的报文摘要需要如下5步：</p><p><strong>1.补位</strong></p><p>信息计算前先要进行位补位，设补位后信息的长度为LEN(bit)，则LEN%512 = 448(bit)，即数据扩展至 K * 512 + 448(bit)。即K * 64+56(byte)，K为整数。补位操作始终要执行，即使补位前信息的长度对512求余的结果是448。具体补位操作：补一个1，然后补0至满足上述要求。总共最少要补1bit，最多补512bit。</p><p><strong>2.尾部加上信息长度</strong></p><p>将输入信息的原始长度b(bit)表示成一个64-bit的数字，把它添加到上一步的结果后面(在32位的机器上，这64位将用2个字来表示并且低位在前)。当遇到b大于2^64这种极少的情况时，b的高位被截去，仅使用b的低64位。经过上面两步，数据就被填补成长度为512(bit)的倍数。也就是说，此时的数据长度是16个字(32byte)的整数倍。此时的数据表示为： M[0 … N-1] 其中的N是16的倍数。</p><p><strong>3.初始化缓存区</strong></p><p>用一个四个字的缓冲器(A，B，C，D)来计算报文摘要，A,B,C,D分别是32位的寄存器，初始化使用的是十六进制表示的数字，注意低字节在前： word A: 01 23 45 67 word B: 89 ab cd ef word C: fe dc ba 98 word D: 76 54 32 10</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">0x67452301</span>;</span><br><span class="line">B = <span class="number">0xEFCDAB89</span>;</span><br><span class="line">C = <span class="number">0x98BADCFE</span>;</span><br><span class="line">D = <span class="number">0x10325476</span>;</span><br></pre></td></tr></table></figure><p><strong>4.转换</strong></p><p>四轮循环运算：循环的次数是分组的个数（N+1）：</p><p>1）将每一512字节细分成16个小组，每个小组64位（8个字节） </p><p>2）用到的作为辅助的四个线性函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">unsigned</span> <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x &amp; y) | ((~x) &amp; z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">G</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">unsigned</span> <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x &amp; z) | (y &amp; (~z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">H</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">unsigned</span> <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x ^ y ^ z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">I</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> y, <span class="keyword">unsigned</span> <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> y ^ (x | (~z));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）x表示消息的某个子分组（从0到15），&lt;&lt; </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">FF</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">int</span> b, <span class="keyword">unsigned</span> <span class="keyword">int</span> c, <span class="keyword">unsigned</span> <span class="keyword">int</span> d, <span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">unsigned</span> <span class="keyword">int</span> ac)</span> </span>&#123;</span><br><span class="line">a += F(b, c, d) + x + ac;</span><br><span class="line">a = (a &lt;&lt; s) | (a &gt;&gt; (<span class="number">32</span> - s));</span><br><span class="line">a += b;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GG</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">int</span> b, <span class="keyword">unsigned</span> <span class="keyword">int</span> c, <span class="keyword">unsigned</span> <span class="keyword">int</span> d, <span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">unsigned</span> <span class="keyword">int</span> ac)</span> </span>&#123;</span><br><span class="line">a += G(b, c, d) + x + ac;</span><br><span class="line">a = (a &lt;&lt; s) | (a &gt;&gt; (<span class="number">32</span> - s));</span><br><span class="line">a += b;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">HH</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">int</span> b, <span class="keyword">unsigned</span> <span class="keyword">int</span> c, <span class="keyword">unsigned</span> <span class="keyword">int</span> d, <span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">unsigned</span> <span class="keyword">int</span> ac)</span> </span>&#123;</span><br><span class="line">a += H(b, c, d) + x + ac;</span><br><span class="line">a = (a &lt;&lt; s) | (a &gt;&gt; (<span class="number">32</span> - s));</span><br><span class="line">a += b;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">II</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">int</span> b, <span class="keyword">unsigned</span> <span class="keyword">int</span> c, <span class="keyword">unsigned</span> <span class="keyword">int</span> d, <span class="keyword">unsigned</span> <span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">unsigned</span> <span class="keyword">int</span> ac)</span> </span>&#123;</span><br><span class="line">a += I(b, c, d) + x + ac;</span><br><span class="line">a = (a &lt;&lt; s) | (a &gt;&gt; (<span class="number">32</span> - s));</span><br><span class="line">a += b;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）四轮运算 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MD5::transform(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *block) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a = A, b = B, c = C, d = D;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> groups[<span class="number">16</span>];</span><br><span class="line">decode(groups, block, <span class="number">64</span>);</span><br><span class="line"><span class="comment">//groups[15] = 0;</span></span><br><span class="line">a = FF(a, b, c, d, groups[<span class="number">0</span>], S11, <span class="number">0xd76aa478</span>L); <span class="comment">/* 1 */</span></span><br><span class="line">    d = FF(d, a, b, c, groups[<span class="number">1</span>], S12, <span class="number">0xe8c7b756</span>L); <span class="comment">/* 2 */</span></span><br><span class="line">    c = FF(c, d, a, b, groups[<span class="number">2</span>], S13, <span class="number">0x242070db</span>L); <span class="comment">/* 3 */</span></span><br><span class="line">    b = FF(b, c, d, a, groups[<span class="number">3</span>], S14, <span class="number">0xc1bdceee</span>L); <span class="comment">/* 4 */</span></span><br><span class="line">    a = FF(a, b, c, d, groups[<span class="number">4</span>], S11, <span class="number">0xf57c0faf</span>L); <span class="comment">/* 5 */</span></span><br><span class="line">    d = FF(d, a, b, c, groups[<span class="number">5</span>], S12, <span class="number">0x4787c62a</span>L); <span class="comment">/* 6 */</span></span><br><span class="line">    c = FF(c, d, a, b, groups[<span class="number">6</span>], S13, <span class="number">0xa8304613</span>L); <span class="comment">/* 7 */</span></span><br><span class="line">    b = FF(b, c, d, a, groups[<span class="number">7</span>], S14, <span class="number">0xfd469501</span>L); <span class="comment">/* 8 */</span></span><br><span class="line">    a = FF(a, b, c, d, groups[<span class="number">8</span>], S11, <span class="number">0x698098d8</span>L); <span class="comment">/* 9 */</span></span><br><span class="line">    d = FF(d, a, b, c, groups[<span class="number">9</span>], S12, <span class="number">0x8b44f7af</span>L); <span class="comment">/* 10 */</span></span><br><span class="line">    c = FF(c, d, a, b, groups[<span class="number">10</span>], S13, <span class="number">0xffff5bb1</span>L); <span class="comment">/* 11 */</span></span><br><span class="line">    b = FF(b, c, d, a, groups[<span class="number">11</span>], S14, <span class="number">0x895cd7be</span>L); <span class="comment">/* 12 */</span></span><br><span class="line">    a = FF(a, b, c, d, groups[<span class="number">12</span>], S11, <span class="number">0x6b901122</span>L); <span class="comment">/* 13 */</span></span><br><span class="line">    d = FF(d, a, b, c, groups[<span class="number">13</span>], S12, <span class="number">0xfd987193</span>L); <span class="comment">/* 14 */</span></span><br><span class="line">    c = FF(c, d, a, b, groups[<span class="number">14</span>], S13, <span class="number">0xa679438e</span>L); <span class="comment">/* 15 */</span></span><br><span class="line">    b = FF(b, c, d, a, groups[<span class="number">15</span>], S14, <span class="number">0x49b40821</span>L); <span class="comment">/* 16 */</span></span><br><span class="line">    <span class="comment">/*第二轮*/</span></span><br><span class="line">    a = GG(a, b, c, d, groups[<span class="number">1</span>], S21, <span class="number">0xf61e2562</span>L); <span class="comment">/* 17 */</span></span><br><span class="line">    d = GG(d, a, b, c, groups[<span class="number">6</span>], S22, <span class="number">0xc040b340</span>L); <span class="comment">/* 18 */</span></span><br><span class="line">    c = GG(c, d, a, b, groups[<span class="number">11</span>], S23, <span class="number">0x265e5a51</span>L); <span class="comment">/* 19 */</span></span><br><span class="line">    b = GG(b, c, d, a, groups[<span class="number">0</span>], S24, <span class="number">0xe9b6c7aa</span>L); <span class="comment">/* 20 */</span></span><br><span class="line">    a = GG(a, b, c, d, groups[<span class="number">5</span>], S21, <span class="number">0xd62f105d</span>L); <span class="comment">/* 21 */</span></span><br><span class="line">    d = GG(d, a, b, c, groups[<span class="number">10</span>], S22, <span class="number">0x2441453</span>L); <span class="comment">/* 22 */</span></span><br><span class="line">    c = GG(c, d, a, b, groups[<span class="number">15</span>], S23, <span class="number">0xd8a1e681</span>L); <span class="comment">/* 23 */</span></span><br><span class="line">    b = GG(b, c, d, a, groups[<span class="number">4</span>], S24, <span class="number">0xe7d3fbc8</span>L); <span class="comment">/* 24 */</span></span><br><span class="line">    a = GG(a, b, c, d, groups[<span class="number">9</span>], S21, <span class="number">0x21e1cde6</span>L); <span class="comment">/* 25 */</span></span><br><span class="line">    d = GG(d, a, b, c, groups[<span class="number">14</span>], S22, <span class="number">0xc33707d6</span>L); <span class="comment">/* 26 */</span></span><br><span class="line">    c = GG(c, d, a, b, groups[<span class="number">3</span>], S23, <span class="number">0xf4d50d87</span>L); <span class="comment">/* 27 */</span></span><br><span class="line">    b = GG(b, c, d, a, groups[<span class="number">8</span>], S24, <span class="number">0x455a14ed</span>L); <span class="comment">/* 28 */</span></span><br><span class="line">    a = GG(a, b, c, d, groups[<span class="number">13</span>], S21, <span class="number">0xa9e3e905</span>L); <span class="comment">/* 29 */</span></span><br><span class="line">    d = GG(d, a, b, c, groups[<span class="number">2</span>], S22, <span class="number">0xfcefa3f8</span>L); <span class="comment">/* 30 */</span></span><br><span class="line">    c = GG(c, d, a, b, groups[<span class="number">7</span>], S23, <span class="number">0x676f02d9</span>L); <span class="comment">/* 31 */</span></span><br><span class="line">    b = GG(b, c, d, a, groups[<span class="number">12</span>], S24, <span class="number">0x8d2a4c8a</span>L); <span class="comment">/* 32 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第三轮*/</span></span><br><span class="line">    a = HH(a, b, c, d, groups[<span class="number">5</span>], S31, <span class="number">0xfffa3942</span>L); <span class="comment">/* 33 */</span></span><br><span class="line">    d = HH(d, a, b, c, groups[<span class="number">8</span>], S32, <span class="number">0x8771f681</span>L); <span class="comment">/* 34 */</span></span><br><span class="line">    c = HH(c, d, a, b, groups[<span class="number">11</span>], S33, <span class="number">0x6d9d6122</span>L); <span class="comment">/* 35 */</span></span><br><span class="line">    b = HH(b, c, d, a, groups[<span class="number">14</span>], S34, <span class="number">0xfde5380c</span>L); <span class="comment">/* 36 */</span></span><br><span class="line">    a = HH(a, b, c, d, groups[<span class="number">1</span>], S31, <span class="number">0xa4beea44</span>L); <span class="comment">/* 37 */</span></span><br><span class="line">    d = HH(d, a, b, c, groups[<span class="number">4</span>], S32, <span class="number">0x4bdecfa9</span>L); <span class="comment">/* 38 */</span></span><br><span class="line">    c = HH(c, d, a, b, groups[<span class="number">7</span>], S33, <span class="number">0xf6bb4b60</span>L); <span class="comment">/* 39 */</span></span><br><span class="line">    b = HH(b, c, d, a, groups[<span class="number">10</span>], S34, <span class="number">0xbebfbc70</span>L); <span class="comment">/* 40 */</span></span><br><span class="line">    a = HH(a, b, c, d, groups[<span class="number">13</span>], S31, <span class="number">0x289b7ec6</span>L); <span class="comment">/* 41 */</span></span><br><span class="line">    d = HH(d, a, b, c, groups[<span class="number">0</span>], S32, <span class="number">0xeaa127fa</span>L); <span class="comment">/* 42 */</span></span><br><span class="line">    c = HH(c, d, a, b, groups[<span class="number">3</span>], S33, <span class="number">0xd4ef3085</span>L); <span class="comment">/* 43 */</span></span><br><span class="line">    b = HH(b, c, d, a, groups[<span class="number">6</span>], S34, <span class="number">0x4881d05</span>L); <span class="comment">/* 44 */</span></span><br><span class="line">    a = HH(a, b, c, d, groups[<span class="number">9</span>], S31, <span class="number">0xd9d4d039</span>L); <span class="comment">/* 45 */</span></span><br><span class="line">    d = HH(d, a, b, c, groups[<span class="number">12</span>], S32, <span class="number">0xe6db99e5</span>L); <span class="comment">/* 46 */</span></span><br><span class="line">    c = HH(c, d, a, b, groups[<span class="number">15</span>], S33, <span class="number">0x1fa27cf8</span>L); <span class="comment">/* 47 */</span></span><br><span class="line">    b = HH(b, c, d, a, groups[<span class="number">2</span>], S34, <span class="number">0xc4ac5665</span>L); <span class="comment">/* 48 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第四轮*/</span></span><br><span class="line">    a = II(a, b, c, d, groups[<span class="number">0</span>], S41, <span class="number">0xf4292244</span>L); <span class="comment">/* 49 */</span></span><br><span class="line">    d = II(d, a, b, c, groups[<span class="number">7</span>], S42, <span class="number">0x432aff97</span>L); <span class="comment">/* 50 */</span></span><br><span class="line">    c = II(c, d, a, b, groups[<span class="number">14</span>], S43, <span class="number">0xab9423a7</span>L); <span class="comment">/* 51 */</span></span><br><span class="line">    b = II(b, c, d, a, groups[<span class="number">5</span>], S44, <span class="number">0xfc93a039</span>L); <span class="comment">/* 52 */</span></span><br><span class="line">    a = II(a, b, c, d, groups[<span class="number">12</span>], S41, <span class="number">0x655b59c3</span>L); <span class="comment">/* 53 */</span></span><br><span class="line">    d = II(d, a, b, c, groups[<span class="number">3</span>], S42, <span class="number">0x8f0ccc92</span>L); <span class="comment">/* 54 */</span></span><br><span class="line">    c = II(c, d, a, b, groups[<span class="number">10</span>], S43, <span class="number">0xffeff47d</span>L); <span class="comment">/* 55 */</span></span><br><span class="line">    b = II(b, c, d, a, groups[<span class="number">1</span>], S44, <span class="number">0x85845dd1</span>L); <span class="comment">/* 56 */</span></span><br><span class="line">    a = II(a, b, c, d, groups[<span class="number">8</span>], S41, <span class="number">0x6fa87e4f</span>L); <span class="comment">/* 57 */</span></span><br><span class="line">    d = II(d, a, b, c, groups[<span class="number">15</span>], S42, <span class="number">0xfe2ce6e0</span>L); <span class="comment">/* 58 */</span></span><br><span class="line">    c = II(c, d, a, b, groups[<span class="number">6</span>], S43, <span class="number">0xa3014314</span>L); <span class="comment">/* 59 */</span></span><br><span class="line">    b = II(b, c, d, a, groups[<span class="number">13</span>], S44, <span class="number">0x4e0811a1</span>L); <span class="comment">/* 60 */</span></span><br><span class="line">    a = II(a, b, c, d, groups[<span class="number">4</span>], S41, <span class="number">0xf7537e82</span>L); <span class="comment">/* 61 */</span></span><br><span class="line">    d = II(d, a, b, c, groups[<span class="number">11</span>], S42, <span class="number">0xbd3af235</span>L); <span class="comment">/* 62 */</span></span><br><span class="line">    c = II(c, d, a, b, groups[<span class="number">2</span>], S43, <span class="number">0x2ad7d2bb</span>L); <span class="comment">/* 63 */</span></span><br><span class="line">    b = II(b, c, d, a, groups[<span class="number">9</span>], S44, <span class="number">0xeb86d391</span>L); <span class="comment">/* 64 */</span></span><br><span class="line"></span><br><span class="line">A += a;</span><br><span class="line">    B += b;</span><br><span class="line">    C += c;</span><br><span class="line">    D += d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数中两个比较重要的模块</strong>，其中一个是update函数，也是大部分摘要算法都具有的操作：</p><p>作用主要是更新MD5块。然后继续MD5消息摘要操作，处理另一个消息块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MD5::update(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *input, <span class="keyword">int</span> length) &#123;</span><br><span class="line">inputNum += (length &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">64</span> - bufferNum;</span><br><span class="line">    <span class="comment">////将输入的一部分复制到buffer所以它可以形成一个块（size = 64）</span></span><br><span class="line">    <span class="keyword">if</span>(start &lt;= length)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//可以形成一个块，然后对这个块做四轮循环</span></span><br><span class="line">            <span class="built_in">memcpy</span>(&amp;buffer[bufferNum], input, start);</span><br><span class="line">            transform(buffer);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i = start; i &lt;= length - <span class="number">64</span>; i += <span class="number">64</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                transform(&amp;input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            bufferNum = length - i;  </span><br><span class="line">            <span class="built_in">memcpy</span>(buffer, &amp;input[i], bufferNum);  </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//不能形成块</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;buffer[bufferNum], input, length);</span><br><span class="line">        bufferNum += length;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再是Final函数，作用是使用100000填充buffer, 并添加64位原始大小的输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MD5::Final()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">56</span> - bufferNum;  <span class="comment">//56 = 448/8</span></span><br><span class="line">    <span class="comment">//填充</span></span><br><span class="line">    <span class="keyword">if</span>(temp &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        update(padding, temp);</span><br><span class="line"></span><br><span class="line">        inputNum -= (temp &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(temp &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        update(padding, <span class="number">64</span> + temp);</span><br><span class="line">        inputNum -= ((<span class="number">64</span> + temp) &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//trans inputNum(输入的位数) to unsigned char (64bits)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> Bits[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//cout &lt;&lt; inputNum &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; inputNum &lt;&lt; endl;</span></span><br><span class="line">        Bits[i] = (inputNum &gt;&gt; <span class="number">8</span>*i) &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; (int)Bits[4] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//添加最初输入的num(后64位)</span></span><br><span class="line">    update(Bits, <span class="number">8</span>); </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> input[<span class="number">4</span>];</span><br><span class="line">    input[<span class="number">0</span>] = A;</span><br><span class="line">   input[<span class="number">1</span>] = B;</span><br><span class="line">   input[<span class="number">2</span>] = C;</span><br><span class="line">   input[<span class="number">3</span>] = D;</span><br><span class="line">   <span class="comment">//将input存入result</span></span><br><span class="line">    encode(result, input, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后将整个模块整合为类：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MD5</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> cipher;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> A;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> B;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> C;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> D;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> bufferNum;  <span class="comment">//</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> inputNum;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> result[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MD5();</span><br><span class="line">~MD5();</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fiename)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readCipher</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *input, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *output, <span class="keyword">unsigned</span> <span class="keyword">int</span> *input, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *output, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* input, <span class="keyword">const</span> <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *block)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Final</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><p><strong>将要加密的文本写入到密码本中：</strong><br><img src="https://img-blog.csdnimg.cn/20181209195553162.png" alt="在这里插入图片描述"></p><p><strong>运行结果：</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209195631415.png" alt="在这里插入图片描述"></p><p><strong>然后与加密网站的结果进行对比：</strong></p><p>网站为：<a href="http://tool.chinaz.com/tools/md5.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/tools/md5.aspx</a><br><img src="https://img-blog.csdnimg.cn/20181209195712744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>结果一致，说明加密成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;MD5算法简介：&quot;&gt;&lt;a href=&quot;#MD5算法简介：&quot; class=&quot;headerlink&quot; title=&quot;MD5算法简介：&quot;&gt;&lt;/a&gt;MD5算法简介：&lt;/h4&gt;&lt;p&gt;消息摘要算法第五版（英语：Message-Digest Algorithm 5，缩写为MD5
      
    
    </summary>
    
      <category term="信息安全技术" scheme="http://yoursite.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="信息安全技术" scheme="http://yoursite.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>图像拼接(Image Stitch)</title>
    <link href="http://yoursite.com/2019/07/06/Stitch/"/>
    <id>http://yoursite.com/2019/07/06/Stitch/</id>
    <published>2019-07-06T13:09:16.000Z</published>
    <updated>2019-07-06T13:10:19.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编译运行："><a href="#编译运行：" class="headerlink" title="编译运行："></a>编译运行：</h3><p><strong>运行环境</strong>：</p><p><code>Ubuntu 18</code></p><p><strong>链接库：</strong></p><p><code>VLFeat</code>&amp;&amp;<code>CImg</code></p><p><strong>编译命令：</strong></p><p><code>g++ -o test main.cpp ImageStitching.cpp ImageStitching.h -lpthread -l X11 -Lglnxa64/ -lvl -O3 -std=c++11</code></p><p>(linux下编译比较简单，只需将CImg.h文件和用到的vl库放在同目录下，但是要将libvl.so添加到usr下的动态链接库内)</p><h3 id="读入图像："><a href="#读入图像：" class="headerlink" title="读入图像："></a>读入图像：</h3><p>将目录下的多张图片读入，运用了linux环境下提取目录文件的一个目录指针，然后图片存在了CImgList中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">ptr</span>;</span></span><br><span class="line">DIR *dir;</span><br><span class="line">dir = opendir(<span class="string">"TEST-ImageData1"</span>);</span><br><span class="line"><span class="keyword">while</span> ((ptr = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(ptr-&gt;d_name[<span class="number">0</span>] == <span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">string</span> file = <span class="built_in">string</span>(<span class="string">"TEST-ImageData1/"</span>) + <span class="built_in">string</span>(ptr-&gt;d_name);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; file &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *Ff = file.c_str();</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; picture;</span><br><span class="line">picture.load(Ff);</span><br><span class="line">imgs.push_back(picture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="柱面投影："><a href="#柱面投影：" class="headerlink" title="柱面投影："></a>柱面投影：</h3><p>在全景图像中，由于摄像头的朝向不同，重合部分部分图像不一定满足视觉一致性的要求，因此先对图像进行投影，使其满足要求，以为后面的拼接做准备。在环形全景中，一般选择柱面投影算法，将图像分别投影到以 像素焦距+摄像头与圆心距离 为半径的圆柱上。投影后的图像为上图摄像头前方的圆弧。从圆弧上看，图像的重合部分已经满足视觉一致性的要求 。</p><p><img src="https://img-blog.csdn.net/20160201195938321" alt="img"></p><p><strong>圆柱面坐标转换的公式为：</strong><br>$$<br>x = \frac{x’-\frac{W}{2}}{k}+\frac{W}{2}=\frac{(x’-\frac{W}{2})\sqrt{R^2+(x-\frac{W}{2})^2}}{R}+\frac{W}{2}<br>$$</p><p>$$<br>y = \frac{y’-\frac{H}{2}}{k}+\frac{H}{2}=\frac{(y’-\frac{H}{2})\sqrt{R^2+(x-\frac{W}{2})^2}}{R}+\frac{H}{2}<br>$$</p><p>可以注意到把x和y写在了等式的左边而x’,y’写在了右边，这样做是为了方便进行插值计算 。投影后的图像点坐标未必为整数，而图像的坐标需要为整数，所以必将造成误差 。为了减少这种误差，我们对坐标点进行双线性插值。</p><p>其中半径R的值: <strong>R = W / (2*tan(α/2))</strong>，α的取值一般为相机视场角度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">float</span>&gt; ImageStitching::CylindricalProjection(CImg&lt;<span class="keyword">float</span>&gt; pic) &#123;</span><br><span class="line">    <span class="keyword">int</span> width = pic._width;</span><br><span class="line">    <span class="keyword">int</span> height = pic._height;</span><br><span class="line">    <span class="keyword">int</span> channel = pic._spectrum;</span><br><span class="line">    CImg&lt;<span class="keyword">float</span>&gt; result(width, height, <span class="number">1</span>, channel, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">float</span>  R = width / (<span class="number">2</span>*<span class="built_in">tan</span>(<span class="number">28.0f</span>/<span class="number">2.0f</span>*PI/<span class="number">180.0f</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; height; y++) &#123;</span><br><span class="line">            <span class="keyword">float</span> x0 = x - (<span class="keyword">float</span>)(width / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">float</span> y0 = y - (<span class="keyword">float</span>) (height/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">float</span> _x = x0*<span class="built_in">sqrt</span>(R*R + x0*x0) / R + (<span class="keyword">float</span>) width / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">float</span> _y = y0*<span class="built_in">sqrt</span>(R*R + x0*x0) / R + (<span class="keyword">float</span>) height / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (_x &gt;= <span class="number">0</span> &amp;&amp; _x &lt; width &amp;&amp; _y &gt;=<span class="number">0</span> &amp;&amp; _y &lt;= height) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>;  c &lt; channel; c++) &#123;</span><br><span class="line">                    result(x,y,c) = Interpolation(pic,_x,_y,c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将图像由RGB空间转为灰度空间："><a href="#将图像由RGB空间转为灰度空间：" class="headerlink" title="将图像由RGB空间转为灰度空间："></a>将图像由RGB空间转为灰度空间：</h3><p>这一步是为了下面的sift算法做铺垫：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">float</span>&gt; ImageStitching::convertTogray(CImg&lt;<span class="keyword">float</span>&gt; pic) &#123;</span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; picture(pic._width, pic._height, <span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">cimg_forXY(pic,x,y) &#123;</span><br><span class="line"><span class="keyword">float</span> R = pic(x,y,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">float</span> G = pic(x,y,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">float</span> B = pic(x,y,<span class="number">2</span>);</span><br><span class="line">picture(x,y) =  R*<span class="number">0.299</span> + G*<span class="number">0.587</span> + B*<span class="number">0.114</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SIFT算法查找特征点"><a href="#SIFT算法查找特征点" class="headerlink" title="SIFT算法查找特征点"></a>SIFT算法查找特征点</h3><p>SIFT算法的实质是在不同尺度空间上查找关键点(特征点)，并计算关键点方向。SIFT所查找的关键点是一些十分突出，不会因光照，仿射变换和噪音等因素而变化的点，例如角点、边缘点、暗区的亮点以及亮区的暗点。</p><p>算法主要分为以下四步：</p><ol><li><strong>尺度空间极值检测</strong>：搜索所有尺度上的图像位置。通过高斯微分函数来识别潜在的对于尺度和旋转不变的兴趣点。</li><li><strong>关键点定位：</strong>在每个候选位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据它们的稳定程度。</li><li><strong>方向确定：</strong>基于图像局部梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向，尺度和位置进行变换。</li><li><strong>关键点描述：</strong>在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变化。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt; ImageStitching::SIFTFeatures(CImg&lt;<span class="keyword">float</span>&gt; pic) &#123;</span><br><span class="line">    <span class="keyword">int</span> noctaves = <span class="number">4</span>, nlevels = <span class="number">2</span>, o_min = <span class="number">0</span>;</span><br><span class="line">    vl_sift_pix *ImageData = <span class="keyword">new</span> vl_sift_pix[pic._width*pic._height];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pic._width; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pic._height; j++) &#123;</span><br><span class="line">            ImageData[j*pic._width + i] = pic(i,j,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义VlSiftFilt结构体指针</span></span><br><span class="line">VlSiftFilt *SiftFilt = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 创建一个新的sift滤波器</span></span><br><span class="line">SiftFilt = vl_sift_new(pic._width, pic._height, noctaves, nlevels, o_min);</span><br><span class="line">    <span class="comment">//int KeyPoint = 0;</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt; Feature;</span><br><span class="line">    <span class="keyword">if</span> (vl_sift_process_first_octave(SiftFilt, ImageData) != VL_ERR_EOF) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//计算每组中的关键点</span></span><br><span class="line">            vl_sift_detect(SiftFilt);</span><br><span class="line"><span class="comment">//遍历并绘制每个点  </span></span><br><span class="line"><span class="comment">//KeyPoint += SiftFilt-&gt;nkeys;//检测到的关键点的数目</span></span><br><span class="line">            VlSiftKeypoint *pKeyPoint = SiftFilt-&gt;keys;<span class="comment">//检测到的关键点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;SiftFilt-&gt;nkeys; i++) &#123;</span><br><span class="line">                VlSiftKeypoint tempKeyPoint = *pKeyPoint;</span><br><span class="line">                pKeyPoint++;</span><br><span class="line">                <span class="keyword">double</span> angles[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> angleCount = vl_sift_calc_keypoint_orientations(SiftFilt, angles, &amp;tempKeyPoint);<span class="comment">//计算关键点的方向</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;angleCount; j++) &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; Descriptor;</span><br><span class="line">                    <span class="keyword">double</span> tempAngle = angles[j];</span><br><span class="line">vl_sift_pix descriptors[<span class="number">128</span>];</span><br><span class="line"><span class="comment">// 计算每个方向的描述</span></span><br><span class="line">vl_sift_calc_keypoint_descriptor(SiftFilt, descriptors, &amp;tempKeyPoint, tempAngle);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">128</span> ;k++) &#123;</span><br><span class="line">                        Descriptor.push_back(descriptors[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Feature.insert(pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt;(Descriptor, tempKeyPoint));</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下一阶  </span></span><br><span class="line"><span class="keyword">if</span> (vl_sift_process_next_octave(SiftFilt) == VL_ERR_EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//free(pKeyPoint);  </span></span><br><span class="line"><span class="comment">//KeyPoint = NULL;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vl_sift_delete(SiftFilt);</span><br><span class="line"><span class="keyword">delete</span>[]ImageData;</span><br><span class="line">ImageData = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Feature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K-d-Tree最近邻搜索进行特征点匹配："><a href="#K-d-Tree最近邻搜索进行特征点匹配：" class="headerlink" title="K-d Tree最近邻搜索进行特征点匹配："></a>K-d Tree最近邻搜索进行特征点匹配：</h3><h4 id="k-d树算法可以分为两大部分，一部分是有关k-d树本身这种数据结构建立的算法，另一部分是在建立的k-d树上如何进行最邻近查找的算法。"><a href="#k-d树算法可以分为两大部分，一部分是有关k-d树本身这种数据结构建立的算法，另一部分是在建立的k-d树上如何进行最邻近查找的算法。" class="headerlink" title="k-d树算法可以分为两大部分，一部分是有关k-d树本身这种数据结构建立的算法，另一部分是在建立的k-d树上如何进行最邻近查找的算法。"></a>k-d树算法可以分为两大部分，一部分是有关k-d树本身这种数据结构建立的算法，另一部分是在建立的k-d树上如何进行最邻近查找的算法。</h4><p><strong>构建k-d树：</strong></p><p>构造kd树的方法：首先构造根节点，根节点对应于整个k维空间，包含所有的实例点，（至于如何选取划分点，有不同的策略。最常用的是一种方法是：对于所有的样本点，统计它们在每个维上的方差，挑选出方差中的最大值，对应的维就是要进行数据切分的维度。数据方差最大表明沿该维度数据点分散得比较开，这个方向上进行数据分割可以获得最好的分辨率；然后再将所有样本点按切分维度的值进行排序，位于正中间的那个数据点选为分裂结点。）。然后利用递归的方法，分别构造k-d树根节点的左右子树。在超矩形区域上选择一个坐标轴（切分维度）和一个分裂结点，以通过此分裂结点且垂直于切分方向坐标轴的直线作为分隔线，将当前超矩形区域分隔成左右或者上下两个子超矩形区域，对应于分裂结点的左右子树的根节点。实例也就被分到两个不相交的区域中。重复此过程直到子区域内没有实例点时终止。终止时的结点为叶结点。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">算法：createKDTree 构建一棵k-d tree </span><br><span class="line"> </span><br><span class="line">输入：exm_<span class="keyword">set</span> 样本集 </span><br><span class="line"> </span><br><span class="line">输出 : Kd, 类型为kd-tree </span><br><span class="line"> </span><br><span class="line">1. 如果exm_<span class="keyword">set</span>是空的，则返回空的kd-tree </span><br><span class="line"> </span><br><span class="line">2.调用分裂结点选择程序（输入是exm_<span class="keyword">set</span>），返回两个值 </span><br><span class="line"> </span><br><span class="line">       dom_elt:= exm_<span class="keyword">set</span>中的一个样本点 </span><br><span class="line"> </span><br><span class="line">       split := 分裂维的序号 </span><br><span class="line"> </span><br><span class="line">3.exm_<span class="keyword">set</span>_left = &#123;exm∈exm_<span class="keyword">set</span> – dom_elt &amp;&amp; exm[split] &lt;= dom_elt[split]&#125; </span><br><span class="line"> </span><br><span class="line">   exm_<span class="keyword">set</span>_right = &#123;exm∈exm_<span class="keyword">set</span> – dom_elt &amp;&amp; exm[split] &gt; dom_elt[split]&#125; </span><br><span class="line"> </span><br><span class="line">4.left = createKDTree<span class="params">(exm_set_left)</span> </span><br><span class="line"> </span><br><span class="line">right = createKDTree<span class="params">(exm_set_right)</span></span><br></pre></td></tr></table></figure><p><strong>k-d tree最近邻搜索算法</strong></p><p>在k-d tree树中进行数据的k近邻搜索是特征匹配的重要环节，其目的是检索在k-d tree中与待查询点距离最近的k个数据点。</p><p> 最近邻搜索是k近邻的特例，也就是1近邻。将1近邻改扩展到k近邻非常容易。下面介绍最简单的k-d tree最近邻搜索算法。</p><p>基本的思路很简单：首先通过二叉树搜索（比较待查询节点和分裂节点的分裂维的值，小于等于就进入左子树分支，等于就进入右子树分支直到叶子结点），顺着“搜索路径”很快能找到最近邻的近似点，也就是与待查询点处于同一个子空间的叶子结点；然后再回溯搜索路径，并判断搜索路径上的结点的其他子结点空间中是否可能有距离查询点更近的数据点，如果有可能，则需要跳到其他子结点空间中去搜索（将其他子结点加入到搜索路径）。重复这个过程直到搜索路径为空。下面是k-d tree最近邻搜索的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">算法：kdtreeFindNearest <span class="comment">/* k-d tree的最近邻搜索 */</span> </span><br><span class="line"> </span><br><span class="line">输入：Kd <span class="comment">/* k-d tree类型*/</span>  </span><br><span class="line">target <span class="comment">/* 待查询数据点 */</span> </span><br><span class="line"> </span><br><span class="line">输出 : nearest <span class="comment">/* 最近邻数据结点 */</span> </span><br><span class="line">dist <span class="comment">/* 最近邻和查询点的距离 */</span> </span><br><span class="line"> </span><br><span class="line"><span class="number">1.</span> 如果Kd是空的，则设dist为无穷大返回 </span><br><span class="line"><span class="number">2.</span> 向下搜索直到叶子结点 </span><br><span class="line">pSearch = &amp;Kd </span><br><span class="line"><span class="keyword">while</span>(pSearch != <span class="literal">NULL</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">pSearch加入到search_path中;  </span><br><span class="line"><span class="keyword">if</span>(target[pSearch-&gt;split] &lt;= pSearch-&gt;dom_elt[pSearch-&gt;split]) <span class="comment">/* 如果小于就进入左子树 */</span>  </span><br><span class="line">&#123;  </span><br><span class="line">pSearch = pSearch-&gt;left;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">&#123;  </span><br><span class="line">pSearch = pSearch-&gt;right;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">取出search_path最后一个赋给nearest  </span><br><span class="line">dist = Distance(nearest, target);  </span><br><span class="line"><span class="number">3.</span> 回溯搜索路径 </span><br><span class="line"><span class="keyword">while</span>(search_path不为空)  </span><br><span class="line">&#123;  </span><br><span class="line">取出search_path最后一个结点赋给pBack  </span><br><span class="line"><span class="keyword">if</span>(pBack-&gt;left为空 &amp;&amp; pBack-&gt;right为空) <span class="comment">/* 如果pBack为叶子结点 */</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>( Distance(nearest, target) &gt; Distance(pBack-&gt;dom_elt, target) )  </span><br><span class="line">&#123;  </span><br><span class="line">nearest = pBack-&gt;dom_elt;  </span><br><span class="line">dist = Distance(pBack-&gt;dom_elt, target);  </span><br><span class="line">&#125; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">s = pBack-&gt;split;  </span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">abs</span>(pBack-&gt;dom_elt[s] - target[s]) &lt; dist) <span class="comment">/* 如果以target为中心的圆（球或超球），半径为dist的圆与分割超平面相交， 那么就要跳到另一边的子空间去搜索 */</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">if</span>( Distance(nearest, target) &gt; Distance(pBack-&gt;dom_elt, target) )  </span><br><span class="line">&#123;  </span><br><span class="line">nearest = pBack-&gt;dom_elt;  </span><br><span class="line">dist = Distance(pBack-&gt;dom_elt, target);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span>(target[s] &lt;= pBack-&gt;dom_elt[s]) <span class="comment">/* 如果target位于pBack的左子空间，那么就要跳到右子空间去搜索 */</span>  </span><br><span class="line">pSearch = pBack-&gt;right;  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">pSearch = pBack-&gt;left; <span class="comment">/* 如果target位于pBack的右子空间，那么就要跳到左子空间去搜索 */</span>  </span><br><span class="line"><span class="keyword">if</span>(pSearch != <span class="literal">NULL</span>)  </span><br><span class="line">pSearch加入到search_path中  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用VLFeat实现k-d tree算法的代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;point_pair&gt; ImageStitching::KDtreeMatch(<span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt; feature_a, <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt; feature_b) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;point_pair&gt; result;</span><br><span class="line"></span><br><span class="line">    VlKDForest* forest = vl_kdforest_new(VL_TYPE_FLOAT, <span class="number">128</span>, <span class="number">1</span>, VlDistanceL1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> *data = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">128</span> * feature_a.size()];</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = feature_a.begin(); it != feature_a.end(); it++) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; &amp;descriptors = it-&gt;first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">data[i + <span class="number">128</span> * k] = descriptors[i];</span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vl_kdforest_build(forest, feature_a.size(), data);</span><br><span class="line">VlKDForestSearcher* searcher = vl_kdforest_new_searcher(forest);</span><br><span class="line">VlKDForestNeighbor neighbours[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = feature_b.begin(); it != feature_b.end(); it++)&#123;</span><br><span class="line"><span class="keyword">float</span> *temp_data = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">temp_data[i] = (it-&gt;first)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nvisited = vl_kdforestsearcher_query(searcher, neighbours, <span class="number">2</span>, temp_data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> ratio = neighbours[<span class="number">0</span>].distance / neighbours[<span class="number">1</span>].distance;</span><br><span class="line"><span class="keyword">if</span> (ratio &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; des(<span class="number">128</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++) &#123;</span><br><span class="line">des[j] = data[j + neighbours[<span class="number">0</span>].index * <span class="number">128</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VlSiftKeypoint left = feature_a.find(des)-&gt;second;</span><br><span class="line">VlSiftKeypoint right = it-&gt;second;</span><br><span class="line">result.push_back(point_pair(left, right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] temp_data;</span><br><span class="line">temp_data = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vl_kdforestsearcher_delete(searcher);</span><br><span class="line">vl_kdforest_delete(forest);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] data;</span><br><span class="line">data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RANSAC筛选出特征匹配点："><a href="#RANSAC筛选出特征匹配点：" class="headerlink" title="RANSAC筛选出特征匹配点："></a>RANSAC筛选出特征匹配点：</h3><p><strong>RANSAC算法在SIFT特征筛选中的主要流程是：</strong></p><p>(1) 从样本集中随机抽选一个RANSAC样本，即4个匹配点对</p><p>(2) 根据这4个匹配点对计算变换矩阵M</p><p>(3) 根据样本集，变换矩阵M，和误差度量函数计算满足当前变换矩阵的一致集consensus，并返回一致集中元素个数</p><p>(4) 根据当前一致集中元素个数判断是否最优(最大)一致集，若是则更新当前最优一致集</p><p>(5) 更新当前错误概率p，若p大于允许的最小错误概率则重复(1)至(4)继续迭代，直到当前错误概率p小于最小错误概率</p><pre><code>![img](https://img-blog.csdn.net/20151208162540847)</code></pre><p> <strong>其中，p为置信度，一般取0.995；w为”内点”的比例 ; m为计算模型所需要的最少样本数=4；</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">points ImageStitching::RANSAC(<span class="built_in">vector</span>&lt;point_pair&gt; pairs) &#123;</span><br><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">int</span> iterations = <span class="built_in">ceil</span>(<span class="built_in">log</span>(<span class="number">1</span> - <span class="number">0.99</span>) / <span class="built_in">log</span>(<span class="number">1</span> - <span class="built_in">pow</span>(<span class="number">0.5</span>, <span class="number">4</span>)));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; max_inliner_indexs;</span><br><span class="line"><span class="keyword">while</span> (iterations--) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;point_pair&gt; random_pairs;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; seleted_indexs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> index = rand() % pairs.size();</span><br><span class="line"><span class="keyword">while</span> (seleted_indexs.find(index) != seleted_indexs.end()) &#123;</span><br><span class="line">index = rand() % pairs.size();</span><br><span class="line">&#125;</span><br><span class="line">seleted_indexs.insert(index);</span><br><span class="line"></span><br><span class="line">random_pairs.push_back(pairs[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">points H = HomographyMatrix(random_pairs);</span><br><span class="line"><span class="comment">//cout &lt;&lt; H.x1 &lt;&lt; endl;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur_inliner_indexs;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (seleted_indexs.find(i) != seleted_indexs.end()) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> real_x = pairs[i].b.x;</span><br><span class="line"><span class="keyword">float</span> real_y = pairs[i].b.y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> x = H.x1 * pairs[i].a.x + H.x2 * pairs[i].a.y + H.x3 * pairs[i].a.x * pairs[i].a.y + H.x4;</span><br><span class="line"><span class="keyword">float</span> y = H.x5 * pairs[i].a.x + H.x6 * pairs[i].a.y + H.x7 * pairs[i].a.x * pairs[i].a.y + H.x8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> distance = <span class="built_in">sqrt</span>((x - real_x) * (x - real_x) + (y - real_y) * (y - real_y));</span><br><span class="line"><span class="keyword">if</span> (distance &lt; <span class="number">4</span>) &#123;</span><br><span class="line">cur_inliner_indexs.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur_inliner_indexs.size() &gt; max_inliner_indexs.size()) &#123;</span><br><span class="line">max_inliner_indexs = cur_inliner_indexs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> calc_size = max_inliner_indexs.size();</span><br><span class="line"></span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; A(<span class="number">4</span>, calc_size, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; b(<span class="number">1</span>, calc_size, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; calc_size; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> cur_index = max_inliner_indexs[i];</span><br><span class="line"></span><br><span class="line">A(<span class="number">0</span>, i) = pairs[cur_index].a.x;</span><br><span class="line">A(<span class="number">1</span>, i) = pairs[cur_index].a.y;</span><br><span class="line">A(<span class="number">2</span>, i) = pairs[cur_index].a.x * pairs[cur_index].a.y;</span><br><span class="line">A(<span class="number">3</span>, i) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">b(<span class="number">0</span>, i) = pairs[cur_index].b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; x1 = b.get_solve(A);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; calc_size; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> cur_index = max_inliner_indexs[i];</span><br><span class="line"></span><br><span class="line">b(<span class="number">0</span>, i) = pairs[cur_index].b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CImg&lt;<span class="keyword">double</span>&gt; x2 = b.get_solve(A);</span><br><span class="line"><span class="keyword">return</span> points(x1(<span class="number">0</span>, <span class="number">0</span>), x1(<span class="number">0</span>, <span class="number">1</span>), x1(<span class="number">0</span>, <span class="number">2</span>), x1(<span class="number">0</span>, <span class="number">3</span>), x2(<span class="number">0</span>, <span class="number">0</span>), x2(<span class="number">0</span>, <span class="number">1</span>), x2(<span class="number">0</span>, <span class="number">2</span>), x2(<span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图像拼接："><a href="#图像拼接：" class="headerlink" title="图像拼接："></a>图像拼接：</h3><p>先是进行进行拷贝，将一副图像按照需要拼接的点拷贝到另一幅图像上。但如果是直接拼接的话可能两幅图像对接点显得很不自然。这里使用Cimg的滤波函数进行边缘的滤波平滑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">CImg&lt;<span class="keyword">float</span>&gt; ImageStitching::Blend(CImg&lt;<span class="keyword">float</span>&gt; pic1, CImg&lt;<span class="keyword">float</span>&gt; pic2) &#123;</span><br><span class="line"><span class="keyword">double</span> sum_a_x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> sum_a_y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a_n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> sum_overlap_x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> sum_overlap_y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> overlap_n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (pic1.width() &gt; pic1.height()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; pic1.width(); x++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!IsBlack(pic1, x, pic1.height() / <span class="number">2</span>)) &#123;</span><br><span class="line">sum_a_x += x;</span><br><span class="line">a_n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!IsBlack(pic1, x, pic1.height() / <span class="number">2</span>) &amp;&amp; !IsBlack(pic2, x, pic1.height() / <span class="number">2</span>)) &#123;</span><br><span class="line">sum_overlap_x += x;</span><br><span class="line">overlap_n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; pic1.height(); y++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!IsBlack(pic1, pic1.width() / <span class="number">2</span>, y)) &#123;</span><br><span class="line">sum_a_y += y;</span><br><span class="line">a_n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!IsBlack(pic1, pic1.width() / <span class="number">2</span>, y) &amp;&amp; !IsBlack(pic2, pic2.width() / <span class="number">2</span>, y)) &#123;</span><br><span class="line">sum_overlap_y += y;</span><br><span class="line">overlap_n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> min_len = (pic1.width() &lt; pic1.height()) ? pic1.width() : pic1.height();</span><br><span class="line"><span class="keyword">int</span> n_level = <span class="built_in">floor</span>(log2(min_len));</span><br><span class="line"><span class="built_in">vector</span>&lt;CImg&lt;<span class="keyword">float</span>&gt; &gt; a_pyramid(n_level);</span><br><span class="line"><span class="built_in">vector</span>&lt;CImg&lt;<span class="keyword">float</span>&gt; &gt; b_pyramid(n_level);</span><br><span class="line"><span class="built_in">vector</span>&lt;CImg&lt;<span class="keyword">float</span>&gt; &gt; mask(n_level);</span><br><span class="line"><span class="comment">// Initialize the base.</span></span><br><span class="line">a_pyramid[<span class="number">0</span>] = pic1;</span><br><span class="line">b_pyramid[<span class="number">0</span>] = pic2;</span><br><span class="line">mask[<span class="number">0</span>] = CImg&lt;<span class="keyword">float</span>&gt;(pic1.width(), pic1.height(), <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pic1.width() &gt; pic1.height()) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum_a_x / a_n &lt; sum_overlap_x / overlap_n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; sum_overlap_x / overlap_n; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; pic1.height(); y++) &#123;</span><br><span class="line">mask[<span class="number">0</span>](x, y) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = sum_overlap_x / overlap_n + <span class="number">1</span>; x &lt; pic1.width(); x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; pic1.height(); y++) &#123;</span><br><span class="line">mask[<span class="number">0</span>](x, y) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (sum_a_y / a_n &lt; sum_overlap_y / overlap_n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; pic1.width(); x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; sum_overlap_y / overlap_n; y++) &#123;</span><br><span class="line">mask[<span class="number">0</span>](x, y) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; pic1.width(); x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = sum_overlap_y / overlap_n; y &lt; pic1.height(); y++) &#123;</span><br><span class="line">mask[<span class="number">0</span>](x, y) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Down sampling a and b, building Gaussian pyramids.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n_level; i++) &#123;</span><br><span class="line">a_pyramid[i] = a_pyramid[i - <span class="number">1</span>].get_blur(<span class="number">2</span>).get_resize(a_pyramid[i - <span class="number">1</span>].width() / <span class="number">2</span>, a_pyramid[i - <span class="number">1</span>].height() / <span class="number">2</span>, <span class="number">1</span>, a_pyramid[i - <span class="number">1</span>].spectrum(), <span class="number">3</span>);</span><br><span class="line">b_pyramid[i] = b_pyramid[i - <span class="number">1</span>].get_blur(<span class="number">2</span>).get_resize(b_pyramid[i - <span class="number">1</span>].width() / <span class="number">2</span>, b_pyramid[i - <span class="number">1</span>].height() / <span class="number">2</span>, <span class="number">1</span>, b_pyramid[i - <span class="number">1</span>].spectrum(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">mask[i] = mask[i - <span class="number">1</span>].get_blur(<span class="number">2</span>).get_resize(mask[i - <span class="number">1</span>].width() / <span class="number">2</span>, mask[i - <span class="number">1</span>].height() / <span class="number">2</span>, <span class="number">1</span>, mask[i - <span class="number">1</span>].spectrum(), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Building Laplacian pyramids.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_level - <span class="number">1</span>; i++) &#123;</span><br><span class="line">a_pyramid[i] = a_pyramid[i] - a_pyramid[i + <span class="number">1</span>].get_resize(a_pyramid[i].width(), a_pyramid[i].height(), <span class="number">1</span>, a_pyramid[i].spectrum(), <span class="number">3</span>);</span><br><span class="line">b_pyramid[i] = b_pyramid[i] - b_pyramid[i + <span class="number">1</span>].get_resize(b_pyramid[i].width(), b_pyramid[i].height(), <span class="number">1</span>, b_pyramid[i].spectrum(), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;CImg&lt;<span class="keyword">float</span>&gt; &gt; blend_pyramid(n_level);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_level; i++) &#123;</span><br><span class="line">blend_pyramid[i] = CImg&lt;<span class="keyword">float</span>&gt;(a_pyramid[i].width(), a_pyramid[i].height(), <span class="number">1</span>, a_pyramid[i].spectrum(), <span class="number">0</span>);</span><br><span class="line">cimg_forXYC(blend_pyramid[i], x, y, c) &#123;</span><br><span class="line">blend_pyramid[i](x, y, c) = a_pyramid[i](x, y, c) * mask[i](x, y) + b_pyramid[i](x, y, c) * (<span class="number">1.0</span> - mask[i](x, y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CImg&lt;<span class="keyword">float</span>&gt; res = blend_pyramid[n_level - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n_level - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">res.resize(blend_pyramid[i].width(), blend_pyramid[i].height(), <span class="number">1</span>, blend_pyramid[i].spectrum(), <span class="number">3</span>);</span><br><span class="line">cimg_forXYC(blend_pyramid[i], x, y, c) &#123;</span><br><span class="line">res(x, y, c) = blend_pyramid[i](x, y, c) + res(x, y, c);</span><br><span class="line"><span class="keyword">if</span> (res(x, y, c) &gt; <span class="number">255</span>) res(x, y, c) = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (res(x, y, c) &lt; <span class="number">0</span>) res(x, y, c) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后封装成类："><a href="#最后封装成类：" class="headerlink" title="最后封装成类："></a>最后封装成类：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageStitching</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//源图列表</span></span><br><span class="line">    CImgList&lt;<span class="keyword">float</span>&gt; imgs;</span><br><span class="line">    <span class="comment">//拼接后的图像</span></span><br><span class="line">    CImg&lt;<span class="keyword">float</span>&gt; resultImg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//柱面投影</span></span><br><span class="line">    CImg&lt;<span class="keyword">float</span>&gt; CylindricalProjection(CImg&lt;<span class="keyword">float</span>&gt; pic);</span><br><span class="line">    <span class="comment">//图像从rgb空间转为灰度空间</span></span><br><span class="line">    CImg&lt;<span class="keyword">float</span>&gt; convertTogray(CImg&lt;<span class="keyword">float</span>&gt; pic);</span><br><span class="line">    <span class="comment">//提取图像中的特征点</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt; SIFTFeatures(CImg&lt;<span class="keyword">float</span>&gt; pic);</span><br><span class="line">    <span class="comment">//k-d树进行特征点匹配</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;point_pair&gt; KDtreeMatch(<span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt; feature_a, <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;, VlSiftKeypoint&gt; feature_b);</span><br><span class="line">    <span class="comment">//利用RANSAC算法求单应矩阵</span></span><br><span class="line">    <span class="function">points <span class="title">RANSAC</span><span class="params">(<span class="built_in">vector</span>&lt;point_pair&gt; pairs)</span></span>;</span><br><span class="line">    <span class="comment">//通过单应矩阵扭曲两幅图像内容</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WarpTwoImg</span><span class="params">(CImg&lt;<span class="keyword">float</span>&gt; src, CImg&lt;<span class="keyword">float</span>&gt; &amp;dst, points H, <span class="keyword">float</span> offset_x, <span class="keyword">float</span> offset_y)</span></span>;</span><br><span class="line">    <span class="comment">//移动两幅图像</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MoveTwoImg</span><span class="params">(CImg&lt;<span class="keyword">float</span>&gt; src, CImg&lt;<span class="keyword">float</span>&gt; &amp;dst, <span class="keyword">int</span> offset_x, <span class="keyword">int</span> offset_y)</span></span>;</span><br><span class="line">    <span class="comment">//图像拼接</span></span><br><span class="line">    CImg&lt;<span class="keyword">float</span>&gt; Blend(CImg&lt;<span class="keyword">float</span>&gt; pic1, CImg&lt;<span class="keyword">float</span>&gt; pic2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ImageStitching();</span><br><span class="line">    ~ImageStitching();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StitchProcess</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果拼接出的图像："><a href="#结果拼接出的图像：" class="headerlink" title="结果拼接出的图像："></a>结果拼接出的图像：</h3><p><img src="https://img-blog.csdnimg.cn/20181209194726866.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20181209194741175.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="实验总结："><a href="#实验总结：" class="headerlink" title="实验总结："></a>实验总结：</h4><p>程序复杂度过高，第二组图跑了半个小时，不过也跟自己虚拟机分配的内存和处理器不足有关。代码而言一方面是SIFT算法本身复杂度就比较高，网上有提到SIFT的简化版SURF的复杂度会低很多，其次自己在边缘处的一些插值算法以及图像拼接处的平滑等也大大提高了算法复杂度。有时间之后会思考去改进一下。</p><p>再就是最大的缺点感觉柱面投影时图片边缘存在许多毛刺，这个本来以为用了插值算法会大大减少这种像素点，结果还是看起来比较明显。同时图像接合处的用滤波的效果感觉不如开始使用opencv库尝试的时候溶解效果好，到时会去读一下opencv中溶解的源码了解一下这类的算法。</p><p><strong>完整代码参见：</strong><br><a href="https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp6" target="_blank" rel="noopener">https://github.com/WangPerryWPY/Computer-Version/tree/master/Exp6</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;编译运行：&quot;&gt;&lt;a href=&quot;#编译运行：&quot; class=&quot;headerlink&quot; title=&quot;编译运行：&quot;&gt;&lt;/a&gt;编译运行：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;运行环境&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ubuntu 18&lt;/code&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>自适应的霍夫曼编码与原始的霍夫曼编码的比较</title>
    <link href="http://yoursite.com/2019/07/06/%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E4%B8%8E%E5%8E%9F%E5%A7%8B%E7%9A%84%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2019/07/06/自适应的霍夫曼编码与原始的霍夫曼编码的比较/</id>
    <published>2019-07-06T13:07:54.000Z</published>
    <updated>2019-07-06T13:08:30.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h2><h4 id="a-自适应的霍夫曼编码与原始的霍夫曼编码相比什么优点："><a href="#a-自适应的霍夫曼编码与原始的霍夫曼编码相比什么优点：" class="headerlink" title="(a) 自适应的霍夫曼编码与原始的霍夫曼编码相比什么优点："></a>(a) 自适应的霍夫曼编码与原始的霍夫曼编码相比什么优点：</h4><ol><li>原始的Huffman算法给出了一种静态的编码树构造方案，要求在实际编码之前统计被编码对象中符号出现的几率，并据此进行编码树的构造。所以应用此方案时必须对输入符号流进行两遍扫描，而在大多数多媒体应用中数据分布的先前统计数据是不可行的。</li><li>另外，静态编码树构造方案不能对符号流的局部统计规律变化做出反应，因为它从始至终都使用完全不变的编码树。而自适应Huffman编码不需要事先构造Huffman树，而是随着编码的进行，逐步构造Huffman树。同时，这种编码方案对符号的统计也动态进行，随着程序的运行，同一个符号的编码可能发生改变（变得更长或更短）。</li><li>再者就静态编码在储存或传输Huffman编码结果之前，还必须先储存或传输Huffman编码树，自适应霍夫曼编码则不需要，这大大节省了内存开销。</li></ol><h4 id="b"><a href="#b" class="headerlink" title="(b)"></a>(b)</h4><h5 id="i-接收到的后续几个字母是什么"><a href="#i-接收到的后续几个字母是什么" class="headerlink" title="(i)接收到的后续几个字母是什么"></a>(i)接收到的后续几个字母是什么</h5><p>接收到的后续的几个字母分别是 <strong>b(01) a(01) c(00 10) c(101)</strong></p><p>(推导过程同第二问)</p><p><strong>(ii)画出接收每一个后续字母后的自适应霍夫曼树</strong></p><p><img src="https://img-blog.csdnimg.cn/2018120919340015.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>fig 1</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209193415577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>fig 2</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209193427609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>fig 3</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209193435475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>fig 4</strong></p><p><strong>推导过程：</strong></p><table><thead><tr><th>步骤</th><th>字符</th><th>分析</th></tr></thead><tbody><tr><td>一</td><td>01</td><td>从7-11图定位到01为b，然后b的权值+1,此时b的节点权值变为3&gt;a(2)，b与a交换位置，huffman树变为fig1</td></tr><tr><td>二</td><td>01</td><td>从fig1定位到01为a，然后a权值+1，此时a的节点权值变为3=b(3)，树的节点不做变动，huffman树变为fig2</td></tr><tr><td>三</td><td>00 10</td><td>根据fig2定位到00是new，意味着有新字符的加入，然后根据下面的10知道新加入的字符是c，然后用包含c和new的子树替换旧的new节点，然后将a的父节点的权值+1变为4&gt;b(3)，与b交换位置，得到fig3</td></tr><tr><td>四</td><td>101</td><td>根据fig3定位到c，然后将相应的节点权值分别+1，发现没有需要置换的节点和子树，得到fig4</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一题：&quot;&gt;&lt;a href=&quot;#第一题：&quot; class=&quot;headerlink&quot; title=&quot;第一题：&quot;&gt;&lt;/a&gt;第一题：&lt;/h2&gt;&lt;h4 id=&quot;a-自适应的霍夫曼编码与原始的霍夫曼编码相比什么优点：&quot;&gt;&lt;a href=&quot;#a-自适应的霍夫曼编码与原始的霍夫曼
      
    
    </summary>
    
      <category term="多媒体技术" scheme="http://yoursite.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="多媒体技术" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>GIF压缩与JPEG压缩对比</title>
    <link href="http://yoursite.com/2019/07/06/GIF%E5%8E%8B%E7%BC%A9%E4%B8%8EJPEG%E5%8E%8B%E7%BC%A9%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2019/07/06/GIF压缩与JPEG压缩对比/</id>
    <published>2019-07-06T13:06:15.000Z</published>
    <updated>2019-07-06T13:06:42.916Z</updated>
    
    <content type="html"><![CDATA[<h4 id="图片示范"><a href="#图片示范" class="headerlink" title="图片示范"></a>图片示范</h4><p><img src="https://img-blog.csdnimg.cn/20181209193758218.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="动物卡通图片"><center><strong>fig: 动物卡通图片</strong></center></p><p><img src="https://img-blog.csdnimg.cn/20181209193850976.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><center><strong>fig: 动物图片</strong></center></p><h4 id="GIF格式"><a href="#GIF格式" class="headerlink" title="GIF格式"></a>GIF格式</h4><p>其中GIF格式采用的是LZW的无损压缩算法，这是一种字典索引的压缩方法，原理是减少每点的存储位数以减少图像文件的大小，也就是通常所说的颜色抖动。因而实际存储数据的并不是图像的直接色彩，而是存储的index，通过index来查询存储颜色的字典（类似我们上次作业实现的采色板）。index通常最高是存储八位，也就是2^8=256种颜色。</p><p>但实际在用rgb存储时，一副全色图像是采用直接色彩存储，每色块存8*3=24位。</p><ul><li>我尝试对老师给的动物图片先转为bmp其大小为2095k，然后用ps转为8位gif，发现大小变为了257k，差不多变为原来的1/(2^3=8)</li></ul><p>所以对于色彩变化不明显的简单图片我们一般采用gif压缩，原因就是基于LZW的原理：原始数据串中有大量的子串多次重复出现的话LZW压缩效果效果就会越好。针对具体图像来说也就是颜色种类越少越好，像素块色彩值重复度就高。gif压缩不会丢失任何数据而且又比同等效果的jpg图要小。</p><h4 id="JPEG格式"><a href="#JPEG格式" class="headerlink" title="JPEG格式"></a>JPEG格式</h4><p>JPEG压缩是一种偏向平衡性的格式，它会舍弃掉人眼根本无法感知的颜色信息，以使文件尽可能小并且细节不丢失。因此，它是一种有损格式。它颜色丰富并且很适合那些允许轻微失真的像素色彩丰富的图片（如相片）。 </p><ul><li>jpeg的压缩比例主要是在于量化一步中对于图像细节的保留程度，这一步采用的量化表也是从广泛实验中根据人对色彩的敏感程度得出。而且根据亮度和色度的精度要求不同采用不同量化表。前者细量化，后者粗量化。</li><li>最后的熵编码一般采用霍夫曼编码，而JPEG的霍夫曼表是由一定规则生成，只要给出少量的描述即可生成相应的JPEG的霍夫曼表，这也减少了存储的字符位数。 </li></ul><p>JPEG的图片相比gif的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，用来表达更生动的图像效果，比如颜色渐变。 </p><h4 id="图片存储格式分析"><a href="#图片存储格式分析" class="headerlink" title="图片存储格式分析"></a>图片存储格式分析</h4><p>所以对于动物图片这张图，它的颜色丰富度比较低，同时也已经存为jpg了，再二次压缩为jpg会失真度较高，也就是显得很糊，因而我们适合采用gif压缩。</p><p>而动物卡通图片这张图颜色种类丰富，渐变也比较明显，因而只用256种色彩存储很难达到较好的色彩效果，所以采用jpeg压缩。</p><p><strong>首先先比较第一张动物图片。</strong>先看压缩率，将第一幅图存为同等效果的jpg和gif，gif的图片大小为410k，而jpg的图片大小为521k；接着再看失真率，因为gif是无损压缩，而jpg是有损压缩，所以gif图片视觉的清晰度要高于jpg压缩，失真度较小。所以第一幅图无论是从压缩率还是失真率来说gif压缩都会略胜一筹。</p><h3 id="结果对比部分："><a href="#结果对比部分：" class="headerlink" title="结果对比部分："></a>结果对比部分：</h3><p><strong>jpg</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209194404217.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>gif</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209194417507.gif" alt="在这里插入图片描述"></p><p><strong>然后比较第二幅动物卡通图片。</strong>从压缩率来看，从同一张图片进行同等效果的压缩后gif的大小为348k，而jpg的大小为210k。接着根据失真度比较，gif最多只能存储8位，也就是256种颜色。而jpg虽然有一定的数据精度损失，但是是以直接色彩的方式存储，颜色丰富程度要远好于gif，而对于一些细节的渐变效果也比较好，所以这幅图jpg的视觉效果较好。所以综合压缩率和失真率来说这幅图用jpeg压缩效果更好。</p><p><strong>jpg</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209194238817.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>gif</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209194250127.gif" alt="在这里插入图片描述"></p><p><strong>ps:</strong>为什么同样是gif压缩第一幅图就会比jpg占内存小而第二幅图就会比jpg大呢？个人分析是因为第一幅图色彩丰富度太低，图片颜色种类少于256种，所以gif存储不需要8位(1~7位即可)就可以将图片色彩全部表示。而第二幅图色彩丰富度较高，颜色种类多于256种，gif最多也只能存八位，所以是将图片以8位索引的形式存的，图片大小就大于gif。</p><p>之后试了一下将第一幅图用ps强行存为8位，图片的内存大小也确实要比jpg大，所以得出结论如果将gif存为8位（256色索引），它的压缩效果是要比jpeg压缩差的，而且视觉上的色彩丰富程度也不达jpg。然而如果图片色彩丰富度低，例如能用128甚至更少的色彩存储，那么gif的压缩效果是会比jpg好，同时因为是无损压缩又不会造成图片的失真。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;图片示范&quot;&gt;&lt;a href=&quot;#图片示范&quot; class=&quot;headerlink&quot; title=&quot;图片示范&quot;&gt;&lt;/a&gt;图片示范&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181209193758218.jpg?x-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JPEG压缩算法</title>
    <link href="http://yoursite.com/2019/07/06/JPEG%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/07/06/JPEG压缩算法/</id>
    <published>2019-07-06T13:04:46.000Z</published>
    <updated>2019-07-06T13:05:31.983Z</updated>
    
    <content type="html"><![CDATA[<p><strong>编译环境</strong></p><p>windows10下MinGW</p><p><strong>编译语言</strong></p><p>c++ &amp;&amp; CImg库</p><p><strong>运行命令</strong></p><p><code>g++ -o test main.cpp jpegCompress.cpp jpegCompress.h -O2 -lgdi32</code></p><h4 id="1-8x8分块"><a href="#1-8x8分块" class="headerlink" title="1. 8x8分块"></a>1. 8x8分块</h4><p>因为之后的DCT变换是要对8x8的子块为一个单位进行处理，所以为了方便第一步我们就进行分块。所以源图的width和height必须要是8的倍数，所以我们对源图进行初始化处理，如果不是8的倍数的话我们要用0对其进行两侧的填充。</p><p><strong>初始化处理：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//载入图片，并对图片进行初始化处理</span></span><br><span class="line"><span class="comment">//如果图片的宽高不是8的倍数，则将两边均匀填0</span></span><br><span class="line">source.load(fileName);</span><br><span class="line"><span class="keyword">int</span> width = source._width;</span><br><span class="line"><span class="keyword">int</span> height = source._height;</span><br><span class="line"><span class="keyword">int</span> width1 = width % <span class="number">8</span> == <span class="number">0</span> ? width : (width / <span class="number">8</span> + <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> height1 = height % <span class="number">8</span> ==<span class="number">0</span> ? height : (height / <span class="number">8</span> + <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line">CImg&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; source_a(width1, height1, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">cimg_forXY(source_a, x, y) &#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; width &amp;&amp; y &lt; height) &#123;</span><br><span class="line">source_a(x + (width1 - width) / <span class="number">2</span>, y + (height1 - height) / <span class="number">2</span>, <span class="number">0</span>) = source(x, y, <span class="number">0</span>);</span><br><span class="line">source_a(x + (width1 - width) / <span class="number">2</span>, y + (height1 - height) / <span class="number">2</span>, <span class="number">1</span>) = source(x, y, <span class="number">1</span>);</span><br><span class="line">source_a(x + (width1 - width) / <span class="number">2</span>, y + (height1 - height) / <span class="number">2</span>, <span class="number">2</span>) = source(x, y, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">source = source_a;</span><br><span class="line">Width = source._width;</span><br><span class="line">Height = source._height;</span><br></pre></td></tr></table></figure><p><strong>分块：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次取8x8的小块进行处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> yPos=<span class="number">0</span>; yPos&lt;Height; yPos+=<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> xPos=<span class="number">0</span>; xPos&lt;Width; xPos+=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><h4 id="2-颜色空间转换"><a href="#2-颜色空间转换" class="headerlink" title="2.颜色空间转换"></a>2.颜色空间转换</h4><p> JPEG采用的是YCrCb颜色空间，而正常的编程软件读入图片后都会转为rgb格式，这也是bmp文件存储的颜色空间。所以要进行颜色空间转换。。YCrCb颜色空间中，Y代表亮度，Cr,Cb则代表色度和饱和度(也有人将Cb,Cr两者统称为色度)，三者通常以Y,U,V来表示，即用U代表Cb，用V代表Cr。RGB和YCrCb之间的转换关系如下：<br>$$<br>Y = 0.299R+0.587G+0.114B<br>$$</p><p>$$<br>Cb = -0.1687R-0.3313G+0.5B+128<br>$$</p><p>$$<br>Cr = 0.5R=0.418G-0.0813B+128<br>$$</p><p><strong>代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JpegCompress::RGB2YCbCr(<span class="keyword">int</span> xPos, <span class="keyword">int</span> yPos, <span class="keyword">char</span>* y_channel, <span class="keyword">char</span>* cd_channel, <span class="keyword">char</span>* cr_channel)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;<span class="number">8</span>; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">8</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> R = source(xPos+x,yPos+y,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> G = source(xPos+x,yPos+y,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> B = source(xPos+x,yPos+y,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">y_channel[y*<span class="number">8</span>+x] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(<span class="number">0.299f</span> * R + <span class="number">0.587f</span> * G + <span class="number">0.114f</span> * B - <span class="number">128</span>);</span><br><span class="line">cd_channel[y*<span class="number">8</span>+x] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(<span class="number">-0.1687f</span> * R - <span class="number">0.3313f</span> * G + <span class="number">0.5f</span> * B );</span><br><span class="line">cr_channel[y*<span class="number">8</span>+x] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(<span class="number">0.5f</span> * R - <span class="number">0.4187f</span> * G - <span class="number">0.0813f</span> * B);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现效果：</strong><br><img src="https://img-blog.csdnimg.cn/20181209192404758.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>对应的分别是Y,Cb,Cr三个空间的图片：</strong></p><p><img src="https://img-blog.csdnimg.cn/20181209192346295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3-离散余弦变换-DCT"><a href="#3-离散余弦变换-DCT" class="headerlink" title="3.离散余弦变换(DCT)"></a>3.离散余弦变换(DCT)</h4><p>$$<br>F(u,v) = alpha(u)<em>alpha(v)</em>\sum_{x=0}^{7}\sum_{y=0}^{7} f(x,y)\cos(\frac{2x+1}{16}u\pi)cos(\frac{2y+1}{16}v\pi) \qquad u,v=0,1,…,7<br>$$</p><p>$$<br>alpha(u) = \left{<br>\begin{aligned}<br>1/ \sqrt{8} \qquad when ;  u = 0 \<br>1 / \quad 2  \qquad when ; u  \neq 0<br>\end{aligned}<br>\right.<br>$$</p><p>8x8的二维像素块经过DCT操作之后，就得到了8x8的变换系数矩阵。这些系数，都有具体的物理含义，例如，U=0，V=0时的F（0,0）是原来的64个数据的均值，相当于直流分量，也有人称之为DC系数或者直流系数。随着U，V的增加，相另外的63个系数则代表了水平空间频率和垂直空间频率分量（高频分量）的大小，多半是一些接近于0的正负浮点数，我们称之为交流系数AC。DCT变换后的8*8的系数矩阵中，低频分量集中在矩阵的左上角。高频成分则集中在右下角。</p><p><strong>DCT变换代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JpegCompress::DCT(<span class="keyword">const</span> <span class="keyword">char</span>* channel_data, <span class="keyword">float</span>* fdc_data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;<span class="number">8</span>; v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;<span class="number">8</span>; u++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> alpha_u = (u==<span class="number">0</span>) ? <span class="number">1</span>/<span class="built_in">sqrt</span>(<span class="number">8.0f</span>) : <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">float</span> alpha_v = (v==<span class="number">0</span>) ? <span class="number">1</span>/<span class="built_in">sqrt</span>(<span class="number">8.0f</span>) : <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">float</span> f_xy = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">8</span>; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;<span class="number">8</span>; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> data = channel_data[y*<span class="number">8</span>+x];</span><br><span class="line">data *= <span class="built_in">cos</span>((<span class="number">2</span>*x+<span class="number">1</span>)*u*PI/<span class="number">16.0f</span>);</span><br><span class="line">data *= <span class="built_in">cos</span>((<span class="number">2</span>*y+<span class="number">1</span>)*v*PI/<span class="number">16.0f</span>);</span><br><span class="line">f_xy += data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fdc_data[v*<span class="number">8</span>+u] = f_xy * alpha_u * alpha_v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于大多数图像的高频分量比较小，相应的图像高频分量的DCT系数经常接近于0，再加上高频分量中只包含了图像的细微的细节变化信息，而人眼对这种高频成分的失真不太敏感，所以，可以考虑将这一些高频成分予以抛弃，从而降低需要传输的数据量。这样一来，传送DCT变换系数的所需要的编码长度要远远小于传送图像像素的编码长度。到达接收端之后通过反离散余弦变换就可以得到原来的数据，虽然这么做存在一定的失真，但人眼是可接受的，而且对这种微小的变换是不敏感的。</p><h4 id="4-量化"><a href="#4-量化" class="headerlink" title="4.量化"></a>4.量化</h4><p>量化阶段需要两个8*8量化矩阵数据，一个是专门处理亮度的频率系数，另一个则是针对色度的频率系数，将频率系数除以量化矩阵的值之后取整，即完成了量化过程。当频率系数经过量化之后，将频率系数由浮点数转变为整数，这才便于执行最后的编码。不难发现，经过量化阶段之后，所有的数据只保留了整数近似值，也就再度损失了一些数据内容。在JPEG算法中，由于对亮度和色度的精度要求不同，分别对亮度和色度采用不同的量化表。前者细量化，后者粗量化。</p><p><img src="https://img-blog.csdnimg.cn/20181209192631703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标准亮度量化表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Luminance_Quantization_Table[<span class="number">64</span>] = </span><br><span class="line">&#123;</span><br><span class="line"><span class="number">16</span>,  <span class="number">11</span>,  <span class="number">10</span>,  <span class="number">16</span>,  <span class="number">24</span>,  <span class="number">40</span>,  <span class="number">51</span>,  <span class="number">61</span>,</span><br><span class="line"><span class="number">12</span>,  <span class="number">12</span>,  <span class="number">14</span>,  <span class="number">19</span>,  <span class="number">26</span>,  <span class="number">58</span>,  <span class="number">60</span>,  <span class="number">55</span>,</span><br><span class="line"><span class="number">14</span>,  <span class="number">13</span>,  <span class="number">16</span>,  <span class="number">24</span>,  <span class="number">40</span>,  <span class="number">57</span>,  <span class="number">69</span>,  <span class="number">56</span>,</span><br><span class="line"><span class="number">14</span>,  <span class="number">17</span>,  <span class="number">22</span>,  <span class="number">29</span>,  <span class="number">51</span>,  <span class="number">87</span>,  <span class="number">80</span>,  <span class="number">62</span>,</span><br><span class="line"><span class="number">18</span>,  <span class="number">22</span>,  <span class="number">37</span>,  <span class="number">56</span>,  <span class="number">68</span>, <span class="number">109</span>, <span class="number">103</span>,  <span class="number">77</span>,</span><br><span class="line"><span class="number">24</span>,  <span class="number">35</span>,  <span class="number">55</span>,  <span class="number">64</span>,  <span class="number">81</span>, <span class="number">104</span>, <span class="number">113</span>,  <span class="number">92</span>,</span><br><span class="line"><span class="number">49</span>,  <span class="number">64</span>,  <span class="number">78</span>,  <span class="number">87</span>, <span class="number">103</span>, <span class="number">121</span>, <span class="number">120</span>, <span class="number">101</span>,</span><br><span class="line"><span class="number">72</span>,  <span class="number">92</span>,  <span class="number">95</span>,  <span class="number">98</span>, <span class="number">112</span>, <span class="number">100</span>, <span class="number">103</span>,  <span class="number">99</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标准色差量化表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Chrominance_Quantization_Table[<span class="number">64</span>] = </span><br><span class="line">&#123;</span><br><span class="line"><span class="number">17</span>, <span class="number">18</span>, <span class="number">24</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line"><span class="number">18</span>, <span class="number">21</span>, <span class="number">26</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line"><span class="number">24</span>, <span class="number">26</span>, <span class="number">56</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line"><span class="number">47</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line"><span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line"><span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line"><span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line"><span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>量化表也是控制 JPEG 压缩比的关键。这个步骤除掉了一些高频量, 损失了很高细节。但事实上人眼对高空间频率远没有低频敏感.所以处理后的视觉损失很小。</li><li>另一个重要原因是所有的图片的点与点之间会有一个色彩过渡的过程. 大量的图象信息被包含在低空间频率中。经过量化处理后, 在高空间频率段, 将出现大量连续的零。</li><li>我的调整方式是设为10个等级，等级越高压缩比例也越大，得到的图片越小。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JpegCompress::InitQualityTables(<span class="keyword">int</span> quality)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> quant = Luminance_Quantization_Table[i] * quality / <span class="number">10</span>;</span><br><span class="line">quant == <span class="number">0</span> ? Y_Table[ZigZag[i]] = <span class="number">1</span>:Y_Table[ZigZag[i]] = quant;</span><br><span class="line">quant = Chrominance_Quantization_Table[i] * quality / <span class="number">10</span>;</span><br><span class="line">quant == <span class="number">0</span> ? CbCr_Table[ZigZag[i]] = <span class="number">1</span>:CbCr_Table[ZigZag[i]] = quant;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用得到的处理后的量化表进行量化处理：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JpegCompress::Quality(<span class="keyword">float</span>* fdc_data, <span class="keyword">short</span>* Quant, <span class="keyword">unsigned</span> <span class="keyword">char</span>* Table) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;<span class="number">8</span>; v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;<span class="number">8</span>; u++)</span><br><span class="line">&#123;</span><br><span class="line">Quant[ZigZag[v*<span class="number">8</span>+u]] = round(fdc_data[v*<span class="number">8</span>+u] / Table[ZigZag[v*<span class="number">8</span>+u]]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>矩阵的量化最后一步是把量化后的二维矩阵转变成一个一维数组，以方便后面的霍夫曼压缩，但在做这个顺序转换时，需要按照一个特定的取值顺序 。也就是我们说的<strong>ZigZag扫描</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于对量化后的矩阵进行顺序调整</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ZigZag[<span class="number">64</span>] =</span><br><span class="line">&#123; </span><br><span class="line"> <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">27</span>, <span class="number">28</span>,</span><br><span class="line"> <span class="number">2</span>,  <span class="number">4</span>,  <span class="number">7</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">26</span>, <span class="number">29</span>, <span class="number">42</span>,</span><br><span class="line"> <span class="number">3</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">41</span>, <span class="number">43</span>,</span><br><span class="line"> <span class="number">9</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">40</span>, <span class="number">44</span>, <span class="number">53</span>,</span><br><span class="line"><span class="number">10</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">32</span>, <span class="number">39</span>, <span class="number">45</span>, <span class="number">52</span>, <span class="number">54</span>,</span><br><span class="line"><span class="number">20</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">38</span>, <span class="number">46</span>, <span class="number">51</span>, <span class="number">55</span>, <span class="number">60</span>,</span><br><span class="line"><span class="number">21</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">50</span>, <span class="number">56</span>, <span class="number">59</span>, <span class="number">61</span>,</span><br><span class="line"><span class="number">35</span>, <span class="number">36</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">62</span>, <span class="number">63</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-Huffman编码"><a href="#5-Huffman编码" class="headerlink" title="5.Huffman编码"></a>5.Huffman编码</h4><h5 id="a-DC系数的DPCM编码："><a href="#a-DC系数的DPCM编码：" class="headerlink" title="a. DC系数的DPCM编码："></a>a. DC系数的DPCM编码：</h5><p>即取同一个图像分量中每个DC值与前一个DC值的差值来进行编码。这样对差值进行编码所需要的位数会比对原值进行编码所需要的位数少了很多 。</p><ul><li>这是基于DC系数的两个特点：<ul><li>系数的数值比较大；</li><li>相邻的8*8图像块的DC系数值变化不大；</li></ul></li></ul><p><strong>代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对DC分量进行DPCM编码</span></span><br><span class="line"><span class="keyword">int</span> dcDiff = (<span class="keyword">int</span>)(Quant[<span class="number">0</span>] - prev);</span><br><span class="line">prev = Quant[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (dcDiff == <span class="number">0</span>) &#123;</span><br><span class="line">outputBit[ptr] = DC_Table[<span class="number">0</span>];</span><br><span class="line">ptr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Bit B;</span><br><span class="line"><span class="keyword">int</span> v = <span class="built_in">abs</span>(dcDiff);</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (v) &#123;</span><br><span class="line">length++;</span><br><span class="line">v /= <span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line">B.value = dcDiff&gt;<span class="number">0</span> ? dcDiff : (<span class="built_in">pow</span>(<span class="number">2</span>,length)+dcDiff<span class="number">-1</span>);</span><br><span class="line">B.length = length;</span><br><span class="line">outputBit[ptr] = DC_Table[B.length];</span><br><span class="line">ptr++;</span><br><span class="line">outputBit[ptr] = B;</span><br><span class="line">ptr++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-AC系数的游长编码："><a href="#b-AC系数的游长编码：" class="headerlink" title="b. AC系数的游长编码："></a>b. AC系数的游长编码：</h5><p>量化之后的AC系数的特点是，63个系数中含有很多值为0的系数，尤其是在ZigZag扫描之后0大部分集中在数组的后面位置。因此，可以采用行程编码RLC（Run Length Coding）来更进一步降低数据的传输量。利用该编码方式，可以将一个字符串中重复出现的连续字符用两个字节来代替，其中，第一个字节代表重复的次数，第二个字节代表被重复的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对AC分量进行游长编码</span></span><br><span class="line"><span class="keyword">int</span> end = <span class="number">63</span>;</span><br><span class="line"><span class="comment">//找到最后不为0的之前部分，后面为0的全部置为EOB</span></span><br><span class="line"><span class="keyword">while</span>((end &gt; <span class="number">0</span>) &amp;&amp; (Quant[end] == <span class="number">0</span>)) end--;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=end; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> start = i;</span><br><span class="line"><span class="keyword">while</span>((Quant[i] == <span class="number">0</span>) &amp;&amp; (i &lt;= end)) i++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = i - start;</span><br><span class="line"><span class="keyword">if</span> (count &gt;= <span class="number">16</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=count/<span class="number">16</span>; j++) &#123;</span><br><span class="line">outputBit[ptr] = AC_Table[<span class="number">0xF0</span>];</span><br><span class="line">ptr++;</span><br><span class="line">&#125;</span><br><span class="line">count = count%<span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line">Bit B;</span><br><span class="line"><span class="keyword">int</span> v = <span class="built_in">abs</span>(Quant[i]);</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (v) &#123;</span><br><span class="line">length++;</span><br><span class="line">v /= <span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line">B.value = Quant[i]&gt;<span class="number">0</span> ? Quant[i] : (<span class="built_in">pow</span>(<span class="number">2</span>,length)+Quant[i]<span class="number">-1</span>);</span><br><span class="line">B.length = length;</span><br><span class="line">outputBit[ptr] = AC_Table[(count * <span class="number">16</span>) | B.length];</span><br><span class="line">ptr++;</span><br><span class="line">outputBit[ptr] = B;</span><br><span class="line">ptr++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (end != <span class="number">63</span>) &#123;</span><br><span class="line">outputBit[ptr] = AC_Table[<span class="number">0x00</span>];</span><br><span class="line">ptr++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-熵编码（Huffman编码）"><a href="#c-熵编码（Huffman编码）" class="headerlink" title="c. 熵编码（Huffman编码）"></a>c. 熵编码（Huffman编码）</h5><p>Huffman编码时DC系数与AC系数分别采用不同的Huffman编码表，对于亮度和色度也采用不同的Huffman编码表。因此，需要4张Huffman编码表才能完成熵编码的工作。具体的Huffman编码采用查表的方式来高效地完成。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标准直流分量色度亮度哈夫曼表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> Standard_DC_Luminance_NRCodes[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Standard_DC_Luminance_Values[] = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> Standard_DC_Chrominance_NRCodes[] = &#123; <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Standard_DC_Chrominance_Values[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标准交流分量色度亮度哈夫曼表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> Standard_AC_Luminance_NRCodes[] = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x7d</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Standard_AC_Luminance_Values[] = </span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x11</span>, <span class="number">0x05</span>, <span class="number">0x12</span>,</span><br><span class="line"><span class="number">0x21</span>, <span class="number">0x31</span>, <span class="number">0x41</span>, <span class="number">0x06</span>, <span class="number">0x13</span>, <span class="number">0x51</span>, <span class="number">0x61</span>, <span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x22</span>, <span class="number">0x71</span>, <span class="number">0x14</span>, <span class="number">0x32</span>, <span class="number">0x81</span>, <span class="number">0x91</span>, <span class="number">0xa1</span>, <span class="number">0x08</span>,</span><br><span class="line"><span class="number">0x23</span>, <span class="number">0x42</span>, <span class="number">0xb1</span>, <span class="number">0xc1</span>, <span class="number">0x15</span>, <span class="number">0x52</span>, <span class="number">0xd1</span>, <span class="number">0xf0</span>,</span><br><span class="line"><span class="number">0x24</span>, <span class="number">0x33</span>, <span class="number">0x62</span>, <span class="number">0x72</span>, <span class="number">0x82</span>, <span class="number">0x09</span>, <span class="number">0x0a</span>, <span class="number">0x16</span>,</span><br><span class="line"><span class="number">0x17</span>, <span class="number">0x18</span>, <span class="number">0x19</span>, <span class="number">0x1a</span>, <span class="number">0x25</span>, <span class="number">0x26</span>, <span class="number">0x27</span>, <span class="number">0x28</span>,</span><br><span class="line"><span class="number">0x29</span>, <span class="number">0x2a</span>, <span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x37</span>, <span class="number">0x38</span>, <span class="number">0x39</span>,</span><br><span class="line"><span class="number">0x3a</span>, <span class="number">0x43</span>, <span class="number">0x44</span>, <span class="number">0x45</span>, <span class="number">0x46</span>, <span class="number">0x47</span>, <span class="number">0x48</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x4a</span>, <span class="number">0x53</span>, <span class="number">0x54</span>, <span class="number">0x55</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x58</span>, <span class="number">0x59</span>,</span><br><span class="line"><span class="number">0x5a</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>, <span class="number">0x66</span>, <span class="number">0x67</span>, <span class="number">0x68</span>, <span class="number">0x69</span>,</span><br><span class="line"><span class="number">0x6a</span>, <span class="number">0x73</span>, <span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0x76</span>, <span class="number">0x77</span>, <span class="number">0x78</span>, <span class="number">0x79</span>,</span><br><span class="line"><span class="number">0x7a</span>, <span class="number">0x83</span>, <span class="number">0x84</span>, <span class="number">0x85</span>, <span class="number">0x86</span>, <span class="number">0x87</span>, <span class="number">0x88</span>, <span class="number">0x89</span>,</span><br><span class="line"><span class="number">0x8a</span>, <span class="number">0x92</span>, <span class="number">0x93</span>, <span class="number">0x94</span>, <span class="number">0x95</span>, <span class="number">0x96</span>, <span class="number">0x97</span>, <span class="number">0x98</span>,</span><br><span class="line"><span class="number">0x99</span>, <span class="number">0x9a</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>, <span class="number">0xa4</span>, <span class="number">0xa5</span>, <span class="number">0xa6</span>, <span class="number">0xa7</span>,</span><br><span class="line"><span class="number">0xa8</span>, <span class="number">0xa9</span>, <span class="number">0xaa</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>, <span class="number">0xb4</span>, <span class="number">0xb5</span>, <span class="number">0xb6</span>,</span><br><span class="line"><span class="number">0xb7</span>, <span class="number">0xb8</span>, <span class="number">0xb9</span>, <span class="number">0xba</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>, <span class="number">0xc4</span>, <span class="number">0xc5</span>,</span><br><span class="line"><span class="number">0xc6</span>, <span class="number">0xc7</span>, <span class="number">0xc8</span>, <span class="number">0xc9</span>, <span class="number">0xca</span>, <span class="number">0xd2</span>, <span class="number">0xd3</span>, <span class="number">0xd4</span>,</span><br><span class="line"><span class="number">0xd5</span>, <span class="number">0xd6</span>, <span class="number">0xd7</span>, <span class="number">0xd8</span>, <span class="number">0xd9</span>, <span class="number">0xda</span>, <span class="number">0xe1</span>, <span class="number">0xe2</span>,</span><br><span class="line"><span class="number">0xe3</span>, <span class="number">0xe4</span>, <span class="number">0xe5</span>, <span class="number">0xe6</span>, <span class="number">0xe7</span>, <span class="number">0xe8</span>, <span class="number">0xe9</span>, <span class="number">0xea</span>,</span><br><span class="line"><span class="number">0xf1</span>, <span class="number">0xf2</span>, <span class="number">0xf3</span>, <span class="number">0xf4</span>, <span class="number">0xf5</span>, <span class="number">0xf6</span>, <span class="number">0xf7</span>, <span class="number">0xf8</span>,</span><br><span class="line"><span class="number">0xf9</span>, <span class="number">0xfa</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> Standard_AC_Chrominance_NRCodes[] = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0x77</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Standard_AC_Chrominance_Values[] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x11</span>, <span class="number">0x04</span>, <span class="number">0x05</span>, <span class="number">0x21</span>,</span><br><span class="line"><span class="number">0x31</span>, <span class="number">0x06</span>, <span class="number">0x12</span>, <span class="number">0x41</span>, <span class="number">0x51</span>, <span class="number">0x07</span>, <span class="number">0x61</span>, <span class="number">0x71</span>,</span><br><span class="line"><span class="number">0x13</span>, <span class="number">0x22</span>, <span class="number">0x32</span>, <span class="number">0x81</span>, <span class="number">0x08</span>, <span class="number">0x14</span>, <span class="number">0x42</span>, <span class="number">0x91</span>,</span><br><span class="line"><span class="number">0xa1</span>, <span class="number">0xb1</span>, <span class="number">0xc1</span>, <span class="number">0x09</span>, <span class="number">0x23</span>, <span class="number">0x33</span>, <span class="number">0x52</span>, <span class="number">0xf0</span>,</span><br><span class="line"><span class="number">0x15</span>, <span class="number">0x62</span>, <span class="number">0x72</span>, <span class="number">0xd1</span>, <span class="number">0x0a</span>, <span class="number">0x16</span>, <span class="number">0x24</span>, <span class="number">0x34</span>,</span><br><span class="line"><span class="number">0xe1</span>, <span class="number">0x25</span>, <span class="number">0xf1</span>, <span class="number">0x17</span>, <span class="number">0x18</span>, <span class="number">0x19</span>, <span class="number">0x1a</span>, <span class="number">0x26</span>,</span><br><span class="line"><span class="number">0x27</span>, <span class="number">0x28</span>, <span class="number">0x29</span>, <span class="number">0x2a</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x37</span>, <span class="number">0x38</span>,</span><br><span class="line"><span class="number">0x39</span>, <span class="number">0x3a</span>, <span class="number">0x43</span>, <span class="number">0x44</span>, <span class="number">0x45</span>, <span class="number">0x46</span>, <span class="number">0x47</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x49</span>, <span class="number">0x4a</span>, <span class="number">0x53</span>, <span class="number">0x54</span>, <span class="number">0x55</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x58</span>,</span><br><span class="line"><span class="number">0x59</span>, <span class="number">0x5a</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>, <span class="number">0x66</span>, <span class="number">0x67</span>, <span class="number">0x68</span>,</span><br><span class="line"><span class="number">0x69</span>, <span class="number">0x6a</span>, <span class="number">0x73</span>, <span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0x76</span>, <span class="number">0x77</span>, <span class="number">0x78</span>,</span><br><span class="line"><span class="number">0x79</span>, <span class="number">0x7a</span>, <span class="number">0x82</span>, <span class="number">0x83</span>, <span class="number">0x84</span>, <span class="number">0x85</span>, <span class="number">0x86</span>, <span class="number">0x87</span>,</span><br><span class="line"><span class="number">0x88</span>, <span class="number">0x89</span>, <span class="number">0x8a</span>, <span class="number">0x92</span>, <span class="number">0x93</span>, <span class="number">0x94</span>, <span class="number">0x95</span>, <span class="number">0x96</span>,</span><br><span class="line"><span class="number">0x97</span>, <span class="number">0x98</span>, <span class="number">0x99</span>, <span class="number">0x9a</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>, <span class="number">0xa4</span>, <span class="number">0xa5</span>,</span><br><span class="line"><span class="number">0xa6</span>, <span class="number">0xa7</span>, <span class="number">0xa8</span>, <span class="number">0xa9</span>, <span class="number">0xaa</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>, <span class="number">0xb4</span>,</span><br><span class="line"><span class="number">0xb5</span>, <span class="number">0xb6</span>, <span class="number">0xb7</span>, <span class="number">0xb8</span>, <span class="number">0xb9</span>, <span class="number">0xba</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>,</span><br><span class="line"><span class="number">0xc4</span>, <span class="number">0xc5</span>, <span class="number">0xc6</span>, <span class="number">0xc7</span>, <span class="number">0xc8</span>, <span class="number">0xc9</span>, <span class="number">0xca</span>, <span class="number">0xd2</span>,</span><br><span class="line"><span class="number">0xd3</span>, <span class="number">0xd4</span>, <span class="number">0xd5</span>, <span class="number">0xd6</span>, <span class="number">0xd7</span>, <span class="number">0xd8</span>, <span class="number">0xd9</span>, <span class="number">0xda</span>,</span><br><span class="line"><span class="number">0xe2</span>, <span class="number">0xe3</span>, <span class="number">0xe4</span>, <span class="number">0xe5</span>, <span class="number">0xe6</span>, <span class="number">0xe7</span>, <span class="number">0xe8</span>, <span class="number">0xe9</span>,</span><br><span class="line"><span class="number">0xea</span>, <span class="number">0xf2</span>, <span class="number">0xf3</span>, <span class="number">0xf4</span>, <span class="number">0xf5</span>, <span class="number">0xf6</span>, <span class="number">0xf7</span>, <span class="number">0xf8</span>,</span><br><span class="line"><span class="number">0xf9</span>, <span class="number">0xfa</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参照jpeg官方的文件交换格式将标准霍夫曼表转换为图像中应用的包含（Huffman_size、Huffman_code）的相应四张查询表。     </p><p>在《ISO/IEC10918-1, 1993(e), Annex C》中，用三个流程图，进行了详细的阐述，下面是其相应的官方转换Matlab代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">% 根据DHT产生HUFFSIZE[]、HUFFCODE[]</span><br><span class="line">% 参考<span class="string">"ISO/IEC10918-1, 1993(e), Annex C"</span></span><br><span class="line">% dxq@<span class="number">2014</span><span class="number">-04</span><span class="number">-24</span></span><br><span class="line"></span><br><span class="line">function[ehufco,ehufsi]=dedht(dht)</span><br><span class="line">bits =dht(<span class="number">1</span>:<span class="number">16</span>);</span><br><span class="line">huffval =dht(<span class="number">17</span>:end);</span><br><span class="line">% 参考<span class="string">"ISO/IEC10918-1, 1993(e), Annex C ,Figure C.1"</span></span><br><span class="line">k = <span class="number">0</span> ;</span><br><span class="line">j = <span class="number">1</span> ;</span><br><span class="line">fori=<span class="number">1</span>:<span class="number">16</span></span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span>:bits(i)</span><br><span class="line">        huffsize(k+<span class="number">1</span>)=i;</span><br><span class="line">        k=k+<span class="number">1</span>;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">huffsize(k+<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line">lastk = k;</span><br><span class="line"></span><br><span class="line">% 参考<span class="string">"ISO/IEC10918-1, 1993(e), Annex C ,Figure C.2"</span></span><br><span class="line">code = <span class="number">0</span>;</span><br><span class="line">k=<span class="number">1</span>;</span><br><span class="line">si =huffsize(<span class="number">1</span>);</span><br><span class="line">whilehuffsize(k)&gt;<span class="number">0</span></span><br><span class="line">    huffcode(k)=code ;</span><br><span class="line">    code = code + <span class="number">1</span> ;</span><br><span class="line">    k = k+ <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> huffsize(k)==si</span><br><span class="line">        huffcode(k)=code ;</span><br><span class="line">        code = code + <span class="number">1</span> ;</span><br><span class="line">        k = k+ <span class="number">1</span> ;</span><br><span class="line">    end</span><br><span class="line">    <span class="keyword">if</span> huffsize(k)==<span class="number">0</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    end</span><br><span class="line">    code = code * <span class="number">2</span> ;</span><br><span class="line">    si = si + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> huffsize(k)~= si</span><br><span class="line">        code = code * <span class="number">2</span> ;</span><br><span class="line">        si = si + <span class="number">1</span>;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% 参考<span class="string">"ISO/IEC10918-1, 1993(e), Annex C ,Figure C.3"</span></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:lastk</span><br><span class="line">    i=huffval(k);</span><br><span class="line">    ehufco(i+<span class="number">1</span>)=uint32(huffcode(k));</span><br><span class="line">    ehufsi(i+<span class="number">1</span>)=uint32(huffsize(k));</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>改写为c++代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JpegCompress::InitHuffmanTables()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> code_value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Standard_DC_Luminance_NRCodes[i<span class="number">-1</span>]; j++)</span><br><span class="line">&#123;</span><br><span class="line">Y_DC_Huffman[Standard_DC_Luminance_Values[pos]].value = code_value;</span><br><span class="line">Y_DC_Huffman[Standard_DC_Luminance_Values[pos]].length = i;</span><br><span class="line">pos++;</span><br><span class="line">code_value++;</span><br><span class="line">&#125;</span><br><span class="line">code_value *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos = <span class="number">0</span>; code_value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Standard_AC_Luminance_NRCodes[i<span class="number">-1</span>]; j++)</span><br><span class="line">&#123;</span><br><span class="line">Y_AC_Huffman[Standard_AC_Luminance_Values[pos]].value = code_value;</span><br><span class="line">Y_AC_Huffman[Standard_AC_Luminance_Values[pos]].length = i;</span><br><span class="line">pos++;</span><br><span class="line">code_value++;</span><br><span class="line">&#125;</span><br><span class="line">code_value *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos = <span class="number">0</span>; code_value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Standard_DC_Chrominance_NRCodes[i<span class="number">-1</span>]; j++)</span><br><span class="line">&#123;</span><br><span class="line">CbCr_DC_Huffman[Standard_DC_Chrominance_Values[pos]].value = code_value;</span><br><span class="line">CbCr_DC_Huffman[Standard_DC_Chrominance_Values[pos]].length = i;</span><br><span class="line">pos++;</span><br><span class="line">code_value++;</span><br><span class="line">&#125;</span><br><span class="line">code_value *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">pos = <span class="number">0</span>; code_value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Standard_AC_Chrominance_NRCodes[i<span class="number">-1</span>]; j++)</span><br><span class="line">&#123;</span><br><span class="line">CbCr_AC_Huffman[Standard_AC_Chrominance_Values[pos]].value = code_value;</span><br><span class="line">CbCr_AC_Huffman[Standard_AC_Chrominance_Values[pos]].length = i;</span><br><span class="line">pos++;</span><br><span class="line">code_value++;</span><br><span class="line">&#125;</span><br><span class="line">code_value *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>d. 范式霍夫曼编码的格式：</strong></p><p>为了提高储存效率, JPEG 里并不直接保存数值, 而是将数值按位数分成 16 组:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                数值                 组              实际保存值</span><br><span class="line">                <span class="number">0</span>                   <span class="number">0</span>                   -</span><br><span class="line">              <span class="number">-1</span>,<span class="number">1</span>                  <span class="number">1</span>                  <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">           <span class="number">-3</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">3</span>                <span class="number">2</span>              <span class="number">00</span>,<span class="number">01</span>,<span class="number">10</span>,<span class="number">11</span></span><br><span class="line">     <span class="number">-7</span>,<span class="number">-6</span>,<span class="number">-5</span>,<span class="number">-4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>            <span class="number">3</span>    <span class="number">000</span>,<span class="number">001</span>,<span class="number">010</span>,<span class="number">011</span>,<span class="number">100</span>,<span class="number">101</span>,<span class="number">110</span>,<span class="number">111</span></span><br><span class="line">       <span class="number">-15</span>,..,<span class="number">-8</span>,<span class="number">8</span>,..,<span class="number">15</span>            <span class="number">4</span>       <span class="number">0000</span>,..,<span class="number">0111</span>,<span class="number">1000</span>,..,<span class="number">1111</span></span><br><span class="line">      <span class="number">-31</span>,..,<span class="number">-16</span>,<span class="number">16</span>,..,<span class="number">31</span>           <span class="number">5</span>     <span class="number">00000</span>,..,<span class="number">01111</span>,<span class="number">10000</span>,..,<span class="number">11111</span></span><br><span class="line">      <span class="number">-63</span>,..,<span class="number">-32</span>,<span class="number">32</span>,..,<span class="number">63</span>           <span class="number">6</span>                   .</span><br><span class="line">     <span class="number">-127</span>,..,<span class="number">-64</span>,<span class="number">64</span>,..,<span class="number">127</span>          <span class="number">7</span>                   .</span><br><span class="line">    <span class="number">-255</span>,..,<span class="number">-128</span>,<span class="number">128</span>,..,<span class="number">255</span>         <span class="number">8</span>                   .</span><br><span class="line">    <span class="number">-511</span>,..,<span class="number">-256</span>,<span class="number">256</span>,..,<span class="number">511</span>         <span class="number">9</span>                   .</span><br><span class="line">   <span class="number">-1023</span>,..,<span class="number">-512</span>,<span class="number">512</span>,..,<span class="number">1023</span>       <span class="number">10</span>                   .</span><br><span class="line">  <span class="number">-2047</span>,..,<span class="number">-1024</span>,<span class="number">1024</span>,..,<span class="number">2047</span>      <span class="number">11</span>                   .</span><br><span class="line">  <span class="number">-4095</span>,..,<span class="number">-2048</span>,<span class="number">2048</span>,..,<span class="number">4095</span>      <span class="number">12</span>                   .</span><br><span class="line">  <span class="number">-8191</span>,..,<span class="number">-4096</span>,<span class="number">4096</span>,..,<span class="number">8191</span>      <span class="number">13</span>                   .</span><br><span class="line"> <span class="number">-16383</span>,..,<span class="number">-8192</span>,<span class="number">8192</span>,..,<span class="number">16383</span>     <span class="number">14</span>                   .</span><br><span class="line"><span class="number">-32767</span>,..,<span class="number">-16384</span>,<span class="number">16384</span>,..,<span class="number">32767</span>    <span class="number">15</span>                   .</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//范式霍夫曼编码表数值范围</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">short</span> paradigm_table[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>,<span class="number">256</span>,<span class="number">512</span>,<span class="number">1024</span>,<span class="number">2048</span>,<span class="number">4096</span>,<span class="number">8192</span>,<span class="number">16384</span>,<span class="number">32768</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((value &amp; paradigm_table[pos]) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">newByte = newByte  | paradigm_table[newBytePos];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>至此，终于完成了霍夫曼编码。</strong></p><h4 id="6-jpeg文件的写入"><a href="#6-jpeg文件的写入" class="headerlink" title="6.jpeg文件的写入"></a>6.jpeg文件的写入</h4><p>查询官方的jpeg格式要求，附在txt文档中。</p><p><strong>jpeg头文件：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JpegCompress::JpegHeader(FILE* fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//SOI</span></span><br><span class="line">WriteShort(<span class="number">0xFFD8</span>, fp);<span class="comment">// marker = 0xFFD8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//APPO</span></span><br><span class="line">WriteShort(<span class="number">0xFFE0</span>,fp);<span class="comment">// marker = 0xFFE0</span></span><br><span class="line">WriteShort(<span class="number">16</span>, fp);<span class="comment">// length = 16 for usual JPEG</span></span><br><span class="line">fwrite(<span class="string">"JFIF"</span>, <span class="number">1</span>, <span class="number">5</span>, fp);<span class="comment">// 'JFIF\0'</span></span><br><span class="line">WriteByte(<span class="number">1</span>, fp);<span class="comment">// version_hi</span></span><br><span class="line">WriteByte(<span class="number">1</span>, fp);<span class="comment">// version_low</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">// xyunits = 0 no units, normal density</span></span><br><span class="line">WriteShort(<span class="number">1</span>, fp);<span class="comment">// xdensity</span></span><br><span class="line">WriteShort(<span class="number">1</span>, fp);<span class="comment">// ydensity</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">// thumbWidth</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">// thumbHeight</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DQT</span></span><br><span class="line">WriteShort(<span class="number">0xFFDB</span>, fp);<span class="comment">//marker = 0xFFDB</span></span><br><span class="line">WriteShort(<span class="number">132</span>, fp);<span class="comment">//size=132</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">//QTYinfo== 0:  bit 0..3: number of QT = 0 (table for Y) </span></span><br><span class="line"><span class="comment">//bit 4..7: precision of QT</span></span><br><span class="line"><span class="comment">//bit 8: 0</span></span><br><span class="line">fwrite(Y_Table, <span class="number">1</span>,  <span class="number">64</span>, fp);<span class="comment">//YTable</span></span><br><span class="line">WriteByte(<span class="number">1</span>, fp);<span class="comment">//QTCbinfo = 1 (quantization table for Cb,Cr)</span></span><br><span class="line">fwrite(CbCr_Table, <span class="number">1</span>, <span class="number">64</span>, fp);<span class="comment">//CbCrTable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SOFO</span></span><br><span class="line">WriteShort(<span class="number">0xFFC0</span>, fp);<span class="comment">//marker = 0xFFC0</span></span><br><span class="line">WriteShort(<span class="number">17</span>, fp);<span class="comment">//length = 17 for a truecolor YCbCr JPG</span></span><br><span class="line">WriteByte(<span class="number">8</span>, fp);<span class="comment">//precision = 8: 8 bits/sample </span></span><br><span class="line">WriteShort(Height&amp;<span class="number">0xFFFF</span>, fp);<span class="comment">//height</span></span><br><span class="line">WriteShort(Width&amp;<span class="number">0xFFFF</span>, fp);<span class="comment">//width</span></span><br><span class="line">WriteByte(<span class="number">3</span>, fp);<span class="comment">//nrofcomponents = 3</span></span><br><span class="line"></span><br><span class="line">WriteByte(<span class="number">1</span>, fp);<span class="comment">//IdY = 1</span></span><br><span class="line">WriteByte(<span class="number">0x11</span>, fp);<span class="comment">//HVY sampling factors for Y (bit 0-3 vert., 4-7 hor.)(SuBamp 1x1)</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">//QTY </span></span><br><span class="line"></span><br><span class="line">WriteByte(<span class="number">2</span>, fp);<span class="comment">//IdCb = 2</span></span><br><span class="line">WriteByte(<span class="number">0x11</span>, fp);<span class="comment">//HVCb = 0x11(SuBamp 1x1)</span></span><br><span class="line">WriteByte(<span class="number">1</span>, fp);<span class="comment">//QTCb = 1</span></span><br><span class="line"></span><br><span class="line">WriteByte(<span class="number">3</span>, fp);<span class="comment">//IdCr = 3</span></span><br><span class="line">WriteByte(<span class="number">0x11</span>, fp);<span class="comment">//HVCr = 0x11 (SuBamp 1x1)</span></span><br><span class="line">WriteByte(<span class="number">1</span>, fp);<span class="comment">//QTCr </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DHT</span></span><br><span class="line">WriteShort(<span class="number">0xFFC4</span>, fp);<span class="comment">//marker = 0xFFC4</span></span><br><span class="line">WriteShort(<span class="number">0x01A2</span>, fp);<span class="comment">//length = 0x01A2</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">//HTYDCinfo bit 0..3</span></span><br><span class="line"><span class="comment">//bit 4</span></span><br><span class="line"><span class="comment">//bit 5..7</span></span><br><span class="line">fwrite(Standard_DC_Luminance_NRCodes, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_DC_Luminance_NRCodes), fp);<span class="comment">//DC_L_NRC</span></span><br><span class="line">fwrite(Standard_DC_Luminance_Values, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_DC_Luminance_Values), fp);<span class="comment">//DC_L_VALUE</span></span><br><span class="line">WriteByte(<span class="number">0x10</span>, fp);<span class="comment">//HTYACinfo</span></span><br><span class="line">fwrite(Standard_AC_Luminance_NRCodes, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_AC_Luminance_NRCodes), fp);</span><br><span class="line">fwrite(Standard_AC_Luminance_Values, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_AC_Luminance_Values), fp); </span><br><span class="line">WriteByte(<span class="number">0x01</span>, fp);<span class="comment">//HTCbDCinfo</span></span><br><span class="line">fwrite(Standard_DC_Chrominance_NRCodes, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_DC_Chrominance_NRCodes), fp);</span><br><span class="line">fwrite(Standard_DC_Chrominance_Values, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_DC_Chrominance_Values), fp);</span><br><span class="line">WriteByte(<span class="number">0x11</span>, fp);<span class="comment">//HTCbACinfo</span></span><br><span class="line">fwrite(Standard_AC_Chrominance_NRCodes, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_AC_Chrominance_NRCodes), fp);</span><br><span class="line">fwrite(Standard_AC_Chrominance_Values, <span class="number">1</span>, <span class="keyword">sizeof</span>(Standard_AC_Chrominance_Values), fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//SOS</span></span><br><span class="line">WriteShort(<span class="number">0xFFDA</span>, fp);<span class="comment">//marker = 0xFFC4</span></span><br><span class="line">WriteShort(<span class="number">12</span>, fp);<span class="comment">//length = 12</span></span><br><span class="line">WriteByte(<span class="number">3</span>, fp);<span class="comment">//nrofcomponents, Should be 3: truecolor JPG</span></span><br><span class="line"></span><br><span class="line">WriteByte(<span class="number">1</span>, fp);<span class="comment">//Idy=1</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">//HTYbits 0..3: AC table (0..3)</span></span><br><span class="line"><span class="comment">//bits 4..7: DC table (0..3)</span></span><br><span class="line">WriteByte(<span class="number">2</span>, fp);<span class="comment">//IdCb</span></span><br><span class="line">WriteByte(<span class="number">0x11</span>, fp);<span class="comment">//HTCb</span></span><br><span class="line"></span><br><span class="line">WriteByte(<span class="number">3</span>, fp);<span class="comment">//IdCr</span></span><br><span class="line">WriteByte(<span class="number">0x11</span>, fp);<span class="comment">//HTCr</span></span><br><span class="line"></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">//Ss</span></span><br><span class="line">WriteByte(<span class="number">0x3F</span>, fp);<span class="comment">//Se</span></span><br><span class="line">WriteByte(<span class="number">0</span>, fp);<span class="comment">//Bf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编码部分的写入：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JpegCompress::WriteToJpeg(<span class="keyword">const</span> Bit* B, <span class="keyword">int</span> counts, <span class="keyword">int</span>&amp; newByte, <span class="keyword">int</span>&amp; newBytePos, FILE* fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;counts; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> value = B[i].value;</span><br><span class="line"><span class="keyword">int</span> pos = B[i].length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (pos &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((value &amp; paradigm_table[pos]) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">newByte = newByte  | paradigm_table[newBytePos];</span><br><span class="line">&#125;</span><br><span class="line">pos--;</span><br><span class="line">newBytePos--;</span><br><span class="line"><span class="keyword">if</span> (newBytePos &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">WriteByte((<span class="keyword">unsigned</span> <span class="keyword">char</span>)(newByte), fp);</span><br><span class="line"><span class="keyword">if</span> (newByte == <span class="number">255</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 特殊处理</span></span><br><span class="line">WriteByte((<span class="keyword">unsigned</span> <span class="keyword">char</span>)(<span class="number">0x00</span>), fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化更新</span></span><br><span class="line">newBytePos = <span class="number">7</span>;</span><br><span class="line">newByte = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-实现效果："><a href="#7-实现效果：" class="headerlink" title="7.实现效果："></a>7.实现效果：</h4><p>对不同等级的量化程度进行测试，均得到理想效果：</p><p>例如下面是量化等级为5时的结果图：</p><p><img src="https://img-blog.csdnimg.cn/20181209192830119.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20181209192837786.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlcnJ5MDUyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>参考文献：</strong></p><p><a href="https://www.codingnow.com/2000/download/jpeg.txt" target="_blank" rel="noopener">https://www.codingnow.com/2000/download/jpeg.txt</a></p><p><a href="https://www.impulseadventure.com/photo/jpeg-huffman-coding.html" target="_blank" rel="noopener">https://www.impulseadventure.com/photo/jpeg-huffman-coding.html</a></p><p><a href="https://www.w3.org/Graphics/JPEG/jfif.txt" target="_blank" rel="noopener">https://www.w3.org/Graphics/JPEG/jfif.txt</a></p><p><a href="https://blog.csdn.net/carson2005/article/details/7753499" target="_blank" rel="noopener">https://blog.csdn.net/carson2005/article/details/7753499</a></p><p><a href="https://blog.csdn.net/fzh2712/article/details/28318715" target="_blank" rel="noopener">https://blog.csdn.net/fzh2712/article/details/28318715</a></p><p><strong>附录：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">附:JPEG 文件格式</span><br><span class="line">~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - 文件头 (2 bytes):  $ff, $d8 (SOI) (JPEG 文件标识)</span></span><br><span class="line"><span class="code">  - 任意数量的段 , 见后面</span></span><br><span class="line"><span class="code">  - 文件结束 (2 bytes): $ff, $d9 (EOI)</span></span><br><span class="line"></span><br><span class="line">段的格式:</span><br><span class="line">~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - header (4 bytes):</span></span><br><span class="line"><span class="code">       $ff     段标识</span></span><br><span class="line"><span class="code">        n      段的类型 (1 byte)</span></span><br><span class="line"><span class="code">       sh, sl  该段长度, 包括这两个字节, 但是不包括前面的 $ff 和 n.</span></span><br><span class="line"><span class="code">               注意: 长度不是 intel 次序, 而是 Motorola 的, 高字节在前,</span></span><br><span class="line"><span class="code">       低字节在后!</span></span><br><span class="line"><span class="code">  - 该段的内容, 最多 65533 字节</span></span><br><span class="line"></span><br><span class="line"><span class="code"> 注意:</span></span><br><span class="line"><span class="code">  - 有一些无参数的段 (下面那些前面注明星号的)</span></span><br><span class="line"><span class="code">    这些段没有长度描述 (而且没有内容), 只有 $ff 和类型字节.</span></span><br><span class="line"><span class="code">  - 段之间无论有多少 $ff 都是合法的, 必须被忽略掉.</span></span><br><span class="line"></span><br><span class="line">段的类型:</span><br><span class="line">~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">   *TEM   = $01   可以忽略掉</span></span><br><span class="line"></span><br><span class="line"><span class="code">    SOF0  = $c0   帧开始 (baseline JPEG), 细节附后</span></span><br><span class="line"><span class="code">    SOF1  = $c1   dito</span></span><br><span class="line"><span class="code">    SOF2  = $c2   通常不支持</span></span><br><span class="line"><span class="code">    SOF3  = $c3   通常不支持</span></span><br><span class="line"></span><br><span class="line"><span class="code">    SOF5  = $c5   通常不支持</span></span><br><span class="line"><span class="code">    SOF6  = $c6   通常不支持</span></span><br><span class="line"><span class="code">    SOF7  = $c7   通常不支持</span></span><br><span class="line"></span><br><span class="line"><span class="code">    SOF9  = $c9   arithmetic 编码(Huffman 的一种扩展算法), 通常不支持</span></span><br><span class="line"><span class="code">    SOF10 = $ca   通常不支持</span></span><br><span class="line"><span class="code">    SOF11 = $cb   通常不支持</span></span><br><span class="line"></span><br><span class="line"><span class="code">    SOF13 = $cd   通常不支持</span></span><br><span class="line"><span class="code">    SOF14 = $ce   通常不支持</span></span><br><span class="line"><span class="code">    SOF14 = $ce   通常不支持</span></span><br><span class="line"><span class="code">    SOF15 = $cf   通常不支持</span></span><br><span class="line"></span><br><span class="line"><span class="code">    DHT   = $c4   定义 Huffman Table,  细节附后</span></span><br><span class="line"><span class="code">    JPG   = $c8   未定义/保留 (引起解码错误)</span></span><br><span class="line"><span class="code">    DAC   = $cc   定义 Arithmetic Table, 通常不支持</span></span><br><span class="line"></span><br><span class="line"><span class="code">   *RST0  = $d0   RSTn 用于 resync, 通常被忽略</span></span><br><span class="line"><span class="code">   *RST1  = $d1</span></span><br><span class="line"><span class="code">   *RST2  = $d2</span></span><br><span class="line"><span class="code">   *RST3  = $d3</span></span><br><span class="line"><span class="code">   *RST4  = $d4</span></span><br><span class="line"><span class="code">   *RST5  = $d5</span></span><br><span class="line"><span class="code">   *RST6  = $d6</span></span><br><span class="line"><span class="code">   *RST7  = $d7</span></span><br><span class="line"></span><br><span class="line"><span class="code">    SOI   = $d8   图片开始</span></span><br><span class="line"><span class="code">    EOI   = $d9   图片结束</span></span><br><span class="line"><span class="code">    SOS   = $da   扫描行开始, 细节附后</span></span><br><span class="line"><span class="code">    DQT   = $db   定义 Quantization Table, 细节附后</span></span><br><span class="line"><span class="code">    DNL   = $dc   通常不支持, 忽略</span></span><br><span class="line"><span class="code">    DRI   = $dd   定义重新开始间隔, 细节附后</span></span><br><span class="line"><span class="code">    DHP   = $de   忽略 (跳过)</span></span><br><span class="line"><span class="code">    EXP   = $df   忽略 (跳过)</span></span><br><span class="line"></span><br><span class="line"><span class="code">    APP0  = $e0   JFIF APP0 segment marker (细节略)</span></span><br><span class="line"><span class="code">    APP15 = $ef   忽略</span></span><br><span class="line"></span><br><span class="line"><span class="code">    JPG0  = $f0   忽略 (跳过)</span></span><br><span class="line"><span class="code">    JPG13 = $fd   忽略 (跳过)</span></span><br><span class="line"><span class="code">    COM   = $fe   注释, 细节附后</span></span><br><span class="line"></span><br><span class="line"><span class="code"> 其它的段类型都保留必须跳过</span></span><br><span class="line"></span><br><span class="line">SOF0: Start Of Frame 0:</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - $ff, $c0 (SOF0)</span></span><br><span class="line"><span class="code">  - 长度 (高字节, 低字节), 8+components*3</span></span><br><span class="line"><span class="code">  - 数据精度 (1 byte) 每个样本位数, 通常是 8 (大多数软件不支持 12 和 16)</span></span><br><span class="line"><span class="code">  - 图片高度 (高字节, 低字节), 如果不支持 DNL 就必须 &gt;0</span></span><br><span class="line"><span class="code">  - 图片宽度 (高字节, 低字节), 如果不支持 DNL 就必须 &gt;0</span></span><br><span class="line"><span class="code">  - components 数量(1 byte), 灰度图是 1, YCbCr/YIQ 彩色图是 3, CMYK 彩色图</span></span><br><span class="line"><span class="code">    是 4</span></span><br><span class="line"><span class="code">  - 每个 component: 3 bytes</span></span><br><span class="line"><span class="code">     - component id (1 = Y, 2 = Cb, 3 = Cr, 4 = I, 5 = Q)</span></span><br><span class="line"><span class="code">     - 采样系数 (bit 0-3 vert., 4-7 hor.)</span></span><br><span class="line"><span class="code">     - quantization table 号</span></span><br><span class="line"></span><br><span class="line">DRI: Define Restart Interval:</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - $ff, $dd (DRI)</span></span><br><span class="line"><span class="code">  - 长度 (高字节, 低字节), 必须是 4</span></span><br><span class="line"><span class="code">  - MCU 块的单元中的重新开始间隔 (高字节, 低字节),</span></span><br><span class="line"><span class="code">    意思是说, 每 n 个 MCU 块就有一个 RSTn 标记.</span></span><br><span class="line"><span class="code">    第一个标记是 RST0, 然后是 RST1 等, RST7 后再从 RST0 重复 </span></span><br><span class="line"></span><br><span class="line">DQT: Define Quantization Table:</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - $ff, $db (DQT)</span></span><br><span class="line"><span class="code">  - 长度 (高字节, 低字节)</span></span><br><span class="line"><span class="code">  - QT 信息 (1 byte):</span></span><br><span class="line"><span class="code">     bit 0..3: QT 号(0..3, 否则错误)</span></span><br><span class="line"><span class="code">     bit 4..7: QT 精度, 0 = 8 bit, 否则 16 bit</span></span><br><span class="line"><span class="code">  - n 字节的 QT, n = 64*(精度+1)</span></span><br><span class="line"></span><br><span class="line"><span class="code"> 备注:</span></span><br><span class="line"><span class="code">  - 一个单独的 DQT 段可以包含多个 QT, 每个都有自己的信息字节</span></span><br><span class="line"><span class="code">  - 当精度=1 (16 bit), 每个字都是高位在前低位在后</span></span><br><span class="line"></span><br><span class="line">DAC: Define Arithmetic Table:</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"><span class="code"> 法律原因, 现在的软件不支持 arithmetic 编码.</span></span><br><span class="line"><span class="code"> 不能生产使用 arithmetic 编码的 JPEG 文件</span></span><br><span class="line"></span><br><span class="line">DHT: Define Huffman Table:</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - $ff, $c4 (DHT)</span></span><br><span class="line"><span class="code">  - 长度 (高字节, 低字节)</span></span><br><span class="line"><span class="code">  - HT 信息 (1 byte):</span></span><br><span class="line"><span class="code">     bit 0..3: HT 号 (0..3, 否则错误)</span></span><br><span class="line"><span class="code">     bit 4   : HT 类型, 0 = DC table, 1 = AC table</span></span><br><span class="line"><span class="code">     bit 5..7: 必须是 0</span></span><br><span class="line"><span class="code">  - 16 bytes: 长度是 1..16 代码的符号数. 这 16 个数的和应该 &lt;=256</span></span><br><span class="line"><span class="code">  - n bytes: 一个包含了按递增次序代码长度排列的符号表</span></span><br><span class="line"><span class="code">    (n = 代码总数)</span></span><br><span class="line"></span><br><span class="line"><span class="code"> 备注:</span></span><br><span class="line"><span class="code">  - 一个单独的 DHT 段可以包含多个 HT, 每个都有自己的信息字节</span></span><br><span class="line"></span><br><span class="line">COM: 注释:</span><br><span class="line">~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - $ff, $fe (COM)</span></span><br><span class="line"><span class="code">  - 注释长度 (高字节, 低字节) = L+2</span></span><br><span class="line"><span class="code">  - 注释为长度为 L 的字符流</span></span><br><span class="line"></span><br><span class="line">SOS: Start Of Scan:</span><br><span class="line">~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="code">  - $ff, $da (SOS)</span></span><br><span class="line"><span class="code">  - 长度 (高字节, 低字节), 必须是 6+2*(扫描行内组件的数量)</span></span><br><span class="line"><span class="code">  - 扫描行内组件的数量 (1 byte), 必须 &gt;= 1 , &lt;=4 (否则是错的) 通常是 3</span></span><br><span class="line"><span class="code">  - 每个组件: 2 bytes</span></span><br><span class="line"><span class="code">     - component id (1 = Y, 2 = Cb, 3 = Cr, 4 = I, 5 = Q), 见 SOF0</span></span><br><span class="line"><span class="code">     - 使用的 Huffman 表:</span></span><br><span class="line"><span class="code">- bit 0..3: AC table (0..3)</span></span><br><span class="line"><span class="code">- bit 4..7: DC table (0..3)</span></span><br><span class="line"><span class="code">  - 忽略 3 bytes (???)</span></span><br><span class="line"></span><br><span class="line"><span class="code"> 备注:</span></span><br><span class="line"><span class="code">  - 图片数据 (一个个扫描行) 紧接着 SOS 段.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;编译环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;windows10下MinGW&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;c++ &amp;amp;&amp;amp; CImg库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行命令&lt;/strong&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="多媒体技术" scheme="http://yoursite.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="多媒体技术" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
